<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Faculty Staff Allocation Interface</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        @page {
            size: A4 landscape;
            margin: 12mm;
        }

        body {
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(circle at 0% 0%, rgba(79, 70, 229, 0.35), rgba(79, 70, 229, 0)) no-repeat,
                        radial-gradient(circle at 100% 0%, rgba(14, 165, 233, 0.32), rgba(14, 165, 233, 0)) no-repeat,
                        #0f172a;
            color: #0f172a;
            min-height: 100vh;
            line-height: 1.5;
        }

        .is-hidden {
            display: none !important;
        }

        .app-alert {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;
            z-index: 10000;
        }

        .app-alert__overlay {
            position: absolute;
            inset: 0;
            background: rgba(15, 23, 42, 0.45);
            backdrop-filter: blur(6px);
        }

        .app-alert__dialog {
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
            gap: 18px;
            width: min(420px, 100%);
            padding: 28px 32px;
            border-radius: 20px;
            background: #ffffff;
            color: #0f172a;
            box-shadow: 0 30px 70px rgba(15, 23, 42, 0.32);
        }

        .app-alert__content {
            display: flex;
            gap: 16px;
            align-items: flex-start;
        }

        .app-alert__icon {
            flex-shrink: 0;
            width: 48px;
            height: 48px;
            border-radius: 16px;
            background: rgba(79, 70, 229, 0.12);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.9rem;
            line-height: 1;
        }

        .app-alert__text {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .app-alert__title {
            font-size: 1.1rem;
            font-weight: 700;
            color: #0f172a;
        }

        .app-alert__message {
            font-size: 0.95rem;
            color: #334155;
            white-space: pre-wrap;
        }

        .app-alert__input {
            display: none;
        }

        .app-alert__input:not(.is-hidden) {
            display: block;
        }

        .app-alert__field {
            width: 100%;
            padding: 12px 16px;
            border-radius: 14px;
            border: 1px solid rgba(148, 163, 184, 0.45);
            background: rgba(255, 255, 255, 0.9);
            font-size: 0.95rem;
            color: #0f172a;
            outline: none;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        .app-alert__field:focus {
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.18);
        }

        .app-alert__actions {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            flex-wrap: wrap;
        }

        .app-alert__button {
            padding: 10px 22px;
            border-radius: 999px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease, color 0.2s ease;
        }

        .app-alert__button--primary {
            background: linear-gradient(135deg, #4f46e5, #2563eb);
            color: #ffffff;
            box-shadow: 0 14px 28px rgba(79, 70, 229, 0.28);
        }

        .app-alert__button--primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 18px 36px rgba(79, 70, 229, 0.34);
        }

        .app-alert__button--primary:focus {
            outline: 2px solid rgba(79, 70, 229, 0.45);
            outline-offset: 3px;
        }

        .app-alert__button--secondary {
            background: rgba(148, 163, 184, 0.18);
            color: #0f172a;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6);
        }

        .app-alert__button--secondary:hover {
            transform: translateY(-1px);
            background: rgba(148, 163, 184, 0.26);
        }

        .app-alert__button--secondary:focus {
            outline: 2px solid rgba(148, 163, 184, 0.6);
            outline-offset: 3px;
        }

        .app-alert__button--danger {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: #ffffff;
            box-shadow: 0 14px 28px rgba(220, 38, 38, 0.28);
        }

        .app-alert__button--danger:hover {
            transform: translateY(-1px);
            box-shadow: 0 18px 36px rgba(220, 38, 38, 0.34);
        }

        .app-alert__button--danger:focus {
            outline: 2px solid rgba(248, 113, 113, 0.6);
            outline-offset: 3px;
        }

        .app-shell {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .app-hero {
            position: relative;
            color: #f8fafc;
            padding: 56px 6vw 96px;
            overflow: hidden;
        }

        .app-hero::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at top left, rgba(99, 102, 241, 0.4), transparent 60%),
                        radial-gradient(circle at top right, rgba(56, 189, 248, 0.45), transparent 55%),
                        linear-gradient(135deg, rgba(15, 118, 110, 0.25), transparent 60%);
            opacity: 0.9;
        }

        .app-hero__content {
            position: relative;
            z-index: 1;
            max-width: 640px;
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        .app-hero__tag {
            align-self: flex-start;
            padding: 6px 14px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.35);
            border: 1px solid rgba(148, 163, 184, 0.4);
            font-size: 0.78rem;
            letter-spacing: 0.14em;
            text-transform: uppercase;
            color: rgba(226, 232, 240, 0.95);
        }

        .app-hero__title {
            font-size: 2.8rem;
            font-weight: 700;
            letter-spacing: -0.02em;
            line-height: 1.15;
        }

        .app-hero__subtitle {
            font-size: 1.05rem;
            color: rgba(226, 232, 240, 0.85);
            max-width: 540px;
        }

        .app-hero__metrics {
            position: relative;
            z-index: 1;
            margin-top: 36px;
            display: grid;
            gap: 18px;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        }

        .hero-metric {
            background: rgba(15, 23, 42, 0.45);
            border-radius: 18px;
            border: 1px solid rgba(148, 163, 184, 0.45);
            padding: 18px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            box-shadow: 0 20px 45px rgba(15, 23, 42, 0.35);
            backdrop-filter: blur(18px);
        }

        .hero-metric__label {
            font-size: 0.78rem;
            letter-spacing: 0.14em;
            text-transform: uppercase;
            color: rgba(226, 232, 240, 0.72);
        }

        .hero-metric__value {
            font-size: 2.3rem;
            font-weight: 700;
            color: #ffffff;
        }

        .container {
            max-width: 100%;
            width: 100%;
            margin: 0;
        }

        .app-layout {
            display: grid;
            grid-template-columns: minmax(240px, 300px) minmax(0, 1fr);
            gap: 24px;
            padding: 0 clamp(24px, 4vw, 48px) 64px;
            margin-top: -72px;
            position: relative;
            z-index: 2;
        }

        .app-sidebar {
            background: rgba(255, 255, 255, 0.96);
            border-radius: 24px;
            border: 1px solid rgba(15, 23, 42, 0.08);
            box-shadow: 0 30px 70px rgba(15, 23, 42, 0.18);
            padding: 32px 28px;
            display: flex;
            flex-direction: column;
            gap: 28px;
            backdrop-filter: blur(18px);
        }

        .sidebar-intro {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .sidebar-intro h2 {
            font-size: 1.3rem;
            font-weight: 700;
            color: #0f172a;
        }

        .sidebar-intro p {
            font-size: 0.9rem;
            color: #475569;
        }

        .control-groups {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .control-group {
            background: linear-gradient(145deg, rgba(15, 23, 42, 0.04), rgba(15, 23, 42, 0));
            border: 1px solid rgba(148, 163, 184, 0.35);
            border-radius: 20px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.5), 0 12px 28px rgba(15, 23, 42, 0.12);
        }

        .control-group--start {
            border-left: 4px solid #4f46e5;
            background: linear-gradient(145deg, rgba(79, 70, 229, 0.18), rgba(79, 70, 229, 0.05));
        }

        .control-group--workflow {
            border-left: 4px solid #6366f1;
            background: linear-gradient(145deg, rgba(99, 102, 241, 0.16), rgba(99, 102, 241, 0.04));
        }

        .control-group--data {
            border-left: 4px solid #0ea5e9;
            background: linear-gradient(145deg, rgba(14, 165, 233, 0.16), rgba(14, 165, 233, 0.04));
        }

        .control-group--history {
            border-left: 4px solid #f59e0b;
            background: linear-gradient(145deg, rgba(245, 158, 11, 0.16), rgba(245, 158, 11, 0.04));
        }

        .control-group--management {
            border-left: 4px solid #22c55e;
            background: linear-gradient(145deg, rgba(34, 197, 94, 0.16), rgba(34, 197, 94, 0.04));
        }

        .control-group-header {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .control-group-label {
            font-size: 0.85rem;
            letter-spacing: 0.14em;
            text-transform: uppercase;
            color: #0f172a;
            font-weight: 700;
        }

        .control-group-description {
            font-size: 0.86rem;
            color: #475569;
            line-height: 1.4;
        }

        .control-group-buttons {
            display: grid;
            gap: 12px;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 12px 18px;
            border: 1px solid transparent;
            border-radius: 14px;
            cursor: pointer;
            font-size: 0.92rem;
            font-weight: 600;
            line-height: 1.2;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease, border-color 0.2s ease, color 0.2s ease;
            color: #0f172a;
            background: rgba(148, 163, 184, 0.16);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.4);
        }

        .btn-primary {
            background: linear-gradient(135deg, #4f46e5, #2563eb);
            color: #ffffff;
            box-shadow: 0 14px 30px rgba(79, 70, 229, 0.35);
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 18px 36px rgba(79, 70, 229, 0.45);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #64748b, #475569);
            color: #f8fafc;
            box-shadow: 0 14px 28px rgba(71, 85, 105, 0.3);
        }

        .btn-secondary:hover {
            transform: translateY(-1px);
            box-shadow: 0 18px 32px rgba(71, 85, 105, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #059669, #10b981);
            color: #f8fafc;
            box-shadow: 0 14px 28px rgba(16, 185, 129, 0.35);
        }

        .btn-success:hover {
            transform: translateY(-1px);
            box-shadow: 0 18px 34px rgba(16, 185, 129, 0.45);
        }

        .btn-warning {
            background: linear-gradient(135deg, #f59e0b, #f97316);
            color: #ffffff;
            box-shadow: 0 14px 28px rgba(249, 115, 22, 0.35);
        }

        .btn-warning:hover {
            transform: translateY(-1px);
            box-shadow: 0 18px 34px rgba(249, 115, 22, 0.45);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444, #b91c1c);
            color: #ffffff;
            box-shadow: 0 14px 28px rgba(239, 68, 68, 0.32);
        }

        .btn-danger:hover {
            transform: translateY(-1px);
            box-shadow: 0 18px 34px rgba(239, 68, 68, 0.42);
        }

        .btn:disabled {
            opacity: 0.55;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-compact {
            padding: 8px 14px;
            font-size: 0.8rem;
        }

        .app-workspace {
            display: flex;
            flex-direction: column;
            gap: 28px;
        }

        .workspace-panel {
            background: rgba(255, 255, 255, 0.97);
            border-radius: 28px;
            border: 1px solid rgba(15, 23, 42, 0.08);
            box-shadow: 0 30px 70px rgba(15, 23, 42, 0.15);
            display: flex;
            flex-direction: column;
        }

        .workspace-panel--legend .workspace-panel__body {
            padding-top: 16px;
        }

        .workspace-panel__header {
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 28px 32px 0;
        }

        .workspace-panel__header-actions {
            display: flex;
            justify-content: flex-end;
        }

        .workspace-panel__title {
            font-size: 1.45rem;
            font-weight: 700;
            color: #0f172a;
        }

        .workspace-panel__subtitle {
            font-size: 0.95rem;
            color: #475569;
        }

        .workspace-panel__body {
            padding: 24px 32px 32px;
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        .workspace-panel__body--flush {
            padding: 0;
        }

        .workspace-panel--converter .workspace-panel__body {
            gap: 24px;
        }

        @media print {
            html,
            body {
                width: 100%;
            }

            body {
                background: #ffffff !important;
                color: #000000 !important;
                font-size: 0.85rem;
            }

            .app-hero,
            .app-sidebar,
            .workspace-panel:not(.workspace-panel--matrix),
            .workspace-panel__header-actions,
            .app-alert,
            #appAlert,
            .app-footer {
                display: none !important;
            }

            .app-layout {
                grid-template-columns: 1fr !important;
                margin: 0 !important;
                padding: 0 !important;
            }

            .workspace-panel--matrix {
                box-shadow: none !important;
                border: none !important;
                max-width: 100% !important;
            }

            .workspace-panel--matrix .workspace-panel__body {
                padding: 0 !important;
            }

            .timetable-container {
                overflow: visible !important;
                padding: 0 !important;
            }

            .timetable {
                font-size: 0.7rem !important;
            }

            .timetable th {
                padding: 8px 6px !important;
                font-size: 0.75rem !important;
            }

            .timetable td {
                padding: 6px 6px !important;
            }

            .subject-slot {
                padding: 4px 6px !important;
                font-size: 0.7rem !important;
            }
        }

        .converter-intro {
            display: grid;
            gap: 12px;
            padding: 20px;
            border-radius: 20px;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.12), rgba(14, 165, 233, 0.06));
            border: 1px solid rgba(99, 102, 241, 0.25);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6);
        }

        .converter-intro__tag {
            align-self: flex-start;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            padding: 4px 10px;
            border-radius: 999px;
            background: rgba(79, 70, 229, 0.12);
            color: #312e81;
        }

        .converter-intro p {
            font-size: 0.92rem;
            color: #1e293b;
        }

        .converter-steps {
            display: grid;
            gap: 8px;
            margin: 4px 0 0 1.2em;
            font-size: 0.9rem;
            color: #334155;
        }

        .converter-steps li::marker {
            font-weight: 600;
            color: #4f46e5;
        }

        .converter-body {
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        .converter-flow {
            display: grid;
            gap: 20px;
        }

        .converter-step {
            display: flex;
            flex-direction: column;
            gap: 16px;
            padding: 20px;
            border-radius: 20px;
            background: linear-gradient(135deg, rgba(248, 250, 255, 0.95), rgba(226, 232, 240, 0.55));
            border: 1px solid rgba(148, 163, 184, 0.35);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.7);
        }

        .converter-step__header {
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        .converter-step__number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4f46e5, #2563eb);
            color: #ffffff;
            font-weight: 700;
            font-size: 0.85rem;
            flex-shrink: 0;
            box-shadow: 0 6px 12px rgba(79, 70, 229, 0.25);
        }

        .converter-step__title {
            font-size: 1.05rem;
            font-weight: 700;
            color: #0f172a;
        }

        .converter-step__description {
            font-size: 0.88rem;
            color: #475569;
            margin-top: 4px;
        }

        .converter-step__body {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .converter-template-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }

        .converter-template-note {
            font-size: 0.85rem;
        }

        .converter-upload-row {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
        }

        .converter-file-input {
            flex: 1 1 260px;
            min-width: 200px;
            background: rgba(248, 250, 255, 0.95);
            border: 1px solid rgba(148, 163, 184, 0.5);
            border-radius: 12px;
            padding: 10px 12px;
            color: #0f172a;
        }

        .converter-file-input::-webkit-file-upload-button {
            padding: 8px 14px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, #6366f1, #3b82f6);
            color: #ffffff;
            font-weight: 600;
            cursor: pointer;
            margin-right: 12px;
        }

        .converter-file-input::file-selector-button {
            padding: 8px 14px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, #6366f1, #3b82f6);
            color: #ffffff;
            font-weight: 600;
            cursor: pointer;
            margin-right: 12px;
        }

        .converter-file-info {
            font-size: 0.83rem;
            color: #475569;
        }

        .converter-mode-toggle {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 14px;
            border: 1px solid rgba(148, 163, 184, 0.4);
            border-radius: 14px;
            background: rgba(248, 250, 255, 0.9);
            font-size: 0.85rem;
        }

        .converter-mode-toggle__label {
            font-weight: 600;
            color: #334155;
        }

        .converter-mode-toggle__actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .converter-mode-button.is-active {
            background: linear-gradient(135deg, #0ea5e9, #6366f1);
            color: #ffffff;
        }

        .converter-summary-grid {
            display: grid;
            gap: 12px;
        }

        @media (min-width: 680px) {
            .converter-summary-grid {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }
        }

        .converter-summary-card {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 14px;
            border-radius: 14px;
            background: rgba(248, 250, 255, 0.9);
            border: 1px solid rgba(148, 163, 184, 0.35);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6);
        }

        .converter-heading {
            font-size: 1.05rem;
            font-weight: 700;
            color: #0f172a;
        }

        .converter-subheading {
            font-size: 0.85rem;
            font-weight: 600;
            color: #1f2937;
        }

        .converter-row {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
        }

        .converter-options {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            font-size: 0.85rem;
            color: #475569;
        }

        .converter-options label {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-radius: 12px;
            background: rgba(148, 163, 184, 0.16);
            border: 1px solid rgba(148, 163, 184, 0.35);
        }

        .converter-force label {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
            color: #475569;
        }

        .converter-force-input {
            width: 72px;
            padding: 6px 8px;
            border-radius: 8px;
            border: 1px solid rgba(148, 163, 184, 0.5);
            background: rgba(248, 250, 255, 0.95);
            color: #0f172a;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', monospace;
            font-size: 0.85rem;
        }

        .converter-force-input:focus {
            border-color: #4f46e5;
            outline: none;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.18);
        }

        .converter-force-note {
            font-size: 0.78rem;
            margin-top: 4px;
        }

        .converter-summary {
            display: grid;
            gap: 6px;
            font-size: 0.9rem;
            color: #1e293b;
        }

        .converter-summary strong {
            color: #0f172a;
        }

        .converter-summary-options {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .converter-summary-options .converter-pill {
            margin: 0;
        }

        .converter-muted {
            color: #64748b;
        }

        .converter-advanced {
            border: 1px solid rgba(148, 163, 184, 0.35);
            border-radius: 16px;
            padding: 12px 16px;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.04), rgba(14, 165, 233, 0.06));
            color: #1e293b;
        }

        .converter-advanced summary {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            color: #0f172a;
            list-style: none;
        }

        .converter-advanced summary::-webkit-details-marker {
            display: none;
        }

        .converter-advanced summary::after {
            content: '\25BC';
            font-size: 0.8rem;
            color: #6366f1;
            transition: transform 0.2s ease;
        }

        .converter-advanced[open] summary::after {
            transform: rotate(-180deg);
        }

        .converter-advanced summary:focus-visible {
            outline: 2px solid #4f46e5;
            outline-offset: 2px;
            border-radius: 10px;
        }

        .converter-advanced__content {
            margin-top: 12px;
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        .converter-advanced__content .btn {
            width: fit-content;
        }

        .converter-advanced--actions {
            margin-top: 8px;
            background: linear-gradient(135deg, rgba(79, 70, 229, 0.08), rgba(14, 165, 233, 0.05));
        }

        .converter-advanced__description {
            font-size: 0.78rem;
        }

        .converter-status {
            padding: 12px 14px;
            border-radius: 16px;
            border: 1px solid rgba(148, 163, 184, 0.4);
            background: rgba(248, 250, 255, 0.92);
            font-size: 0.85rem;
            color: #1e293b;
        }

        .converter-status + .converter-row {
            margin-top: 8px;
        }

        .converter-status--ready {
            border-color: rgba(34, 197, 94, 0.45);
            background: rgba(34, 197, 94, 0.12);
            color: #065f46;
        }

        .converter-status--success {
            border-color: rgba(14, 165, 233, 0.45);
            background: rgba(14, 165, 233, 0.12);
            color: #075985;
        }

        .converter-status--error {
            border-color: rgba(239, 68, 68, 0.45);
            background: rgba(239, 68, 68, 0.12);
            color: #991b1b;
        }

        .converter-textarea {
            width: 100%;
            min-height: 170px;
            border-radius: 16px;
            border: 1px solid rgba(148, 163, 184, 0.4);
            padding: 12px;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', monospace;
            font-size: 0.85rem;
            color: #0f172a;
            background: rgba(248, 250, 255, 0.92);
            resize: vertical;
        }

        .converter-textarea:focus {
            border-color: #4f46e5;
            outline: none;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.16);
        }

        .converter-actions {
            justify-content: flex-start;
        }

        .converter-preview {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .converter-cells {
            padding: 16px;
            border-radius: 18px;
            border: 1px solid rgba(148, 163, 184, 0.35);
            background: rgba(248, 250, 255, 0.95);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.8);
        }

        .converter-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }

        .converter-table th,
        .converter-table td {
            border-top: 1px solid rgba(148, 163, 184, 0.35);
            padding: 8px 10px;
            text-align: left;
        }

        .converter-table th {
            background: rgba(15, 23, 42, 0.05);
            color: #1f2937;
            font-weight: 600;
        }

        .converter-table td {
            color: #1e293b;
        }

        .converter-pill {
            display: inline-flex;
            align-items: center;
            padding: 2px 8px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.08);
            border: 1px solid rgba(148, 163, 184, 0.45);
            margin: 2px 4px 2px 0;
            font-size: 0.75rem;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', monospace;
            color: #1e293b;
        }

        .converter-footer {
            text-align: center;
            font-size: 0.85rem;
            color: #64748b;
        }

        @media (max-width: 900px) {
            .converter-upload-row {
                flex-direction: column;
                align-items: stretch;
            }

            .converter-row {
                align-items: stretch;
            }

            .converter-actions {
                flex-direction: column;
                align-items: stretch;
            }

            .converter-actions .btn {
                width: 100%;
            }
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
        }

        .legend-item {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 10px 16px;
            border-radius: 999px;
            background: rgba(241, 245, 249, 0.95);
            border: 1px solid rgba(148, 163, 184, 0.35);
            color: #0f172a;
            font-size: 0.85rem;
        }

        .legend-color {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 2px solid transparent;
        }

        .legend-color.available {
            background: rgba(99, 102, 241, 0.7);
            border-color: rgba(99, 102, 241, 0.9);
        }

        .legend-color.allocated {
            background: rgba(248, 113, 113, 0.75);
            border-color: rgba(239, 68, 68, 0.9);
        }

        .legend-color.semester-pair {
            background: rgba(16, 185, 129, 0.75);
            border-color: rgba(5, 150, 105, 0.9);
        }

        .legend-color.clash {
            background: rgba(59, 130, 246, 0.75);
            border-color: rgba(37, 99, 235, 0.9);
        }

        .legend-color.room-clash {
            background: rgba(168, 85, 247, 0.75);
            border-color: rgba(147, 51, 234, 0.9);
        }

        .legend-color.split {
            background: rgba(251, 191, 36, 0.75);
            border-color: rgba(217, 119, 6, 0.9);
        }

        .timetable-container {
            padding: 0;
            background: rgba(248, 250, 255, 0.98);
            border-radius: 0 0 28px 28px;
            overflow-x: auto;
            border-top: 1px solid rgba(15, 23, 42, 0.08);
        }

        .timetable {
            min-width: 900px;
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            font-size: 0.9rem;
        }

        .timetable thead th:first-child {
            border-top-left-radius: 28px;
        }

        .timetable thead th:last-child {
            border-top-right-radius: 28px;
        }

        .timetable th {
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.9), rgba(30, 41, 59, 0.9));
            color: #f8fafc;
            padding: 12px 10px;
            text-align: center;
            font-weight: 600;
            border: none;
        }

        .timetable td {
            padding: 8px;
            border: 1px solid rgba(15, 23, 42, 0.08);
            vertical-align: top;
            min-height: 52px;
            background: rgba(248, 250, 255, 0.96);
            position: relative;
        }

        .timetable tr.timetable-row--wed td {
            background: rgba(240, 253, 250, 0.95);
        }

        .teacher-column {
            background: rgba(15, 23, 42, 0.08);
            font-weight: 600;
            text-align: center;
        }

        .period-row {
            background: rgba(226, 232, 240, 0.6);
            font-weight: 600;
            text-align: center;
            color: #0f172a;
        }

        .period-row.period-row--wed {
            background: rgba(13, 148, 136, 0.12);
            color: #0f766e;
        }

        .tlc-period-label {
            background: rgba(224, 231, 255, 0.85);
            font-weight: 600;
            text-align: center;
            color: #3730a3;
        }

        .tlc-period-cell {
            background: rgba(224, 231, 255, 0.6);
            color: #312e81;
            font-weight: 600;
            text-align: center;
        }

        .tlc-period-editor {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .tlc-period-text {
            font-size: 0.78rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: rgba(49, 46, 129, 0.88);
        }

        .tlc-period-input {
            width: 76px;
            padding: 4px 6px;
            border-radius: 8px;
            border: 1px solid rgba(79, 70, 229, 0.4);
            background: rgba(255, 255, 255, 0.95);
            color: #1e1b4b;
            font-weight: 600;
            text-align: center;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            -moz-appearance: textfield;
        }

        .tlc-period-input:focus {
            outline: none;
            border-color: rgba(79, 70, 229, 0.65);
            box-shadow: 0 0 0 2px rgba(165, 180, 252, 0.55);
        }

        .tlc-period-input::-webkit-outer-spin-button,
        .tlc-period-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .subject-slot {
            background: rgba(99, 102, 241, 0.16);
            border: 1.5px dashed rgba(99, 102, 241, 0.45);
            border-radius: 12px;
            padding: 6px 8px;
            margin: 2px 0;
            cursor: move;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease, border-color 0.2s ease;
            min-height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
            color: #312e81;
        }

        .subject-slot.subject-slot--wed {
            background: rgba(13, 148, 136, 0.18);
            border-color: rgba(13, 148, 136, 0.5);
            color: #0f766e;
        }

        .subject-slot.subject-slot--wed:hover {
            background: rgba(13, 148, 136, 0.26);
            border-color: rgba(13, 148, 136, 0.7);
        }

        .subject-slot:hover {
            background: rgba(79, 70, 229, 0.24);
            border-color: rgba(79, 70, 229, 0.65);
            box-shadow: 0 10px 24px rgba(79, 70, 229, 0.22);
            transform: translateY(-1px);
        }

        .subject-slot.split-subject,
        .subject-slot.split-segment {
            background: rgba(251, 191, 36, 0.2);
            border-color: rgba(245, 158, 11, 0.7);
            color: #8a4f0f;
        }

        .subject-slot.split-subject:hover,
        .subject-slot.split-segment:hover {
            background: rgba(251, 191, 36, 0.28);
            border-color: rgba(217, 119, 6, 0.8);
        }

        .subject-slot.split-subject {
            border-style: dashed;
            flex-direction: column;
            align-items: flex-start;
            justify-content: flex-start;
            gap: 4px;
        }

        .subject-slot.split-segment {
            border-style: solid;
            flex-direction: column;
            align-items: flex-start;
            justify-content: flex-start;
            gap: 4px;
        }

        .subject-slot.split-subject .split-subject-base,
        .subject-slot.split-segment .split-subject-base {
            font-weight: 600;
            font-size: 12px;
        }

        .subject-slot.split-subject .split-subject-details,
        .subject-slot.split-segment .split-subject-details {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            font-weight: 500;
        }

        .split-period-badge {
            background: rgba(217, 119, 6, 0.9);
            color: #ffffff;
            border-radius: 12px;
            padding: 2px 8px;
            font-size: 11px;
            font-weight: 600;
        }

        .split-part-label {
            color: #92400e;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-size: 10px;
        }

        .split-allocation-cell {
            background: rgba(254, 243, 199, 0.4);
        }

        .split-allocation-header {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #92400e;
            margin-bottom: 4px;
        }

        .subject-slot.allocated {
            background: rgba(248, 113, 113, 0.24);
            border: 1.5px solid rgba(239, 68, 68, 0.65);
            color: #b91c1c;
        }

        .subject-slot.allocated:hover {
            background: rgba(248, 113, 113, 0.32);
            border-color: rgba(239, 68, 68, 0.8);
        }

        .drop-zone.clash-cell {
            background: rgba(59, 130, 246, 0.18);
            border-color: rgba(37, 99, 235, 0.75);
        }

        .drop-zone.room-clash-cell {
            background: rgba(168, 85, 247, 0.18);
            border-color: rgba(147, 51, 234, 0.75);
        }

        .drop-zone.semester-pair-cell {
            background: rgba(16, 185, 129, 0.18);
            border-color: rgba(5, 150, 105, 0.75);
        }

        .subject-slot.clash {
            background: rgba(59, 130, 246, 0.18);
            border: 1.5px solid rgba(37, 99, 235, 0.65);
            color: #1d4ed8;
        }

        .subject-slot.room-clash {
            background: rgba(168, 85, 247, 0.18);
            border: 1.5px solid rgba(147, 51, 234, 0.65);
            color: #6b21a8;
        }

        .subject-slot.semester-pair {
            background: rgba(16, 185, 129, 0.2);
            border: 1.5px solid rgba(5, 150, 105, 0.7);
            color: #065f46;
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-items: stretch;
        }

        .subject-slot.semester-pair .semester-pair-item {
            background: rgba(5, 150, 105, 0.12);
            border-radius: 6px;
            padding: 6px 8px;
            font-size: 11px;
            cursor: move;
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-items: stretch;
            text-align: left;
        }

        .subject-slot.semester-pair .semester-pair-item .subject-room-footer {
            margin-top: 4px;
        }

        .subject-slot.semester-pair .semester-pair-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #047857;
            text-align: center;
            border-top: 1px dashed rgba(5, 150, 105, 0.4);
            padding-top: 4px;
            margin-top: 4px;
        }

        .drop-zone.semester-pair-cell.room-clash-cell {
            background: rgba(168, 85, 247, 0.18);
            border-color: rgba(147, 51, 234, 0.75);
        }

        .drop-zone.semester-pair-cell.clash-cell {
            background: rgba(59, 130, 246, 0.18);
            border-color: rgba(37, 99, 235, 0.75);
        }

        .subject-slot.semester-pair.room-clash {
            background: rgba(168, 85, 247, 0.18);
            border: 1.5px solid rgba(147, 51, 234, 0.65);
            color: #6b21a8;
        }

        .subject-slot.semester-pair.clash {
            background: rgba(59, 130, 246, 0.18);
            border: 1.5px solid rgba(37, 99, 235, 0.65);
            color: #1d4ed8;
        }

        .subject-slot.semester-pair.room-clash .semester-pair-item {
            background: rgba(147, 51, 234, 0.08);
        }

        .subject-slot.semester-pair.clash .semester-pair-item {
            background: rgba(37, 99, 235, 0.08);
        }

        .subject-slot.semester-pair.room-clash .semester-pair-label {
            color: #6b21a8;
            border-top-color: rgba(147, 51, 234, 0.3);
        }

        .subject-slot.semester-pair.clash .semester-pair-label {
            color: #1d4ed8;
            border-top-color: rgba(37, 99, 235, 0.3);
        }

        .subject-slot.semester-pair.room-clash .subject-room-tag,
        .subject-slot.semester-pair.room-clash .subject-room-empty {
            background: rgba(147, 51, 234, 0.12);
            color: #6b21a8;
        }

        .subject-slot.semester-pair.clash .subject-room-tag,
        .subject-slot.semester-pair.clash .subject-room-empty {
            background: rgba(37, 99, 235, 0.12);
            color: #1d4ed8;
        }

        .subject-room-footer {
            margin-top: 6px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            width: 100%;
        }

        .subject-slot.split-subject .subject-room-footer,
        .subject-slot.split-segment .subject-room-footer {
            align-items: flex-start;
        }

        .subject-room-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .subject-room-tag,
        .subject-room-empty {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            border-radius: 999px;
            padding: 2px 8px;
            font-size: 10px;
            font-weight: 600;
            background: rgba(30, 64, 175, 0.08);
            color: #1e3a8a;
            white-space: nowrap;
        }

        .subject-slot.allocated .subject-room-tag {
            background: rgba(239, 68, 68, 0.15);
            color: #b91c1c;
        }

        .subject-room-tag--override {
            background: rgba(34, 197, 94, 0.2);
            color: #047857;
        }

        .subject-room-empty {
            background: rgba(148, 163, 184, 0.16);
            color: #475569;
            font-style: italic;
        }

        .subject-room-edit {
            border: none;
            background: rgba(79, 70, 229, 0.18);
            color: #312e81;
            border-radius: 999px;
            padding: 4px 12px;
            font-size: 10px;
            font-weight: 700;
            cursor: pointer;
            transition: background 0.2s ease, color 0.2s ease;
        }

        .subject-room-edit:hover,
        .subject-room-edit:focus {
            background: rgba(79, 70, 229, 0.3);
            color: #1e1b4b;
            outline: none;
        }

        .subject-room-edit:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .subject-slot.subject-slot--with-rooms {
            flex-direction: column;
            align-items: stretch;
            justify-content: flex-start;
            text-align: center;
            gap: 4px;
        }

        .subject-slot.split-subject.subject-slot--with-rooms,
        .subject-slot.split-segment.subject-slot--with-rooms {
            align-items: flex-start;
            text-align: left;
        }

        .subject-pool-grid {
            display: grid;
            gap: 18px;
            margin-top: 18px;
            align-items: flex-start;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        }

        .subject-pool-column {
            background: rgba(255, 255, 255, 0.96);
            border: 1px solid rgba(148, 163, 184, 0.35);
            border-radius: 18px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            box-shadow: 0 18px 36px rgba(15, 23, 42, 0.12);
        }

        .subject-pool-column.subject-pool-column--wed {
            border-color: rgba(13, 148, 136, 0.35);
            box-shadow: 0 20px 34px rgba(13, 148, 136, 0.15);
        }

        .subject-pool-column h4 {
            font-size: 0.95rem;
            font-weight: 700;
            color: #0f172a;
            margin-bottom: 6px;
            text-align: center;
            letter-spacing: 0.02em;
        }

        .subject-pool-column.subject-pool-column--wed h4 {
            color: #0f766e;
        }

        .subject-pool-column-body {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .subject-pool-column-body.drag-over {
            background: rgba(37, 99, 235, 0.12);
            border-radius: 16px;
            outline: 2px dashed rgba(96, 165, 250, 0.8);
            outline-offset: -6px;
        }

        .subject-pool-column-body .subject-slot {
            margin: 0;
        }

        .subject-pool-column--unassigned {
            grid-column: 1 / -1;
            margin-top: 18px;
            border-style: dashed;
        }

        .subject-pool-section {
            margin: 32px clamp(16px, 4vw, 36px) 0;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .subject-pool-header {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .subject-pool-header h3 {
            font-size: 1.1rem;
            font-weight: 700;
            color: #0f172a;
        }

        .subject-pool-count {
            font-size: 0.85rem;
            color: #475569;
            font-weight: 600;
        }

        .subject-pool-description {
            font-size: 0.9rem;
            color: #5d6d7e;
        }

        .subject-pool-empty {
            color: #64748b;
            font-style: italic;
        }

        .timetable-empty-state {
            margin: 32px clamp(16px, 4vw, 36px) 0;
            padding: 28px;
            border-radius: 24px;
            border: 1px dashed rgba(148, 163, 184, 0.6);
            background: rgba(15, 23, 42, 0.05);
            color: #475569;
            text-align: center;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.5);
        }

        .timetable-empty-state h3 {
            font-size: 1.15rem;
            font-weight: 700;
            color: #1e1b4b;
            margin-bottom: 8px;
        }

        .timetable-empty-state p {
            font-size: 0.95rem;
            line-height: 1.6;
            max-width: 560px;
            margin: 0 auto;
        }

        .teacher-period-summary {
            margin: 28px clamp(16px, 4vw, 36px) 0;
            padding: 28px;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.12), rgba(56, 189, 248, 0.1));
            border-radius: 24px;
            border: 1px solid rgba(99, 102, 241, 0.28);
            box-shadow: 0 26px 52px rgba(15, 23, 42, 0.18);
        }

        .teacher-period-summary h3 {
            font-size: 1.25rem;
            color: #1e1b4b;
            margin-bottom: 8px;
        }

        .teacher-period-subtitle {
            font-size: 0.9rem;
            color: #475569;
            margin-bottom: 16px;
            line-height: 1.5;
        }

        .teacher-period-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 20px;
            font-size: 0.78rem;
            color: #475569;
        }

        .teacher-period-legend span {
            background: rgba(255, 255, 255, 0.65);
            border-radius: 999px;
            padding: 8px 14px;
            border: 1px solid rgba(99, 102, 241, 0.2);
            color: #1e293b;
            box-shadow: 0 8px 16px rgba(79, 70, 229, 0.18);
        }

        .teacher-card-toggle-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: flex-end;
            margin: 12px 0 6px;
        }

        .btn-compact {
            padding: 6px 12px;
            font-size: 12px;
        }

        .teacher-period-grid {
            display: grid;
            gap: 18px;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        }

        .teacher-period-card {
            position: relative;
            background: rgba(255, 255, 255, 0.98);
            border: 1px solid rgba(148, 163, 184, 0.3);
            border-radius: 16px;
            box-shadow: 0 14px 34px rgba(15, 23, 42, 0.12);
            transition: box-shadow 0.3s ease, border-color 0.3s ease, transform 0.3s ease;
            overflow: hidden;
            border-left: 6px solid transparent;
        }

        .teacher-period-card.balance-positive {
            border-left-color: #22c55e;
        }

        .teacher-period-card.balance-negative {
            border-left-color: #ef4444;
        }

        .teacher-period-card[open] {
            box-shadow: 0 26px 54px rgba(79, 70, 229, 0.22);
            transform: translateY(-1px);
            border-color: rgba(79, 70, 229, 0.25);
        }

        .teacher-card-summary {
            list-style: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 16px 20px;
            background: linear-gradient(135deg, rgba(79, 70, 229, 0.16), rgba(14, 165, 233, 0.08));
            cursor: pointer;
            user-select: none;
            font-size: 0.95rem;
            font-weight: 600;
            color: #1e1b4b;
        }

        .teacher-period-card.balance-negative > .teacher-card-summary {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.18), rgba(248, 113, 113, 0.12));
        }

        .teacher-card-summary::-webkit-details-marker {
            display: none;
        }

        .teacher-card-summary:focus {
            outline: none;
        }

        .teacher-card-summary::after {
            content: '\25BC';
            font-size: 0.75rem;
            color: inherit;
            transition: transform 0.3s ease;
        }

        .teacher-period-card:not([open]) > .teacher-card-summary::after {
            transform: rotate(-90deg);
        }

        .teacher-card-summary-main {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .teacher-card-summary-chips {
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-end;
            gap: 6px;
        }

        .teacher-card-chip {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            border-radius: 999px;
            background: rgba(248, 250, 255, 0.85);
            border: 1px solid rgba(148, 163, 184, 0.35);
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #1e293b;
        }

        .teacher-card-chip.fte-chip {
            background: rgba(139, 92, 246, 0.18);
            border-color: rgba(139, 92, 246, 0.35);
            color: #5b21b6;
        }

        .teacher-card-chip.load-chip {
            background: rgba(56, 189, 248, 0.18);
            border-color: rgba(56, 189, 248, 0.35);
            color: #0f4c75;
        }

        .teacher-card-chip.balance-chip.positive {
            background: rgba(34, 197, 94, 0.18);
            border-color: rgba(34, 197, 94, 0.35);
            color: #047857;
        }

        .teacher-card-chip.balance-chip.negative {
            background: rgba(248, 113, 113, 0.18);
            border-color: rgba(248, 113, 113, 0.35);
            color: #b91c1c;
        }

        .teacher-card-body {
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            background: #ffffff;
            border-top: 1px solid #e3ebf3;
        }

        .teacher-card-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 12px;
        }

        .teacher-period-name {
            font-size: 1rem;
            font-weight: 600;
            color: #2c3e50;
        }

        .teacher-fte-control {
            display: flex;
            flex-direction: column;
            font-size: 0.75rem;
            color: #7f8c8d;
            text-align: right;
            margin-left: auto;
        }

        .teacher-fte-control label {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 4px;
        }

        .teacher-fte-control select {
            padding: 6px 10px;
            border: 1px solid #ccd9e4;
            border-radius: 6px;
            font-size: 0.85rem;
            background: #ffffff;
            color: #2c3e50;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }

        .teacher-fte-control select:focus {
            border-color: #4f46e5;
            outline: none;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.18);
        }

        .teacher-card-section-title {
            font-size: 0.72rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: #5d6d7e;
        }

        .teacher-load-inputs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 12px;
        }

        .teacher-load-input {
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 0.75rem;
            color: #1e293b;
            background: rgba(248, 250, 255, 0.9);
            border: 1px solid rgba(148, 163, 184, 0.35);
            border-radius: 12px;
            padding: 10px;
            box-shadow: inset 0 1px 2px rgba(15, 23, 42, 0.05);
        }

        .teacher-load-input label {
            font-weight: 700;
            color: #0f172a;
        }

        .teacher-load-input input {
            padding: 6px 8px;
            border: 1px solid rgba(148, 163, 184, 0.35);
            border-radius: 6px;
            font-size: 0.8rem;
            color: #0f172a;
            background: #ffffff;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }

        .teacher-load-input input:focus {
            border-color: #4f46e5;
            outline: none;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.18);
        }

        .teacher-load-input-note {
            font-size: 0.7rem;
            color: #7f8c8d;
        }

        .teacher-load-summary {
            background: linear-gradient(135deg, rgba(79, 70, 229, 0.08), rgba(14, 165, 233, 0.08));
            border: 1px dashed rgba(79, 70, 229, 0.28);
            border-radius: 14px;
            padding: 14px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-size: 0.75rem;
            color: #1e293b;
        }

        .teacher-load-row {
            display: flex;
            justify-content: space-between;
            gap: 8px;
        }

        .teacher-load-row span:first-child {
            color: #5d6d7e;
            text-transform: uppercase;
            letter-spacing: 0.04em;
        }

        .teacher-load-row span:last-child {
            font-weight: 700;
            text-align: right;
            color: #2c3e50;
        }

        .teacher-load-balance span:last-child {
            font-weight: 800;
        }

        .teacher-load-balance.positive span:last-child {
            color: #27ae60;
        }

        .teacher-load-balance.negative span:last-child {
            color: #c0392b;
        }

        .teacher-load-note {
            font-size: 0.7rem;
            color: #5f6a6a;
        }

        .teacher-period-empty {
            grid-column: 1 / -1;
            text-align: center;
            color: #7f8c8d;
            font-style: italic;
            padding: 10px 0;
        }

        .subject-slot.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }

        .drop-zone {
            background: rgba(79, 70, 229, 0.06);
            border: 1.5px dashed rgba(99, 102, 241, 0.3);
            border-radius: 14px;
            min-height: 84px;
            transition: background 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
        }

        .drop-zone.drag-over {
            background: rgba(79, 70, 229, 0.16);
            border-color: rgba(79, 70, 229, 0.6);
            transform: scale(1.01);
        }

        .drop-zone.drop-zone--wed {
            background: rgba(13, 148, 136, 0.08);
            border-color: rgba(13, 148, 136, 0.35);
        }

        .drop-zone.drop-zone--wed.drag-over {
            background: rgba(13, 148, 136, 0.18);
            border-color: rgba(13, 148, 136, 0.65);
        }


        /* Autocomplete styles */
        .autocomplete-container {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .autocomplete-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            box-sizing: border-box;
        }

        .autocomplete-input:focus {
            border-color: #4f46e5;
            outline: none;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.18);
        }

        .autocomplete-list {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .autocomplete-list.autocomplete-list--grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
            padding: 12px;
            max-height: none;
        }

        .autocomplete-item {
            padding: 10px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            transition: background-color 0.2s ease, border-left-color 0.2s ease;
            border-left: 3px solid transparent;
        }

        .autocomplete-item--grid {
            border-bottom: none;
            border: 1px solid #dce4ec;
            border-left-width: 4px;
            border-radius: 8px;
            background: #f8fbff;
            text-align: center;
            font-weight: 600;
            padding: 14px 10px;
        }

        .autocomplete-list.autocomplete-list--grid .autocomplete-item:hover,
        .autocomplete-list.autocomplete-list--grid .autocomplete-item.selected {
            border-left-color: #4f46e5;
            background: linear-gradient(135deg, rgba(79, 70, 229, 0.18), rgba(14, 165, 233, 0.08));
        }

        .autocomplete-item:hover,
        .autocomplete-item.selected {
            background-color: rgba(79, 70, 229, 0.12);
            color: #1e1b4b;
            border-left-color: #4f46e5;
        }

        .autocomplete-item:last-child {
            border-bottom: none;
        }

        .autocomplete-container.autocomplete-container--static {
            position: static;
        }

        .autocomplete-container.autocomplete-container--static .autocomplete-list {
            position: relative;
            top: auto;
            left: auto;
            right: auto;
            border: 1px solid #ddd;
            border-radius: 6px;
            margin-top: 0;
            box-shadow: none;
            max-height: 260px;
            padding: 4px 0;
        }

        .autocomplete-container.autocomplete-container--static .autocomplete-list.autocomplete-list--grid {
            max-height: none;
            padding: 12px;
        }

        .autocomplete-item.autocomplete-item--empty {
            cursor: default;
            color: #7f8c8d;
            border-left-color: transparent;
            background-color: #f9fbfd;
        }

        .modal-description {
            font-size: 0.9rem;
            color: #4a6074;
            line-height: 1.5;
            margin-bottom: 15px;
            display: none;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(15, 23, 42, 0.55);
            backdrop-filter: blur(4px);
        }

        .modal-content {
            background-color: #ffffff;
            margin: 8% auto;
            padding: 28px;
            border-radius: 20px;
            width: 420px;
            max-width: 92%;
            border: 1px solid rgba(148, 163, 184, 0.3);
            box-shadow: 0 40px 70px rgba(15, 23, 42, 0.2);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.3);
        }

        .modal-title {
            font-size: 1.45rem;
            font-weight: 700;
            color: #1e1b4b;
        }

        .close {
            color: #475569;
            font-size: 26px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .close:hover {
            color: #0f172a;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .modal-message {
            margin-top: 16px;
            font-size: 0.95rem;
            color: #334155;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .modal-message__lead {
            font-weight: 600;
            color: #0f172a;
        }

        .modal-message ul {
            margin: 0;
            padding-left: 20px;
            color: #1f2937;
        }

        .modal-message li {
            margin-bottom: 6px;
        }

        .modal-message__note {
            font-size: 0.88rem;
            color: #475569;
        }

        .modal-content.modal-content--room {
            width: 520px;
            max-width: 95%;
        }

        .room-modal-body {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .room-modal-summary {
            font-size: 0.9rem;
            font-weight: 600;
            color: #1f2937;
        }

        .room-modal-info {
            font-size: 0.85rem;
            color: #475569;
            line-height: 1.5;
        }

        .room-modal-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .room-modal-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .room-modal-row {
            display: grid;
            grid-template-columns: minmax(120px, 1fr) minmax(80px, 90px) minmax(120px, 1fr) auto;
            gap: 8px;
            align-items: center;
        }

        .room-modal-room,
        .room-modal-periods,
        .room-modal-note {
            width: 100%;
            border-radius: 10px;
            border: 1px solid rgba(148, 163, 184, 0.5);
            padding: 8px 10px;
            font-size: 0.85rem;
            color: #1f2937;
            background: rgba(255, 255, 255, 0.92);
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        .room-modal-room:focus,
        .room-modal-periods:focus,
        .room-modal-note:focus {
            outline: none;
            border-color: rgba(79, 70, 229, 0.6);
            box-shadow: 0 0 0 2px rgba(165, 180, 252, 0.45);
        }

        .room-modal-periods {
            -moz-appearance: textfield;
        }

        .room-modal-periods::-webkit-outer-spin-button,
        .room-modal-periods::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .room-modal-remove {
            border: none;
            background: rgba(239, 68, 68, 0.18);
            color: #b91c1c;
            border-radius: 10px;
            padding: 6px 10px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease, color 0.2s ease;
        }

        .room-modal-remove:hover,
        .room-modal-remove:focus {
            background: rgba(239, 68, 68, 0.3);
            color: #7f1d1d;
            outline: none;
        }

        .room-modal-empty {
            font-size: 0.85rem;
            color: #64748b;
            font-style: italic;
        }

        .room-modal-hint {
            font-size: 0.8rem;
            color: #475569;
        }

        .management-actions {
            display: none;
            flex-direction: column;
            gap: 16px;
        }

        .management-actions__tabs {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .management-actions__tab {
            border: 1px solid #d0d7e2;
            border-radius: 999px;
            padding: 8px 18px;
            background: #ffffff;
            color: #1f3d63;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(31, 61, 99, 0.1);
            transition: background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
        }

        .management-actions__tab:hover,
        .management-actions__tab:focus {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(31, 61, 99, 0.18);
            outline: none;
        }

        .management-actions__tab--active {
            background: linear-gradient(135deg, #1f3d63, #315a8a);
            color: #ffffff;
            border-color: rgba(31, 61, 99, 0.9);
            box-shadow: 0 6px 18px rgba(31, 61, 99, 0.3);
        }

        .management-actions__sections {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .management-actions__section {
            border: 1px solid #dfe6f1;
            border-radius: 12px;
            padding: 14px;
            background: linear-gradient(135deg, rgba(236, 240, 241, 0.4), rgba(255, 255, 255, 0.95));
            display: none;
            flex-direction: column;
            gap: 12px;
        }

        .management-actions__section--active {
            display: flex;
        }

        .management-actions__section--add {
            border-color: rgba(39, 174, 96, 0.4);
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.1), rgba(255, 255, 255, 0.95));
        }

        .management-actions__section--remove {
            border-color: rgba(231, 76, 60, 0.35);
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.12), rgba(255, 255, 255, 0.95));
        }

        .management-actions__section--utility {
            border-color: rgba(52, 152, 219, 0.35);
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.12), rgba(255, 255, 255, 0.95));
        }

        .management-actions__header {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .management-actions__title {
            font-size: 1rem;
            font-weight: 700;
            color: #1f3d63;
        }

        .management-actions__subtitle {
            font-size: 0.8rem;
            color: #5d6d7e;
        }

        .management-actions__buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }

        .management-actions__button {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 6px;
            padding: 12px;
            border: none;
            border-radius: 10px;
            background: #ffffff;
            box-shadow: 0 2px 6px rgba(31, 61, 99, 0.1);
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            border-left: 4px solid transparent;
        }

        .management-actions__button:hover,
        .management-actions__button:focus {
            transform: translateY(-2px);
            box-shadow: 0 6px 14px rgba(44, 62, 80, 0.18);
            outline: none;
        }

        .management-actions__button-label {
            font-size: 0.95rem;
            font-weight: 600;
            color: #2c3e50;
        }

        .management-actions__button-description {
            font-size: 0.75rem;
            color: #5d6d7e;
            line-height: 1.4;
        }

        .management-actions__button--add {
            border-left-color: #22c55e;
        }

        .management-actions__button--remove {
            border-left-color: #ef4444;
        }

        .management-actions__button--utility {
            border-left-color: #4f46e5;
        }

        .download-toast-container {
            position: fixed;
            bottom: 24px;
            right: 24px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 3000;
            pointer-events: none;
        }

        .download-toast {
            background: rgba(15, 23, 42, 0.92);
            color: #f8fafc;
            padding: 12px 18px;
            border-radius: 16px;
            box-shadow: 0 22px 45px rgba(15, 23, 42, 0.25);
            border: 1px solid rgba(148, 163, 184, 0.25);
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 0.95rem;
            transform: translateY(12px);
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: auto;
        }

        .download-toast--visible {
            opacity: 1;
            transform: translateY(0);
        }

        .download-toast__icon {
            font-size: 1.25rem;
        }

        .download-toast__message {
            flex: 1;
        }

        @media (max-width: 1200px) {
            .app-hero {
                padding: 48px 5vw 88px;
            }

            .app-layout {
                grid-template-columns: 1fr;
                padding: 0 clamp(20px, 5vw, 40px) 56px;
                gap: 24px;
            }

            .app-sidebar {
                order: 2;
            }

            .app-workspace {
                order: 1;
            }

            .control-group-buttons {
                grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            }
        }

        @media (max-width: 768px) {
            .app-hero {
                padding: 40px 5vw 72px;
            }

            .app-hero__title {
                font-size: 2.2rem;
            }

            .app-hero__metrics {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            }

            .app-sidebar {
                padding: 24px 20px;
            }

            .control-group-buttons {
                grid-template-columns: 1fr;
            }

            .workspace-panel__header {
                padding: 24px 20px 0;
            }

            .workspace-panel__body {
                padding: 20px;
            }

            .timetable-container {
                border-radius: 0 0 20px 20px;
            }

            .timetable {
                min-width: 720px;
                font-size: 12px;
            }

            .teacher-period-grid {
                grid-template-columns: 1fr;
            }

            .teacher-card-summary {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }

            .teacher-card-summary::after {
                align-self: flex-start;
            }

            .teacher-card-summary-chips {
                justify-content: flex-start;
            }

            .teacher-card-controls {
                flex-direction: column;
                align-items: stretch;
            }

            .teacher-fte-control {
                margin-left: 0;
                text-align: left;
            }

            .modal-content {
                margin: 5% auto;
                width: 95%;
                border-radius: 18px;
            }

            .download-toast-container {
                left: 16px;
                right: 16px;
                bottom: 16px;
                align-items: stretch;
            }

            .download-toast {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="app-alert is-hidden" id="appAlert" aria-hidden="true">
        <div class="app-alert__overlay" data-alert-dismiss></div>
        <div class="app-alert__dialog" role="alertdialog" aria-modal="true" aria-labelledby="appAlertTitle" aria-describedby="appAlertMessage" tabindex="-1">
            <div class="app-alert__content">
                <div class="app-alert__icon" id="appAlertIcon" aria-hidden="true"></div>
                <div class="app-alert__text">
                    <h2 class="app-alert__title" id="appAlertTitle">Heads up</h2>
                    <p class="app-alert__message" id="appAlertMessage"></p>
                </div>
            </div>
            <div class="app-alert__input is-hidden" id="appAlertInputWrapper">
                <input type="text" class="app-alert__field" id="appAlertInput" autocomplete="off">
            </div>
            <div class="app-alert__actions" id="appAlertActions"></div>
        </div>
    </div>
    <div class="app-shell">
        <header class="app-hero">
            <div class="app-hero__content">
                <span class="app-hero__tag">Matrix Control Center</span>
                <h1 class="app-hero__title">Faculty Staff Allocation Matrix</h1>
                <p class="app-hero__subtitle">Import your spreadsheet, map teachers to lines, and balance every subject with a drag-and-drop workspace tailored for timetable planning.</p>
            </div>
            <div class="app-hero__metrics">
                <div class="hero-metric">
                    <span class="hero-metric__label">Total Subjects</span>
                    <span class="hero-metric__value" id="totalSubjects">0</span>
                </div>
                <div class="hero-metric">
                    <span class="hero-metric__label">Allocated Subjects</span>
                    <span class="hero-metric__value" id="allocatedSubjects">0</span>
                </div>
                <div class="hero-metric">
                    <span class="hero-metric__label">Available Subjects</span>
                    <span class="hero-metric__value" id="remainingSubjects">0</span>
                </div>
                <div class="hero-metric">
                    <span class="hero-metric__label">Allocation Progress</span>
                    <span class="hero-metric__value" id="allocationPercentage">0%</span>
                </div>
            </div>
        </header>

        <div class="container app-layout">
            <aside class="app-sidebar">
                <div class="sidebar-intro">
                    <h2>Control Hub</h2>
                    <p>Choose an action to allocate subjects, manage data or adjust supporting resources.</p>
                </div>
                <div class="control-groups">
                    <section class="control-group control-group--start">
                        <div class="control-group-header">
                            <div class="control-group-label">Start Here</div>
                            <p class="control-group-description">Begin by converting your timetable file into the matrix-ready format.</p>
                        </div>
                        <div class="control-group-buttons">
                            <button class="btn btn-secondary" id="togglePatchConverterBtn" type="button" onclick="togglePatchConverter()" aria-expanded="false" aria-controls="patchConverterPanel" title="Convert CSVs into JSON lineCells patches or validate a patch in the File Converter">Open File Converter</button>
                        </div>
                    </section>
                    <section class="control-group control-group--workflow">
                        <div class="control-group-header">
                            <div class="control-group-label">Allocation Workflow</div>
                            <p class="control-group-description">Use guided prompts or drag subjects directly onto the timetable to keep your matrix balanced.</p>
                        </div>
                        <div class="control-group-buttons">
                            <button class="btn btn-primary" onclick="allocateNewSubject()" title="Allocate an available subject to a teacher">Allocate New Subject</button>
                            <button class="btn btn-primary" onclick="splitSubject()" title="Divide a subject into multiple allocations">Split Subject</button>
                            <button class="btn btn-secondary" onclick="openRoomAllocationManager()" title="Assign default rooms to subjects and manage overrides">Manage Room Allocations</button>
                            <button class="btn btn-primary" onclick="moveExistingAllocation()" title="Reassign a subject that is already allocated">Move Existing Allocation</button>
                            <button class="btn btn-primary" onclick="openManagementHub()" title="Open tools to add or remove teachers, subjects, lines and supplemental data">Add / Remove Data</button>
                        </div>
                    </section>

                    <section class="control-group control-group--data">
                        <div class="control-group-header">
                            <div class="control-group-label">Data &amp; Progress</div>
                            <p class="control-group-description">Keep imports, exports and saves in sync so everyone works from the latest plan.</p>
                        </div>
                        <div class="control-group-buttons">
                            <button class="btn btn-success" onclick="saveAllocations()" title="Save your current allocations for later">Save Allocations</button>
                            <button class="btn btn-secondary" onclick="importData()" title="Reload a previously exported allocation file">Import Saved Data</button>
                            <button class="btn btn-primary" onclick="exportData()" title="Export allocations for sharing or backup">Export Data</button>
                            <button class="btn btn-warning" onclick="resetAllocations()" title="Clear all current allocations and start fresh">Reset Allocations</button>
                            <button class="btn btn-danger" onclick="clearAllData()" title="Remove all imported data, allocations and saved settings to start from scratch">Clear All Data</button>
                        </div>
                    </section>

                    <section class="control-group control-group--history">
                        <div class="control-group-header">
                            <div class="control-group-label">History</div>
                            <p class="control-group-description">Step backwards or forwards through your recent actions.</p>
                        </div>
                        <div class="control-group-buttons">
                            <button class="btn btn-secondary" onclick="undoLastAction()" id="undoBtn" disabled title="Undo the last change">Undo</button>
                            <button class="btn btn-secondary" onclick="redoLastAction()" id="redoBtn" disabled title="Redo the last undone change">Redo</button>
                        </div>
                    </section>

                </div>
            </aside>

            <main class="app-workspace">
                <section class="workspace-panel workspace-panel--legend">
                    <div class="workspace-panel__header">
                        <h2 class="workspace-panel__title">Legend &amp; Quick Reference</h2>
                        <p class="workspace-panel__subtitle">Every color represents a different allocation state. Use this guide while dragging subjects around the matrix.</p>
                    </div>
                    <div class="workspace-panel__body">
                        <div class="legend">
                            <div class="legend-item">
                                <div class="legend-color available"></div>
                                <span>Available Subject</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color allocated"></div>
                                <span>Allocated Subject</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color split"></div>
                                <span>Split Allocation Portion</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color semester-pair"></div>
                                <span>Year 8 S1/S2 Pair</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color clash"></div>
                                <span>Teacher Clash</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color room-clash"></div>
                                <span>Room Clash</span>
                            </div>
                        </div>
                    </div>
                </section>

                <section class="workspace-panel workspace-panel--converter is-hidden" id="patchConverterPanel" aria-hidden="true">
                    <div class="workspace-panel__header">
                        <div>
                            <h2 class="workspace-panel__title">File Converter</h2>
                            <p class="workspace-panel__subtitle">Convert timetable spreadsheets into a usable JSON file format ready for importing.</p>
                        </div>
                        <div class="workspace-panel__header-actions">
                            <button class="btn btn-secondary btn-compact" id="closePatchConverterBtn" type="button" onclick="togglePatchConverter(false)" aria-label="Close file converter">Close</button>
                        </div>
                    </div>
                    <div class="workspace-panel__body converter-body">
                        <div class="converter-intro">
                            <span class="converter-intro__tag">How it works</span>
                            <p>Use this streamlined workflow to drop a timetable spreadsheet straight into the matrix.</p>
                            <ol class="converter-steps">
                                <li>Download the Allocation Data Template CSV (or grab an existing export) and fill in your subjects.</li>
                                <li>Upload the completed file to preview the first 30 cells and check the summary.</li>
                                <li>Press <strong>Add to Matrix</strong> to merge the data instantly. Downloading the JSON remains optional for sharing or backups.</li>
                            </ol>
                        </div>
                        <div class="converter-flow">
                            <section class="converter-step">
                                <div class="converter-step__header">
                                    <span class="converter-step__number">1</span>
                                    <div>
                                        <h3 class="converter-step__title">Prepare your template</h3>
                                        <p class="converter-step__description">Download a fresh copy or reuse an existing export before filling in your subjects.</p>
                                    </div>
                                </div>
                                <div class="converter-step__body">
                                    <div class="converter-template-buttons">
                                        <a class="btn btn-secondary btn-compact" id="converterDownloadTemplate" href="allocation-data-template.csv" download>Subject CSV Template</a>
                                        <a class="btn btn-secondary btn-compact" id="converterDownloadTeacherTemplate" href="teacher-import-template.csv" download>Teacher CSV Template</a>
                                    </div>
                                    <p class="converter-muted converter-template-note">Use the subject template to prepare line allocations or the teacher template to bulk add staff names and optional load settings.</p>
                                </div>
                            </section>
                            <section class="converter-step">
                                <div class="converter-step__header">
                                    <span class="converter-step__number">2</span>
                                    <div>
                                        <h3 class="converter-step__title">Upload &amp; configure</h3>
                                        <p class="converter-step__description">Choose a CSV, JSON, or XLSX file, then adjust optional cleanup rules before importing.</p>
                                    </div>
                                </div>
                                <div class="converter-step__body">
                                    <div class="converter-upload-row">
                                        <input id="converterFile" class="converter-file-input" type="file" accept=".csv,.json,.xlsx,.xlsm,.xls" hidden>
                                        <button class="btn btn-secondary btn-compact" id="converterFileButton" type="button" data-label-default="Choose File" data-label-active="Choose another file">Choose File</button>
                                        <button class="btn btn-secondary btn-compact" id="converterClear" type="button">Clear</button>
                                    </div>
                                    <div id="converterFileInfo" class="converter-file-info" role="status" aria-live="polite">No file selected yet.</div>
                                    <div class="converter-mode-toggle is-hidden" id="converterModeToggle" aria-label="Preview mode">
                                        <span class="converter-mode-toggle__label">Preview:</span>
                                        <div class="converter-mode-toggle__actions">
                                            <button class="btn btn-secondary btn-compact converter-mode-button" type="button" id="converterModeSubjects" aria-pressed="false">Subjects</button>
                                            <button class="btn btn-secondary btn-compact converter-mode-button" type="button" id="converterModeTeachers" aria-pressed="false">Teachers</button>
                                        </div>
                                    </div>
                                    <details class="converter-advanced">
                                        <summary>Advanced options</summary>
                                        <div class="converter-advanced__content">
                                            <p class="converter-advanced__description converter-muted">Tweak how your data is cleaned or set a fallback year before importing.</p>
                                            <div class="converter-options">
                                                <label><input type="checkbox" id="converterNormalize" checked> Normalize codes</label>
                                                <label><input type="checkbox" id="converterInherit" checked> Inherit line for splits</label>
                                                <label><input type="checkbox" id="converterRemove"> Add <code>removeMissingInThisYear</code></label>
                                            </div>
                                            <div class="converter-force">
                                                <label>Force Year (optional)
                                                    <input id="converterForceYear" class="converter-force-input" type="number" min="7" max="12" placeholder="7-12">
                                                </label>
                                                <div class="converter-muted converter-force-note">Use this if your CSV doesn't include a Year column.</div>
                                            </div>
                                        </div>
                                    </details>
                                    <div class="converter-summary-grid">
                                        <div class="converter-summary-card">
                                            <h4 class="converter-subheading">Detected</h4>
                                            <div id="converterDetected" class="converter-muted"></div>
                                        </div>
                                        <div class="converter-summary-card">
                                            <h4 class="converter-subheading">Summary</h4>
                                            <div id="converterSummary" class="converter-summary"></div>
                                        </div>
                                    </div>
                                </div>
                            </section>
                            <section class="converter-step converter-step--review">
                                <div class="converter-step__header">
                                    <span class="converter-step__number">3</span>
                                    <div>
                                        <h3 class="converter-step__title">Review &amp; export JSON</h3>
                                        <p class="converter-step__description">Inspect the generated patch, apply it to the matrix, or download a copy for reference.</p>
                                    </div>
                                </div>
                                <div class="converter-step__body">
                                    <textarea id="converterJson" class="converter-textarea" spellcheck="false" placeholder="Your JSON lineCells patch appears here, or paste an existing patch to validate it."></textarea>
                                    <div id="converterStatus" class="converter-status">Load a CSV, JSON, or XLSX file to enable <strong>Add to Matrix</strong>.</div>
                                    <div class="converter-row converter-actions">
                                        <button class="btn btn-success btn-compact" id="converterApply" disabled>Add to Matrix</button>
                                        <button class="btn btn-primary btn-compact" id="converterDownloadJson" disabled>Download JSON</button>
                                        <button class="btn btn-warning btn-compact" id="converterCopy" disabled>Copy</button>
                                    </div>
                                    <details class="converter-advanced converter-advanced--actions">
                                        <summary>Advanced tools</summary>
                                        <div class="converter-advanced__content">
                                            <p class="converter-advanced__description converter-muted">Validate a manual JSON edit before applying it to the matrix.</p>
                                            <button class="btn btn-secondary btn-compact" id="converterValidate">Validate JSON</button>
                                        </div>
                                    </details>
                                </div>
                            </section>
                        </div>
                        <div class="converter-preview">
                            <h3 class="converter-heading">Parsed Cells (first 30)</h3>
                            <div id="converterCells" class="converter-cells"><div class="converter-muted">No cells parsed yet.</div></div>
                        </div>
                        <p class="converter-footer">No data leaves your browser. Built for quick, safe imports.</p>
                    </div>
                </section>

                <section class="workspace-panel workspace-panel--matrix">
                    <div class="workspace-panel__header">
                        <div>
                            <h2 class="workspace-panel__title">Allocation Matrix</h2>
                            <p class="workspace-panel__subtitle">Drag subjects onto a teacher&apos;s line or click any cell to launch the quick allocation modal.</p>
                        </div>
                        <div class="workspace-panel__header-actions">
                            <button class="btn btn-secondary btn-compact" id="printMatrixBtn" type="button">Print Matrix</button>
                        </div>
                    </div>
                    <div class="workspace-panel__body workspace-panel__body--flush">
                        <div class="timetable-container">
                            <table class="timetable" id="timetable">
                                <thead id="timetableHead">
                                    <tr>
                                        <th>Line</th>
                                        <!-- Teachers will be dynamically added here -->
                                    </tr>
                                </thead>
                                <tbody id="timetableBody">
                                    <!-- Periods will be generated by JavaScript -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </section>
            </main>
        </div>
    </div>

    <!-- Autocomplete Modal -->
    <div id="autocompleteModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title" id="modalTitle">Select Item</span>
                <span class="close">&times;</span>
            </div>
            <p class="modal-description" id="modalDescription"></p>
            <div class="autocomplete-container">
                <input type="text" id="autocompleteInput" class="autocomplete-input" placeholder="Start typing to search...">
                <div id="autocompleteList" class="autocomplete-list" style="display: none;"></div>
            </div>
            <div id="managementActionContainer" class="management-actions"></div>
            <div class="modal-buttons">
                <button class="btn btn-primary" id="confirmBtn">Confirm</button>
                <button class="btn btn-warning" id="cancelBtn">Cancel</button>
            </div>
        </div>
    </div>

    <div id="clashModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="clashModalTitle">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title" id="clashModalTitle">Allocation Clash</span>
                <span class="close" id="clashModalClose">&times;</span>
            </div>
            <div id="clashModalMessage" class="modal-message"></div>
            <div class="modal-buttons">
                <button class="btn btn-primary" id="clashProceedBtn">Proceed</button>
                <button class="btn btn-secondary is-hidden" id="clashChangeBtn">Change</button>
                <button class="btn btn-secondary is-hidden" id="clashDivideBtn">Divide</button>
                <button class="btn btn-warning" id="clashCancelBtn">Cancel</button>
                <button class="btn btn-danger" id="clashReplaceBtn">Replace</button>
            </div>
        </div>
    </div>

    <div id="roomModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="roomModalTitle" aria-hidden="true">
        <div class="modal-content modal-content--room">
            <div class="modal-header">
                <span class="modal-title" id="roomModalTitle">Manage Rooms</span>
                <span class="close" id="roomModalClose">&times;</span>
            </div>
            <div class="room-modal-body">
                <div class="room-modal-summary" id="roomModalSummary"></div>
                <div class="room-modal-info" id="roomModalInfo"></div>
                <div class="room-modal-actions" id="roomModalContextActions" hidden>
                    <button type="button" class="btn btn-secondary btn-compact" id="roomModalCopyDefaults">Copy defaults</button>
                </div>
                <div class="room-modal-list" id="roomModalList"></div>
                <div class="room-modal-hint" id="roomModalHint"></div>
                <div class="modal-buttons">
                    <button type="button" class="btn btn-warning" id="roomModalClearRooms">Clear Rooms</button>
                    <button type="button" class="btn btn-primary" id="roomModalSaveRooms">Save Rooms</button>
                </div>
            </div>
        </div>
    </div>

    <script src="xlsx.full.min.js"></script>
    <script>
        (function() {
            const originalAlert = window.alert ? window.alert.bind(window) : null;
            let alertRoot = document.getElementById('appAlert');

            const ensureAlertStructure = () => {
                if (!alertRoot && document.body) {
                    alertRoot = document.createElement('div');
                    alertRoot.id = 'appAlert';
                    alertRoot.className = 'app-alert is-hidden';
                    alertRoot.setAttribute('aria-hidden', 'true');
                    alertRoot.innerHTML = `
                        <div class="app-alert__overlay" data-alert-dismiss></div>
                        <div class="app-alert__dialog" role="alertdialog" aria-modal="true" aria-labelledby="appAlertTitle" aria-describedby="appAlertMessage" tabindex="-1">
                            <div class="app-alert__content">
                                <div class="app-alert__icon" id="appAlertIcon" aria-hidden="true"></div>
                                <div class="app-alert__text">
                                    <h2 class="app-alert__title" id="appAlertTitle">Heads up</h2>
                                    <p class="app-alert__message" id="appAlertMessage"></p>
                                </div>
                            </div>
                            <div class="app-alert__input is-hidden" id="appAlertInputWrapper">
                                <input type="text" class="app-alert__field" id="appAlertInput" autocomplete="off">
                            </div>
                            <div class="app-alert__actions" id="appAlertActions"></div>
                        </div>`;
                    document.body.appendChild(alertRoot);
                }
            };

            ensureAlertStructure();

            if (!alertRoot) {
                window.alert = message => {
                    if (originalAlert) {
                        originalAlert(message);
                    }
                };
                return;
            }

            const overlay = alertRoot.querySelector('[data-alert-dismiss]');
            const dialog = alertRoot.querySelector('.app-alert__dialog');
            const titleEl = alertRoot.querySelector('#appAlertTitle');
            const messageEl = alertRoot.querySelector('#appAlertMessage');
            const iconEl = alertRoot.querySelector('#appAlertIcon');
            const inputWrapper = alertRoot.querySelector('#appAlertInputWrapper');
            const inputField = alertRoot.querySelector('#appAlertInput');
            const actionsContainer = alertRoot.querySelector('#appAlertActions');

            const queue = [];
            let isOpen = false;
            let activeItem = null;
            let previousActiveElement = null;
            let currentActionButtons = [];
            let showScheduled = false;

            const inferPresentation = text => {
                const normalized = text.toLowerCase();
                if (/error|unable|invalid|fail|unsupported|could not|cannot|can't/.test(normalized)) {
                    return { icon: '', title: 'Something needs attention' };
                }
                if (/success|saved|added|removed|imported|ready|restored|completed|allocated||successfully/.test(normalized)) {
                    return { icon: '', title: 'Success' };
                }
                if (/warning|caution|alert/.test(normalized)) {
                    return { icon: '', title: 'Warning' };
                }
                return { icon: '', title: 'Heads up' };
            };

            const buildActionsForItem = item => {
                if (item.type === 'dialog') {
                    const provided = Array.isArray(item.actions) ? item.actions : [];
                    const normalized = provided
                        .map((action, index) => {
                            if (!action || typeof action.label !== 'string') {
                                return null;
                            }
                            const label = action.label.trim();
                            if (!label) {
                                return null;
                            }
                            const variant = ['primary', 'secondary', 'danger'].includes(action.variant)
                                ? action.variant
                                : (index === 0 ? 'primary' : 'secondary');
                            const allowedRoles = ['primary', 'cancel', 'submit', 'option'];
                            const role = allowedRoles.includes(action.role)
                                ? action.role
                                : (variant === 'primary' ? 'primary' : 'option');
                            const value = typeof action.value !== 'undefined' ? action.value : index;
                            const focus = Boolean(action.focus);
                            return { label, variant, role, value, focus };
                        })
                        .filter(Boolean);

                    if (normalized.length === 0) {
                        normalized.push({
                            label: 'OK',
                            variant: 'primary',
                            role: 'primary',
                            value: undefined,
                            focus: true
                        });
                    }

                    if (typeof item.dismissValue !== 'undefined' && !normalized.some(action => action.role === 'cancel')) {
                        normalized.push({
                            label: 'Cancel',
                            variant: 'secondary',
                            role: 'cancel',
                            value: item.dismissValue
                        });
                    }

                    return normalized;
                }

                const actions = [];
                if ((item.type === 'confirm' || item.type === 'prompt') && item.secondaryLabel) {
                    actions.push({
                        label: item.secondaryLabel,
                        variant: 'secondary',
                        role: 'cancel',
                        value: item.dismissValue
                    });
                }

                actions.push({
                    label: item.primaryLabel,
                    variant: 'primary',
                    role: item.type === 'prompt' ? 'submit' : 'primary',
                    value: item.type === 'prompt' ? undefined : item.primaryValue,
                    focus: true
                });

                return actions;
            };

            const renderActions = item => {
                if (!actionsContainer) {
                    currentActionButtons = [];
                    return;
                }

                const actions = buildActionsForItem(item);

                actionsContainer.innerHTML = '';
                currentActionButtons = [];

                if (!actions || actions.length === 0) {
                    actionsContainer.classList.add('is-hidden');
                    return;
                }

                actionsContainer.classList.remove('is-hidden');

                actions.forEach(action => {
                    const button = document.createElement('button');
                    button.type = 'button';
                    button.className = 'app-alert__button';
                    if (action.variant === 'primary') {
                        button.classList.add('app-alert__button--primary');
                    } else if (action.variant === 'danger') {
                        button.classList.add('app-alert__button--danger');
                    } else {
                        button.classList.add('app-alert__button--secondary');
                    }
                    button.textContent = action.label;
                    button.addEventListener('click', () => handleAction(action));
                    actionsContainer.appendChild(button);
                    currentActionButtons.push({ element: button, action });
                });
            };

            const configureDialog = item => {
                if (titleEl) {
                    titleEl.textContent = item.title;
                }
                if (messageEl) {
                    messageEl.textContent = item.message;
                }
                if (iconEl) {
                    iconEl.textContent = item.icon;
                }
                if (inputWrapper && inputField) {
                    if (item.type === 'prompt') {
                        inputWrapper.classList.remove('is-hidden');
                        inputField.value = item.defaultValue || '';
                        if (item.placeholder) {
                            inputField.setAttribute('placeholder', item.placeholder);
                        } else {
                            inputField.removeAttribute('placeholder');
                        }
                    } else {
                        inputWrapper.classList.add('is-hidden');
                        inputField.value = '';
                        inputField.removeAttribute('placeholder');
                    }
                }

                renderActions(item);
            };

            const focusFirstElement = () => {
                if (!isOpen) {
                    return;
                }

                if (activeItem && activeItem.type === 'prompt' && inputField && inputWrapper && !inputWrapper.classList.contains('is-hidden')) {
                    inputField.focus({ preventScroll: true });
                    inputField.select();
                    return;
                }

                const preferred = currentActionButtons.find(btn => btn.action.focus)
                    || currentActionButtons.find(btn => btn.action.role === 'primary')
                    || currentActionButtons[currentActionButtons.length - 1];

                if (preferred && preferred.element) {
                    preferred.element.focus({ preventScroll: true });
                } else if (dialog && typeof dialog.focus === 'function') {
                    dialog.focus({ preventScroll: true });
                }
            };

            const getFocusableElements = () => {
                const focusable = [];
                if (activeItem && activeItem.type === 'prompt' && inputField && inputWrapper && !inputWrapper.classList.contains('is-hidden')) {
                    focusable.push(inputField);
                }
                currentActionButtons.forEach(({ element }) => {
                    if (element) {
                        focusable.push(element);
                    }
                });
                return focusable;
            };

            const finishDialog = result => {
                if (!isOpen) {
                    return;
                }
                alertRoot.classList.add('is-hidden');
                alertRoot.setAttribute('aria-hidden', 'true');
                isOpen = false;

                const item = activeItem;
                activeItem = null;
                currentActionButtons = [];

                if (previousActiveElement && typeof previousActiveElement.focus === 'function') {
                    previousActiveElement.focus({ preventScroll: true });
                }
                previousActiveElement = null;

                if (item && typeof item.resolve === 'function') {
                    item.resolve(result);
                }

                scheduleShowNext();
            };

            const dismissDialog = () => {
                const fallback = activeItem ? activeItem.dismissValue : undefined;
                finishDialog(fallback);
            };

            const handleAction = action => {
                if (!activeItem) {
                    finishDialog(undefined);
                    return;
                }

                if (activeItem.type === 'prompt' && action.role === 'submit') {
                    const rawValue = inputField ? inputField.value : '';
                    const result = typeof activeItem.transform === 'function'
                        ? activeItem.transform(rawValue)
                        : rawValue;
                    finishDialog(result);
                    return;
                }

                if (action.role === 'cancel') {
                    const fallback = typeof action.value !== 'undefined' ? action.value : activeItem.dismissValue;
                    finishDialog(fallback);
                    return;
                }

                if (typeof action.value !== 'undefined') {
                    finishDialog(action.value);
                    return;
                }

                if (typeof activeItem.primaryValue !== 'undefined' && action.role === 'primary') {
                    finishDialog(activeItem.primaryValue);
                    return;
                }

                finishDialog(undefined);
            };

            const invokeDefaultAction = () => {
                if (currentActionButtons.length === 0) {
                    finishDialog(undefined);
                    return;
                }

                const preferred = currentActionButtons.find(btn => btn.action.role === 'submit')
                    || currentActionButtons.find(btn => btn.action.role === 'primary')
                    || currentActionButtons[currentActionButtons.length - 1];

                if (preferred) {
                    handleAction(preferred.action);
                } else {
                    finishDialog(undefined);
                }
            };

            const showNext = () => {
                if (isOpen) {
                    return;
                }
                const next = queue.shift();
                if (!next) {
                    return;
                }
                activeItem = next;
                previousActiveElement = document.activeElement instanceof HTMLElement ? document.activeElement : null;
                configureDialog(next);
                alertRoot.classList.remove('is-hidden');
                alertRoot.setAttribute('aria-hidden', 'false');
                isOpen = true;
                requestAnimationFrame(focusFirstElement);
            };

            const scheduleShowNext = () => {
                if (isOpen || showScheduled || queue.length === 0) {
                    return;
                }
                showScheduled = true;
                requestAnimationFrame(() => {
                    showScheduled = false;
                    if (!isOpen) {
                        showNext();
                    }
                });
            };

            if (overlay) {
                overlay.addEventListener('click', dismissDialog);
            }

            if (inputField) {
                inputField.addEventListener('keydown', event => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        invokeDefaultAction();
                    }
                });
            }

            alertRoot.addEventListener('keydown', event => {
                if (!isOpen) {
                    return;
                }
                if (event.key === 'Tab') {
                    const focusable = getFocusableElements();
                    if (focusable.length === 0) {
                        event.preventDefault();
                        return;
                    }
                    const currentIndex = focusable.indexOf(document.activeElement);
                    let nextIndex;
                    if (event.shiftKey) {
                        nextIndex = currentIndex <= 0 ? focusable.length - 1 : currentIndex - 1;
                    } else {
                        nextIndex = currentIndex === -1 || currentIndex >= focusable.length - 1 ? 0 : currentIndex + 1;
                    }
                    event.preventDefault();
                    focusable[nextIndex].focus({ preventScroll: true });
                } else if (event.key === 'Escape') {
                    event.preventDefault();
                    dismissDialog();
                }
            });

            document.addEventListener('focusin', event => {
                if (!isOpen || !dialog) {
                    return;
                }
                if (!dialog.contains(event.target)) {
                    focusFirstElement();
                }
            });

            document.addEventListener('keydown', event => {
                if (!isOpen) {
                    return;
                }
                if (event.key === 'Escape') {
                    event.preventDefault();
                    dismissDialog();
                }
            });

            const enqueue = (type, message, options = {}) => {
                const text = String(message ?? '');
                const inferred = inferPresentation(text);
                const icon = typeof options.icon === 'string' && options.icon.trim() ? options.icon.trim() : inferred.icon;
                const title = typeof options.title === 'string' && options.title.trim() ? options.title.trim() : inferred.title;

                const providedActions = Array.isArray(options.actions)
                    ? options.actions.filter(action => action && typeof action === 'object')
                    : [];

                const normalizedType = providedActions.length > 0 ? 'dialog' : type;

                const item = {
                    type: normalizedType,
                    message: text,
                    icon,
                    title,
                    primaryLabel: 'OK',
                    secondaryLabel: null,
                    primaryValue: undefined,
                    dismissValue: typeof options.dismissValue !== 'undefined' ? options.dismissValue : undefined,
                    defaultValue: '',
                    placeholder: '',
                    transform: null,
                    actions: providedActions,
                    resolve: () => {}
                };

                if (normalizedType === 'confirm') {
                    item.primaryLabel = typeof options.confirmLabel === 'string' && options.confirmLabel.trim() ? options.confirmLabel.trim() : 'Confirm';
                    item.secondaryLabel = typeof options.cancelLabel === 'string' && options.cancelLabel.trim() ? options.cancelLabel.trim() : 'Cancel';
                    item.primaryValue = typeof options.primaryValue !== 'undefined' ? options.primaryValue : true;
                    item.dismissValue = typeof options.dismissValue !== 'undefined' ? options.dismissValue : false;
                } else if (normalizedType === 'prompt') {
                    item.primaryLabel = typeof options.confirmLabel === 'string' && options.confirmLabel.trim() ? options.confirmLabel.trim() : 'Save';
                    item.secondaryLabel = typeof options.cancelLabel === 'string' && options.cancelLabel.trim() ? options.cancelLabel.trim() : 'Cancel';
                    item.defaultValue = typeof options.defaultValue === 'string' ? options.defaultValue : '';
                    item.placeholder = typeof options.placeholder === 'string' ? options.placeholder : '';
                    item.transform = typeof options.transform === 'function' ? options.transform : null;
                    item.dismissValue = typeof options.dismissValue !== 'undefined' ? options.dismissValue : null;
                } else if (normalizedType === 'dialog') {
                    if (typeof item.dismissValue === 'undefined') {
                        item.dismissValue = 'dismissed';
                    }
                } else {
                    item.primaryLabel = typeof options.confirmLabel === 'string' && options.confirmLabel.trim() ? options.confirmLabel.trim() : 'OK';
                    if (typeof options.primaryValue !== 'undefined') {
                        item.primaryValue = options.primaryValue;
                    }
                }

                return new Promise(resolve => {
                    item.resolve = resolve;
                    queue.push(item);
                    scheduleShowNext();
                });
            };

            window.showAppAlert = (message, options) => enqueue('alert', message, options);
            window.showAppConfirm = (message, options) => enqueue('confirm', message, options);
            window.showAppPrompt = (message, options) => enqueue('prompt', message, options);
            window.showAppDialog = (message, options) => enqueue('dialog', message, options);

            window.alert = message => {
                enqueue('alert', message);
            };
        })();

        // Dynamic data loaded from spreadsheet
        const STANDARD_PERIOD_MINUTES = 59;
        const WED_SPECIAL_LINES = ['WedA1', 'WedA5', 'WedA6', 'WedB1', 'WedB5', 'WedB6'];
        const DEFAULT_LINES = ['Line 1', 'Line 2', 'Line 3', 'Line 4', 'Line 5', 'Line 6', 'Line 7'];
        const EXTENDED_LINE_LABELS = [...DEFAULT_LINES, ...WED_SPECIAL_LINES];
        const WED_PERIOD_MINUTES = 38;
        const SPECIAL_LINE_DURATION_MAP = new Map();
        const WED_LINE_TOKENS = new Set();
        WED_SPECIAL_LINES.forEach(label => {
            const key = normalizeLineLabelKey(label);
            SPECIAL_LINE_DURATION_MAP.set(key, WED_PERIOD_MINUTES);
            WED_LINE_TOKENS.add(key);
        });
        const LINE_TOKEN_TO_INDEX = buildLineTokenIndex();
        let subjects = [];
        let teachers = [];
        let years = ['Year 12', 'Year 11', 'Year 10', 'Year 9', 'Year 8', 'Year 7'];
        let lines = [...DEFAULT_LINES];
        let lineDurationMap = new Map();
        rebuildLineDurations();

        function isWednesdayLineLabel(label) {
            const token = normalizeLineLabelKey(label);
            return token ? WED_LINE_TOKENS.has(token) : false;
        }

        function isWednesdayLineIndex(index) {
            const numeric = typeof index === 'string' ? parseInt(index, 10) : index;
            return Number.isInteger(numeric)
                && Array.isArray(lines)
                && numeric >= 0
                && numeric < lines.length
                && isWednesdayLineLabel(lines[numeric]);
        }

        function isWednesdaySubjectCode(subjectCode) {
            if (!subjectCode) {
                return false;
            }
            return String(subjectCode).toLowerCase().includes('_wed');
        }

        function markElementAsWednesday(element, lineIndex, className = 'subject-slot--wed') {
            if (!element) {
                return;
            }
            if (isWednesdayLineIndex(lineIndex)) {
                element.classList.add(className);
            }
        }
        function getMaxLineNumber() {
            const dynamicLength = Array.isArray(lines) ? lines.length : 0;
            return Math.max(dynamicLength, EXTENDED_LINE_LABELS.length);
        }
        function normalizeLineLabelKey(value) {
            return String(value || '').toLowerCase().replace(/[^a-z0-9]/g, '');
        }

        function buildLineTokenIndex() {
            const map = new Map();
            EXTENDED_LINE_LABELS.forEach((label, index) => {
                const token = normalizeLineLabelKey(label);
                if (token) {
                    map.set(token, index + 1);
                }
            });
            for (let i = 1; i <= EXTENDED_LINE_LABELS.length; i++) {
                map.set(`line${i}`, i);
            }
            return map;
        }

        function getDefaultLineLabel(index) {
            if (index >= 0 && index < EXTENDED_LINE_LABELS.length) {
                return EXTENDED_LINE_LABELS[index];
            }
            return `Line ${index + 1}`;
        }

        function getDefaultLineMinutes(label) {
            const token = normalizeLineLabelKey(label);
            if (SPECIAL_LINE_DURATION_MAP.has(token)) {
                return SPECIAL_LINE_DURATION_MAP.get(token);
            }
            return STANDARD_PERIOD_MINUTES;
        }

        function ensureLineDurationEntry(label) {
            const token = normalizeLineLabelKey(label);
            if (!token) {
                return STANDARD_PERIOD_MINUTES;
            }
            if (!lineDurationMap.has(token)) {
                lineDurationMap.set(token, getDefaultLineMinutes(label));
            }
            return lineDurationMap.get(token);
        }

        function rebuildLineDurations() {
            lineDurationMap = new Map();
            if (Array.isArray(lines)) {
                lines.forEach(label => ensureLineDurationEntry(label));
            }
        }

        function getLineMinutes(lineIndex) {
            if (!Array.isArray(lines) || lineIndex < 0 || lineIndex >= lines.length) {
                return STANDARD_PERIOD_MINUTES;
            }
            return ensureLineDurationEntry(lines[lineIndex]);
        }

        function expandLinesToInclude(targetIndex, targetLines = lines, options = {}) {
            const shouldUpdateDurations = options.updateDurations !== undefined
                ? options.updateDurations
                : targetLines === lines;
            let added = false;
            while (targetLines.length <= targetIndex) {
                const fallback = getDefaultLineLabel(targetLines.length);
                targetLines.push(fallback);
                if (shouldUpdateDurations) {
                    ensureLineDurationEntry(fallback);
                }
                added = true;
            }
            return added;
        }

        let teacherAllocations = {}; // Stores which teachers can teach which lines
        let subjectLineMapping = {}; // Maps subject codes to their correct line index
        function getMappedLineForSubject(subjectCode) {
            if (!subjectCode || typeof subjectLineMapping !== 'object') {
                return undefined;
            }

            const coerceLine = value => {
                if (Number.isInteger(value)) {
                    return value;
                }
                const parsed = Number.parseInt(value, 10);
                return Number.isNaN(parsed) ? undefined : parsed;
            };

            const normalized = normalizeSubjectCode(subjectCode);
            if (normalized && Object.prototype.hasOwnProperty.call(subjectLineMapping, normalized)) {
                const mapped = coerceLine(subjectLineMapping[normalized]);
                if (mapped !== undefined) {
                    return mapped;
                }
            }

            if (Object.prototype.hasOwnProperty.call(subjectLineMapping, subjectCode)) {
                return coerceLine(subjectLineMapping[subjectCode]);
            }

            return undefined;
        }
        let subjectYearMapping = {}; // Tracks the owning year level for each subject code
        let actionHistory = []; // Stores undo history
        let redoStack = []; // Stores redo history
        let csvData = [];

        let allocations = {};
        let draggedElement = null;
        let subjectSplits = {};
        let splitSubjectLookup = {};
        let pendingClashContext = null;
        let lastAllocationOutcome = { status: 'idle', reason: null };

        const IS_DEV_ENV = (() => {
            if (typeof window === 'undefined' || typeof window.location === 'undefined') {
                return false;
            }

            const host = (window.location.hostname || '').toLowerCase();
            if (host === 'localhost' || host === '127.0.0.1' || host === '0.0.0.0') {
                return true;
            }

            return window.location.protocol === 'file:';
        })();

        const AVAILABLE_ROOMS = [
            'A01', 'A02', 'A03', 'A04', 'A05', 'A06', 'A07', 'A08', 'AMP', 'ANX',
            'B01', 'B02', 'B03', 'B04', 'B05', 'B07', 'B09', 'B10', 'B11', 'B12', 'B13', 'B14', 'B15', 'B16', 'B17', 'B18', 'B19', 'B20', 'B21', 'B22',
            'C01', 'C02', 'C03', 'C04', 'C05', 'C06', 'C07', 'C08', 'C09', 'C10', 'C12',
            'D01', 'D02', 'D03', 'D04', 'D05', 'D06', 'D07', 'D08', 'D09',
            'E01', 'E02', 'E03', 'E04',
            'F01', 'F02', 'F03',
            'GY01', 'GY02', 'GY03', 'GY04',
            'H01', 'H02', 'H03', 'HAL', 'LIB', 'TDR'
        ];

        let subjectRoomAssignments = {};
        let allocationRoomOverrides = {};
        let currentRoomModalContext = null;
        let activeRoomClashMap = new Map();
        let roomClashRefreshScheduled = false;

        const FTE_OPTIONS = ['1.0', '0.8', '0.6', '0.4', '0.2'];
        // Base load expressed in 59-minute period equivalents for each FTE value
        const FTE_BASE_PERIODS_MAPPING = {
            '1.0': 37.95,
            '0.8': 30.35,
            '0.6': 22.77,
            '0.4': 15.17,
            '0.2': 11.8
        };
        const DEFAULT_FTE_VALUE = '1.0';
        const PERIOD_MINUTES = STANDARD_PERIOD_MINUTES;
        const TLC_MINUTES = 19;
        const ASSEMBLY_FULL_PERIOD_EQUIVALENT = 0.62;
        const ASSEMBLY_FULL_MINUTES = PERIOD_MINUTES * ASSEMBLY_FULL_PERIOD_EQUIVALENT;
        const ASSEMBLY_SHORT_MINUTES = TLC_MINUTES;
        const ASSEMBLY_SHORT_PERIOD_EQUIVALENT = ASSEMBLY_SHORT_MINUTES / PERIOD_MINUTES;

        let teacherLoadSettings = {};

        const patchConverterPanel = document.getElementById('patchConverterPanel');
        const patchConverterToggleBtn = document.getElementById('togglePatchConverterBtn');

        function ensureDownloadToastContainer() {
            let container = document.getElementById('downloadToastContainer');
            if (!container) {
                container = document.createElement('div');
                container.id = 'downloadToastContainer';
                container.className = 'download-toast-container';
                container.setAttribute('aria-live', 'polite');
                container.setAttribute('aria-atomic', 'true');
                document.body.appendChild(container);
            }
            return container;
        }

        function togglePatchConverter(forceState) {
            if (!patchConverterPanel || !patchConverterToggleBtn) {
                return;
            }

            const shouldShow = typeof forceState === 'boolean'
                ? forceState
                : patchConverterPanel.classList.contains('is-hidden');

            patchConverterPanel.classList.toggle('is-hidden', !shouldShow);
            patchConverterPanel.setAttribute('aria-hidden', shouldShow ? 'false' : 'true');

            patchConverterToggleBtn.textContent = shouldShow ? 'Hide File Converter' : 'Open File Converter';
            patchConverterToggleBtn.setAttribute('aria-expanded', shouldShow ? 'true' : 'false');

            if (shouldShow) {
                patchConverterPanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

        function showDownloadNotification(message, options = {}) {
            if (!message) {
                return;
            }

            const duration = typeof options.duration === 'number' && Number.isFinite(options.duration)
                ? Math.max(1000, options.duration)
                : 4000;

            const container = ensureDownloadToastContainer();
            const toast = document.createElement('div');
            toast.className = 'download-toast';
            toast.setAttribute('role', 'status');

            const icon = document.createElement('span');
            icon.className = 'download-toast__icon';
            icon.setAttribute('aria-hidden', 'true');
            icon.textContent = typeof options.icon === 'string' && options.icon.trim() !== ''
                ? options.icon
                : '';

            const text = document.createElement('span');
            text.className = 'download-toast__message';
            text.textContent = message;

            toast.appendChild(icon);
            toast.appendChild(text);

            container.appendChild(toast);

            requestAnimationFrame(() => {
                toast.classList.add('download-toast--visible');
            });

            const hideToast = () => {
                toast.classList.remove('download-toast--visible');
                setTimeout(() => {
                    if (toast.parentElement) {
                        toast.parentElement.removeChild(toast);
                    }
                }, 300);
            };

            const timeoutId = setTimeout(hideToast, duration);

            toast.addEventListener('click', () => {
                clearTimeout(timeoutId);
                hideToast();
            });
        }

        const YEAR_PERIOD_ALLOCATION = {
            12: 7,
            11: 7,
            10: 5,
            9: 6
        };

        const YEAR8_ELECTIVE_PERIODS = 3;
        const YEAR8_TECH_MANDATORY_PERIODS = 5;
        const YEAR7_TECH_MANDATORY_PERIODS = 5;

        function normalizeYearLabel(rawYear) {
            if (rawYear === null || rawYear === undefined) {
                return null;
            }

            const text = String(rawYear).trim();
            if (text.length === 0) {
                return null;
            }

            const match = text.match(/(\d{1,2})/);
            if (!match) {
                return null;
            }

            const yearNumber = parseInt(match[1], 10);
            if (!Number.isInteger(yearNumber) || yearNumber <= 0) {
                return null;
            }

            return `Year ${yearNumber}`;
        }

        function resetSplitData() {
            subjectSplits = {};
            splitSubjectLookup = {};
        }

        function rebuildSplitLookup() {
            splitSubjectLookup = {};

            Object.entries(subjectSplits).forEach(([baseSubject, splits]) => {
                if (!Array.isArray(splits)) {
                    return;
                }

                splits.forEach(split => {
                    if (!split || typeof split.code !== 'string') {
                        return;
                    }

                    const totalSplits = Number.isFinite(split.totalSplits) ? split.totalSplits : splits.length;

                    splitSubjectLookup[split.code] = {
                        baseSubject: baseSubject,
                        periods: Number.isFinite(split.periods) ? split.periods : parseInt(split.periods, 10) || 0,
                        index: Number.isFinite(split.index) ? split.index : parseInt(split.index, 10) || 0,
                        totalSplits: totalSplits
                    };
                });
            });
        }

        function getSplitSubjectsForBase(baseSubject) {
            if (!baseSubject || !subjectSplits[baseSubject]) {
                return [];
            }
            return subjectSplits[baseSubject]
                .filter(split => split && typeof split.code === 'string')
                .map(split => split.code);
        }

        function isSplitSubject(subjectCode) {
            return Boolean(splitSubjectLookup[subjectCode]);
        }

        function getSplitMetadata(subjectCode) {
            return splitSubjectLookup[subjectCode] || null;
        }

        function applyLineMappingToSubject(subjectCode, lineIndex) {
            if (!Number.isFinite(lineIndex)) {
                return false;
            }

            let changed = false;

            const updateMapping = code => {
                if (!code) {
                    return;
                }
                const normalized = normalizeSubjectCode(code);
                if (!normalized) {
                    return;
                }

                const previous = Object.prototype.hasOwnProperty.call(subjectLineMapping, normalized)
                    ? subjectLineMapping[normalized]
                    : undefined;
                if (previous !== lineIndex) {
                    subjectLineMapping[normalized] = lineIndex;
                    changed = true;
                }

                if (code !== normalized) {
                    if (subjectLineMapping[code] !== lineIndex) {
                        changed = true;
                    }
                    subjectLineMapping[code] = lineIndex;
                }
            };

            updateMapping(subjectCode);

            const metadata = getSplitMetadata(subjectCode);
            if (metadata && metadata.baseSubject && metadata.baseSubject !== subjectCode) {
                updateMapping(metadata.baseSubject);
                const baseSplits = subjectSplits[metadata.baseSubject];
                if (Array.isArray(baseSplits)) {
                    baseSplits.forEach(split => updateMapping(split && split.code));
                }
            } else if (subjectSplits[subjectCode]) {
                subjectSplits[subjectCode].forEach(split => updateMapping(split && split.code));
            }

            return changed;
        }

        function setLineMappingForCode(subjectCode, lineIndex) {
            if (!subjectCode || !Number.isFinite(lineIndex)) {
                return;
            }

            const normalized = normalizeSubjectCode(subjectCode);
            subjectLineMapping[subjectCode] = lineIndex;
            if (normalized && normalized !== subjectCode) {
                subjectLineMapping[normalized] = lineIndex;
            }
        }

        function clearLineMappingForSubject(subjectCode) {
            if (!subjectCode) {
                return false;
            }

            const normalizedCode = normalizeSubjectCode(subjectCode);
            if (!normalizedCode) {
                return false;
            }

            let changed = false;

            const removeMapping = code => {
                if (!code) {
                    return;
                }
                const normalized = normalizeSubjectCode(code);
                if (!normalized) {
                    return;
                }
                if (Object.prototype.hasOwnProperty.call(subjectLineMapping, normalized)) {
                    delete subjectLineMapping[normalized];
                    changed = true;
                }
            };

            removeMapping(normalizedCode);

            const metadata = getSplitMetadata(normalizedCode);
            if (metadata && metadata.baseSubject && metadata.baseSubject !== normalizedCode) {
                removeMapping(metadata.baseSubject);
                const baseSplits = subjectSplits[metadata.baseSubject];
                if (Array.isArray(baseSplits)) {
                    baseSplits.forEach(split => removeMapping(split && split.code));
                }
            } else if (subjectSplits[normalizedCode]) {
                subjectSplits[normalizedCode].forEach(split => removeMapping(split && split.code));
            }

            return changed;
        }

        function applyYearMappingToSubject(subjectCode, yearLabel) {
            const normalizedLabel = normalizeYearLabel(yearLabel);
            if (!normalizedLabel) {
                return false;
            }

            let changed = false;

            const updateYear = code => {
                if (!code) {
                    return;
                }
                if (subjectYearMapping[code] !== normalizedLabel) {
                    subjectYearMapping[code] = normalizedLabel;
                    changed = true;
                }
            };

            updateYear(subjectCode);

            const metadata = getSplitMetadata(subjectCode);
            if (metadata && metadata.baseSubject && metadata.baseSubject !== subjectCode) {
                updateYear(metadata.baseSubject);
                const baseSplits = subjectSplits[metadata.baseSubject];
                if (Array.isArray(baseSplits)) {
                    baseSplits.forEach(split => updateYear(split && split.code));
                }
            } else if (subjectSplits[subjectCode]) {
                subjectSplits[subjectCode].forEach(split => updateYear(split && split.code));
            }

            return changed;
        }

        function setYearMappingForCode(subjectCode, yearLabel) {
            if (!subjectCode) {
                return;
            }
            const normalizedLabel = normalizeYearLabel(yearLabel);
            if (!normalizedLabel) {
                return;
            }
            subjectYearMapping[subjectCode] = normalizedLabel;
        }

        function purgeSubjectFromCsvData(subjectCode) {
            if (!subjectCode || !Array.isArray(csvData)) {
                return;
            }

            const normalizedTarget = normalizeSubjectCode(subjectCode);
            csvData.forEach(row => {
                if (!Array.isArray(row)) {
                    return;
                }
                row.forEach((cell, index) => {
                    if (typeof cell !== 'string') {
                        return;
                    }
                    const trimmed = cell.trim();
                    if (trimmed.length === 0) {
                        return;
                    }
                    const normalizedCell = normalizeSubjectCode(trimmed);
                    if (trimmed === subjectCode || (normalizedTarget && normalizedCell === normalizedTarget)) {
                        row[index] = '';
                    }
                });
            });
        }

        function removeParentSubjectReferences(subjectCode) {
            if (!subjectCode) {
                return;
            }

            const normalized = normalizeSubjectCode(subjectCode);
            const deleteFromMap = map => {
                if (!map || typeof map !== 'object') {
                    return;
                }
                delete map[subjectCode];
                if (normalized && normalized !== subjectCode) {
                    delete map[normalized];
                }
            };

            deleteFromMap(subjectLineMapping);
            deleteFromMap(subjectYearMapping);

            if (subjectRoomAssignments && typeof subjectRoomAssignments === 'object') {
                delete subjectRoomAssignments[subjectCode];
                if (normalized && normalized !== subjectCode) {
                    delete subjectRoomAssignments[normalized];
                }
            }

            purgeSubjectFromCsvData(subjectCode);
        }

        function populateYearMappingFromSubjects() {
            if (!Array.isArray(subjects)) {
                return;
            }

            subjects.forEach(subject => {
                if (typeof subject !== 'string') {
                    return;
                }

                const trimmed = subject.trim();
                if (trimmed.length === 0) {
                    return;
                }

                const splitInfo = getSplitMetadata(trimmed);
                const baseSubject = splitInfo ? splitInfo.baseSubject : trimmed;

                let yearLabel = subjectYearMapping[trimmed] || subjectYearMapping[baseSubject];
                if (!yearLabel) {
                    yearLabel = deriveYearLabelFromCode(baseSubject);
                }

                if (yearLabel) {
                    applyYearMappingToSubject(baseSubject, yearLabel);
                }
            });
        }

        function applySubjectDisplay(element, subjectCode, options = {}) {
            if (!element) {
                return;
            }

            element.classList.remove('split-subject', 'split-segment');
            element.innerHTML = '';
            element.dataset.baseSubject = '';
            element.dataset.splitIndex = '';
            element.dataset.splitTotal = '';
            element.dataset.periods = '';

            const splitInfo = getSplitMetadata(subjectCode);

            if (!splitInfo) {
                element.textContent = subjectCode;
                element.title = subjectCode || '';
                return;
            }

            const { baseSubject, periods, index, totalSplits } = splitInfo;
            const hideBaseLabel = options.hideBaseLabel === true;

            element.classList.add(options.forceSegmentStyle ? 'split-segment' : 'split-subject');

            element.dataset.baseSubject = baseSubject;
            element.dataset.splitIndex = index;
            element.dataset.splitTotal = totalSplits;
            element.dataset.periods = periods;

            if (!hideBaseLabel) {
                const baseLabel = document.createElement('div');
                baseLabel.className = 'split-subject-base';
                baseLabel.textContent = baseSubject;
                element.appendChild(baseLabel);
            }

            const details = document.createElement('div');
            details.className = 'split-subject-details';

            const periodBadge = document.createElement('span');
            periodBadge.className = 'split-period-badge';
            periodBadge.textContent = `${periods}p`;
            details.appendChild(periodBadge);

            const partLabel = document.createElement('span');
            partLabel.className = 'split-part-label';
            partLabel.textContent = `Split ${index + 1}/${totalSplits}`;
            details.appendChild(partLabel);

            element.appendChild(details);

            element.title = `${baseSubject}  ${periods} period${periods === 1 ? '' : 's'} (Split ${index + 1}/${totalSplits})`;
        }

        function cloneRoomEntries(entries) {
            if (!Array.isArray(entries)) {
                return [];
            }
            return entries.map(entry => ({ ...entry }));
        }

        function createEmptyRoomEntry() {
            return { room: '', periods: '', label: '' };
        }

        function isRoomEntryEmpty(entry) {
            if (!entry || typeof entry !== 'object') {
                return true;
            }

            const hasRoom = typeof entry.room === 'string' && entry.room.trim() !== '';

            const rawPeriods = entry.periods;
            let hasPeriods = false;
            if (rawPeriods !== null && rawPeriods !== undefined) {
                if (typeof rawPeriods === 'string') {
                    hasPeriods = rawPeriods.trim() !== '';
                } else if (typeof rawPeriods === 'number') {
                    hasPeriods = !Number.isNaN(rawPeriods);
                } else {
                    hasPeriods = true;
                }
            }

            const hasLabel = typeof entry.label === 'string' && entry.label.trim() !== '';

            return !hasRoom && !hasPeriods && !hasLabel;
        }

        function sanitizeRoomEntry(entry) {
            if (!entry || typeof entry !== 'object') {
                return null;
            }

            const rawRoom = typeof entry.room === 'string' ? entry.room.trim().toUpperCase() : '';
            if (!rawRoom || !AVAILABLE_ROOMS.includes(rawRoom)) {
                return null;
            }

            let periodsValue = entry.periods;
            if (typeof periodsValue === 'string') {
                periodsValue = periodsValue.trim();
            }

            let periods = null;
            if (periodsValue !== null && periodsValue !== undefined && periodsValue !== '') {
                const numeric = Number(periodsValue);
                if (Number.isFinite(numeric) && numeric >= 0) {
                    periods = Number.isInteger(numeric) ? numeric : parseFloat(numeric.toFixed(2));
                }
            }

            let label = '';
            if (typeof entry.label === 'string') {
                label = entry.label.trim();
            } else if (typeof entry.note === 'string') {
                label = entry.note.trim();
            }

            return {
                room: rawRoom,
                periods: periods,
                label: label
            };
        }

        function normalizeRoomEntries(entries) {
            if (!Array.isArray(entries)) {
                return [];
            }

            const seen = new Set();
            const normalized = [];

            entries.forEach(entry => {
                const sanitized = sanitizeRoomEntry(entry);
                if (!sanitized) {
                    return;
                }

                const key = `${sanitized.room}|${sanitized.periods !== null && sanitized.periods !== undefined ? sanitized.periods : ''}|${sanitized.label || ''}`;
                if (seen.has(key)) {
                    return;
                }
                seen.add(key);
                normalized.push(sanitized);
            });

            return normalized;
        }

        function getUniqueRoomsFromEntries(entries) {
            if (!Array.isArray(entries)) {
                return [];
            }

            const seenRooms = new Set();

            entries.forEach(entry => {
                if (!entry || typeof entry !== 'object') {
                    return;
                }

                const room = typeof entry.room === 'string' ? entry.room.trim().toUpperCase() : '';
                if (room) {
                    seenRooms.add(room);
                }
            });

            return Array.from(seenRooms);
        }

        function getDirectSubjectRoomAssignments(subjectCode) {
            const normalized = normalizeSubjectCode(subjectCode);
            if (!normalized) {
                return [];
            }
            const entries = subjectRoomAssignments[normalized];
            return Array.isArray(entries) ? cloneRoomEntries(entries) : [];
        }

        function getSubjectRoomAssignments(subjectCode, options = {}) {
            const direct = getDirectSubjectRoomAssignments(subjectCode);
            if (direct.length > 0) {
                return direct;
            }

            if (options.ignoreBase === true) {
                return [];
            }

            const metadata = getSplitMetadata(subjectCode);
            if (metadata && metadata.baseSubject && metadata.baseSubject !== subjectCode) {
                return getSubjectRoomAssignments(metadata.baseSubject, { ignoreBase: false });
            }

            return [];
        }

        function getInheritedSubjectRoomAssignments(subjectCode) {
            const metadata = getSplitMetadata(subjectCode);
            if (metadata && metadata.baseSubject && metadata.baseSubject !== subjectCode) {
                return getSubjectRoomAssignments(metadata.baseSubject);
            }
            return [];
        }

        function setSubjectRoomAssignments(subjectCode, entries) {
            const normalized = normalizeSubjectCode(subjectCode);
            if (!normalized) {
                return;
            }

            const sanitized = normalizeRoomEntries(entries);
            if (sanitized.length === 0) {
                delete subjectRoomAssignments[normalized];
            } else {
                subjectRoomAssignments[normalized] = sanitized;
            }
        }

        function clearSubjectRoomAssignments(subjectCode) {
            const normalized = normalizeSubjectCode(subjectCode);
            if (!normalized) {
                return;
            }
            delete subjectRoomAssignments[normalized];
        }

        function getAllocationRoomAssignments(lineIndex, teacherIndex, subjectCode) {
            const key = getAllocationKey(lineIndex, teacherIndex);
            const normalized = normalizeSubjectCode(subjectCode);
            if (!normalized) {
                return [];
            }
            const overrides = allocationRoomOverrides && allocationRoomOverrides[key];
            if (!overrides || typeof overrides !== 'object') {
                return [];
            }
            const entries = overrides[normalized];
            return Array.isArray(entries) ? cloneRoomEntries(entries) : [];
        }

        function setAllocationRoomAssignments(lineIndex, teacherIndex, subjectCode, entries) {
            const key = getAllocationKey(lineIndex, teacherIndex);
            const parsed = parseAllocationKey(key);
            const normalized = normalizeSubjectCode(subjectCode);

            if (!parsed || !normalized) {
                return;
            }

            const sanitized = normalizeRoomEntries(entries);
            if (!allocationRoomOverrides || typeof allocationRoomOverrides !== 'object') {
                allocationRoomOverrides = {};
            }

            if (sanitized.length === 0) {
                if (allocationRoomOverrides[key]) {
                    delete allocationRoomOverrides[key][normalized];
                    if (Object.keys(allocationRoomOverrides[key]).length === 0) {
                        delete allocationRoomOverrides[key];
                    }
                }
                return;
            }

            if (!allocationRoomOverrides[key] || typeof allocationRoomOverrides[key] !== 'object') {
                allocationRoomOverrides[key] = {};
            }

            allocationRoomOverrides[key][normalized] = sanitized;
        }

        function clearAllocationRoomAssignments(lineIndex, teacherIndex, subjectCode) {
            setAllocationRoomAssignments(lineIndex, teacherIndex, subjectCode, []);
        }

        function getEffectiveRoomAssignmentsForCell(subjectCode, lineIndex, teacherIndex) {
            const override = getAllocationRoomAssignments(lineIndex, teacherIndex, subjectCode);
            if (override.length > 0) {
                return override;
            }
            return getSubjectRoomAssignments(subjectCode);
        }

        function hasAllocationRoomOverride(lineIndex, teacherIndex, subjectCode) {
            const key = getAllocationKey(lineIndex, teacherIndex);
            const normalized = normalizeSubjectCode(subjectCode);
            if (!normalized || !allocationRoomOverrides || typeof allocationRoomOverrides !== 'object') {
                return false;
            }
            const mapping = allocationRoomOverrides[key];
            if (!mapping || typeof mapping !== 'object') {
                return false;
            }
            const entries = mapping[normalized];
            return Array.isArray(entries) && entries.length > 0;
        }

        function removeRoomOverridesForSubject(subjectCode) {
            const normalized = normalizeSubjectCode(subjectCode);
            if (!normalized || !allocationRoomOverrides || typeof allocationRoomOverrides !== 'object') {
                return;
            }

            Object.entries({ ...allocationRoomOverrides }).forEach(([key, mapping]) => {
                if (!mapping || typeof mapping !== 'object') {
                    delete allocationRoomOverrides[key];
                    return;
                }

                if (mapping[normalized]) {
                    delete mapping[normalized];
                }

                if (Object.keys(mapping).length === 0) {
                    delete allocationRoomOverrides[key];
                }
            });
        }

        function cleanupCellRoomAssignments(allocationKey, subjectsInCell) {
            if (!allocationRoomOverrides || typeof allocationRoomOverrides !== 'object') {
                return;
            }

            const overrides = allocationRoomOverrides[allocationKey];
            if (!overrides || typeof overrides !== 'object') {
                return;
            }

            const currentSubjects = Array.isArray(subjectsInCell)
                ? subjectsInCell.map(subject => normalizeSubjectCode(subject))
                : getAllocationSubjects(allocationKey).map(subject => normalizeSubjectCode(subject));

            const subjectSet = new Set(currentSubjects.filter(Boolean));

            Object.keys(overrides).forEach(subjectCode => {
                if (!subjectSet.has(subjectCode)) {
                    delete overrides[subjectCode];
                }
            });

            if (Object.keys(overrides).length === 0) {
                delete allocationRoomOverrides[allocationKey];
            }
        }

        function formatRoomEntryLabel(entry) {
            if (!entry || typeof entry !== 'object') {
                return '';
            }

            const parts = [entry.room];
            if (entry.periods !== null && entry.periods !== undefined && entry.periods !== '') {
                parts.push(`${entry.periods}`);
            }
            if (entry.label) {
                parts.push(`(${entry.label})`);
            }
            return parts.join(' ');
        }

        function areRoomEntriesEqual(first, second) {
            if (!Array.isArray(first) || !Array.isArray(second)) {
                return false;
            }
            if (first.length !== second.length) {
                return false;
            }
            for (let index = 0; index < first.length; index++) {
                const a = first[index];
                const b = second[index];
                if (!a || !b) {
                    return false;
                }
                const periodsA = a.periods === undefined ? null : a.periods;
                const periodsB = b.periods === undefined ? null : b.periods;
                const labelA = (a.label || '').trim();
                const labelB = (b.label || '').trim();
                if (a.room !== b.room || periodsA !== periodsB || labelA !== labelB) {
                    return false;
                }
            }
            return true;
        }

        function appendSubjectRoomDetails(element, subjectCode, context = {}) {
            if (!element || !subjectCode) {
                return;
            }

            element.querySelectorAll('.subject-room-footer').forEach(footer => footer.remove());
            element.classList.remove('subject-slot--with-rooms');

            const contextType = context.context || context.mode || 'pool';
            const lineIndex = context.lineIndex;
            const teacherIndex = context.teacherIndex;

            let entries = [];
            let isOverride = false;

            if (contextType === 'cell') {
                entries = getEffectiveRoomAssignmentsForCell(subjectCode, lineIndex, teacherIndex);
                isOverride = hasAllocationRoomOverride(lineIndex, teacherIndex, subjectCode);
            } else {
                entries = getSubjectRoomAssignments(subjectCode);
            }

            const shouldShowButton = contextType === 'cell';
            const hasEntries = entries.length > 0;

            if (!shouldShowButton && !hasEntries) {
                return;
            }

            const footer = document.createElement('div');
            footer.className = 'subject-room-footer';

            const tags = document.createElement('div');
            tags.className = 'subject-room-tags';

            if (hasEntries) {
                entries.forEach(entry => {
                    const tag = document.createElement('span');
                    tag.className = 'subject-room-tag';
                    if (isOverride) {
                        tag.classList.add('subject-room-tag--override');
                    }
                    tag.textContent = formatRoomEntryLabel(entry);
                    tags.appendChild(tag);
                });
            } else {
                const empty = document.createElement('span');
                empty.className = 'subject-room-empty';
                empty.textContent = 'No room set';
                tags.appendChild(empty);
            }

            footer.appendChild(tags);

            if (shouldShowButton) {
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'subject-room-edit';
                button.textContent = 'Rooms';
                button.title = 'Manage room allocation for this subject';
                button.addEventListener('click', event => {
                    event.preventDefault();
                    event.stopPropagation();
                    openRoomModal({
                        subjectCode: subjectCode,
                        lineIndex: lineIndex,
                        teacherIndex: teacherIndex,
                        mode: 'allocation'
                    });
                });
                footer.appendChild(button);
            }

            element.classList.add('subject-slot--with-rooms');
            element.appendChild(footer);
        }

        function computeRoomClashMap() {
            const map = new Map();

            if (!Array.isArray(lines) || lines.length === 0 || !Array.isArray(teachers) || teachers.length === 0) {
                return map;
            }

            for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                const roomAllocationMap = new Map();

                teachers.forEach((_, teacherIndex) => {
                    const subjects = getAllocationSubjects(getAllocationKey(lineIndex, teacherIndex));
                    if (!Array.isArray(subjects) || subjects.length === 0) {
                        return;
                    }

                    subjects.forEach(subjectCode => {
                        const entries = getEffectiveRoomAssignmentsForCell(subjectCode, lineIndex, teacherIndex);
                        const rooms = getUniqueRoomsFromEntries(entries);
                        if (rooms.length === 0) {
                            return;
                        }

                        rooms.forEach(room => {
                            if (!roomAllocationMap.has(room)) {
                                roomAllocationMap.set(room, []);
                            }
                            roomAllocationMap.get(room).push({
                                cellKey: getAllocationKey(lineIndex, teacherIndex),
                                subjectCode: subjectCode
                            });
                        });
                    });
                });

                roomAllocationMap.forEach(allocationsForRoom => {
                    const cellToSubjects = new Map();

                    allocationsForRoom.forEach(entry => {
                        if (!cellToSubjects.has(entry.cellKey)) {
                            cellToSubjects.set(entry.cellKey, new Set());
                        }
                        cellToSubjects.get(entry.cellKey).add(entry.subjectCode);
                    });

                    if (cellToSubjects.size <= 1) {
                        return;
                    }

                    cellToSubjects.forEach((subjectCodes, cellKey) => {
                        if (!map.has(cellKey)) {
                            map.set(cellKey, new Set());
                        }
                        subjectCodes.forEach(code => map.get(cellKey).add(code));
                    });
                });
            }

            return map;
        }

        function refreshRoomClashHighlights() {
            const newMap = computeRoomClashMap();

            if (typeof document === 'undefined') {
                activeRoomClashMap = newMap;
                return;
            }

            document.querySelectorAll('.drop-zone[data-room-clash="true"]').forEach(cell => {
                cell.removeAttribute('data-room-clash');
                cell.classList.remove('room-clash-cell');
            });

            document.querySelectorAll('.subject-slot[data-room-clash="true"]').forEach(slot => {
                slot.removeAttribute('data-room-clash');
                slot.classList.remove('room-clash');
            });

            newMap.forEach((subjectSet, cellKey) => {
                const parsed = parseAllocationKey(cellKey);
                if (!parsed) {
                    return;
                }

                const cell = document.querySelector(`[data-period="${parsed.lineIndex}"][data-teacher="${parsed.teacherIndex}"]`);
                if (!cell) {
                    return;
                }

                cell.dataset.roomClash = 'true';
                cell.classList.add('room-clash-cell');

                subjectSet.forEach(subjectCode => {
                    const elements = cell.querySelectorAll('[data-subject]');
                    elements.forEach(element => {
                        if (element.dataset.subject !== subjectCode) {
                            return;
                        }

                        const slot = element.classList.contains('subject-slot')
                            ? element
                            : element.closest('.subject-slot');

                        if (!slot) {
                            return;
                        }

                        slot.dataset.roomClash = 'true';
                        slot.classList.add('room-clash');
                    });
                });
            });

            activeRoomClashMap = newMap;
        }

        function scheduleRoomClashRefresh() {
            if (roomClashRefreshScheduled) {
                return;
            }

            roomClashRefreshScheduled = true;

            const scheduler = typeof requestAnimationFrame === 'function'
                ? requestAnimationFrame
                : callback => setTimeout(callback, 16);

            scheduler(() => {
                roomClashRefreshScheduled = false;
                try {
                    refreshRoomClashHighlights();
                } catch (error) {
                    console.error('Unable to refresh room clash highlights:', error);
                }
            });
        }

        function getAllocationKey(lineIndex, teacherIndex) {
            return `${lineIndex}-${teacherIndex}`;
        }

        function parseAllocationKey(rawKey) {
            if (typeof rawKey !== 'string') {
                return null;
            }

            const trimmed = rawKey.trim();
            if (trimmed.length === 0) {
                return null;
            }

            const parts = trimmed.split('-');
            if (parts.length !== 2) {
                return null;
            }

            const lineIndex = Number(parts[0]);
            const teacherIndex = Number(parts[1]);

            if (!Number.isFinite(lineIndex) || !Number.isFinite(teacherIndex)) {
                return null;
            }

            if (!Number.isInteger(lineIndex) || !Number.isInteger(teacherIndex)) {
                return null;
            }

            if (lineIndex < 0 || teacherIndex < 0) {
                return null;
            }

            return {
                key: `${lineIndex}-${teacherIndex}`,
                lineIndex,
                teacherIndex
            };
        }

        function getAllocationSubjects(key) {
            const parsed = parseAllocationKey(key);
            if (!parsed) {
                return [];
            }

            const value = allocations[parsed.key];
            if (!value) {
                return [];
            }

            return Array.isArray(value) ? [...value] : [value];
        }

        function setAllocationSubjects(key, subjects) {
            const parsed = parseAllocationKey(key);
            if (!parsed) {
                console.warn('Ignoring allocation update for invalid key:', key);
                return;
            }

            if (!subjects || subjects.length === 0) {
                delete allocations[parsed.key];
                cleanupCellRoomAssignments(parsed.key, []);
            } else {
                allocations[parsed.key] = [...subjects];
                cleanupCellRoomAssignments(parsed.key, subjects);
            }
        }

        function rebuildSubjectLineMappingFromAllocations() {
            const rebuilt = {};

            if (!allocations || typeof allocations !== 'object') {
                return rebuilt;
            }

            Object.entries(allocations).forEach(([key, value]) => {
                const parsed = parseAllocationKey(key);
                if (!parsed) {
                    return;
                }

                const subjectsInCell = Array.isArray(value) ? value : [value];
                subjectsInCell.forEach(subjectCode => {
                    if (typeof subjectCode !== 'string') {
                        return;
                    }

                    const normalizedCode = normalizeSubjectCode(subjectCode);
                    const effectiveCode = normalizedCode || subjectCode;
                    rebuilt[effectiveCode] = parsed.lineIndex;
                });
            });

            return rebuilt;
        }

        function selfHealSubjectLineMapping() {
            const rebuilt = rebuildSubjectLineMappingFromAllocations();
            let changed = 0;

            Object.entries(rebuilt).forEach(([code, lineIndex]) => {
                if (subjectLineMapping[code] !== lineIndex) {
                    subjectLineMapping[code] = lineIndex;
                    changed++;
                }
            });

            if (changed > 0) {
                console.warn(`[Self-heal] Updated ${changed} subjectLineMapping entr${changed === 1 ? 'y' : 'ies'} from allocations.`);
            }

            return changed;
        }

        function validateMappingAgainstAllocations() {
            const rebuilt = rebuildSubjectLineMappingFromAllocations();
            const mismatches = [];

            Object.entries(rebuilt).forEach(([code, lineIndex]) => {
                if (subjectLineMapping[code] !== lineIndex) {
                    mismatches.push({ code, expected: lineIndex, actual: subjectLineMapping[code] });
                }
            });

            if (mismatches.length > 0) {
                console.warn('[Validation] subjectLineMapping mismatches:', mismatches);
            }
        }

        function commitSubjectMove(subjectCode, oldLineIndex, oldTeacherIndex, newLineIndex, newTeacherIndex) {
            if (typeof subjectCode !== 'string') {
                return;
            }

            if (!Number.isInteger(newLineIndex) || !Number.isInteger(newTeacherIndex)) {
                return;
            }

            const normalizedCode = normalizeSubjectCode(subjectCode);
            const effectiveCode = normalizedCode || subjectCode;

            if (Number.isInteger(oldLineIndex) && Number.isInteger(oldTeacherIndex)) {
                const oldKey = getAllocationKey(oldLineIndex, oldTeacherIndex);
                const subjectsInOldCell = getAllocationSubjects(oldKey);
                const index = subjectsInOldCell.indexOf(effectiveCode);
                if (index !== -1) {
                    subjectsInOldCell.splice(index, 1);
                    setAllocationSubjects(oldKey, subjectsInOldCell);
                }
            }

            const newKey = getAllocationKey(newLineIndex, newTeacherIndex);
            const subjectsInNewCell = getAllocationSubjects(newKey);
            if (!subjectsInNewCell.includes(effectiveCode)) {
                subjectsInNewCell.push(effectiveCode);
                setAllocationSubjects(newKey, subjectsInNewCell);
            }

            subjectLineMapping[effectiveCode] = newLineIndex;
            if (subjectCode !== effectiveCode) {
                subjectLineMapping[subjectCode] = newLineIndex;
            }

            if (IS_DEV_ENV) {
                validateMappingAgainstAllocations();
            }
        }

        function flattenAllocatedSubjects() {
            const list = [];
            Object.values(allocations).forEach(value => {
                if (Array.isArray(value)) {
                    list.push(...value);
                } else if (value) {
                    list.push(value);
                }
            });
            return list;
        }

        function findSubjectLocation(subjectCode) {
            for (const [key, value] of Object.entries(allocations)) {
                const parsed = parseAllocationKey(key);
                if (!parsed) {
                    delete allocations[key];
                    continue;
                }

                const subjects = Array.isArray(value) ? value : [value];
                const index = subjects.indexOf(subjectCode);
                if (index !== -1) {
                    return {
                        key: parsed.key,
                        lineIndex: parsed.lineIndex,
                        teacherIndex: parsed.teacherIndex,
                        index
                    };
                }
            }
            return null;
        }

        function clearActionHistory() {
            actionHistory = [];
            redoStack = [];

            const undoBtn = document.getElementById('undoBtn');
            if (undoBtn) {
                undoBtn.disabled = true;
            }

            const redoBtn = document.getElementById('redoBtn');
            if (redoBtn) {
                redoBtn.disabled = true;
            }
        }

        function resolveLineReference(reference) {
            if (reference === null || reference === undefined) {
                return null;
            }

            if (Number.isInteger(reference)) {
                return reference >= 0 && reference < lines.length ? reference : null;
            }

            if (typeof reference === 'string') {
                const trimmed = reference.trim();
                if (trimmed.length === 0) {
                    return null;
                }

                const labelIndex = lines.indexOf(trimmed);
                if (labelIndex !== -1) {
                    return labelIndex;
                }

                const numeric = parseInt(trimmed, 10);
                if (!Number.isNaN(numeric) && numeric >= 0 && numeric < lines.length) {
                    return numeric;
                }
            }

            const numericValue = Number(reference);
            if (Number.isInteger(numericValue) && numericValue >= 0 && numericValue < lines.length) {
                return numericValue;
            }

            return null;
        }

        function addTeacher(teacherName, options = {}) {
            const { skipRefresh = false, silent = false } = options;

            if (!teacherName || typeof teacherName !== 'string') {
                if (!silent) {
                    alert('Teacher name cannot be empty.');
                }
                return false;
            }

            const trimmedName = teacherName.trim();
            if (trimmedName.length === 0) {
                if (!silent) {
                    alert('Teacher name cannot be empty.');
                }
                return false;
            }

            if (teachers.includes(trimmedName)) {
                if (!silent) {
                    alert('This teacher already exists.');
                }
                return false;
            }

            teachers.push(trimmedName);
            getTeacherLoadSettings(trimmedName);

            if (!skipRefresh) {
                initializeTimetable();
                createSubjectPool();
                updateStats();
            }

            return true;
        }

        function removeTeacher(teacherName, options = {}) {
            const { skipRefresh = false, silent = false } = options;
            const index = teachers.indexOf(teacherName);

            if (index === -1) {
                if (!silent) {
                    alert('Teacher not found.');
                }
                return null;
            }

            const removedSubjects = [];
            const updatedAllocations = {};

            Object.entries(allocations).forEach(([key, value]) => {
                const parsed = parseAllocationKey(key);
                if (!parsed) {
                    delete allocations[key];
                    return;
                }

                const { lineIndex, teacherIndex } = parsed;

                if (teacherIndex === index) {
                    const subjectList = Array.isArray(value) ? value : [value];
                    subjectList.forEach(subject => {
                        if (subject) {
                            removedSubjects.push(subject);
                        }
                    });
                    return;
                }

                const newTeacherIndex = teacherIndex > index ? teacherIndex - 1 : teacherIndex;
                const subjectList = Array.isArray(value) ? [...value] : [value];

                if (subjectList.length > 0) {
                    updatedAllocations[getAllocationKey(lineIndex, newTeacherIndex)] = subjectList;
                }
            });

            teachers.splice(index, 1);
            delete teacherLoadSettings[teacherName];
            if (teacherAllocations && typeof teacherAllocations === 'object') {
                delete teacherAllocations[teacherName];
            }

            allocations = {};
            Object.entries(updatedAllocations).forEach(([key, value]) => {
                setAllocationSubjects(key, Array.isArray(value) ? value : [value]);
            });

            clearActionHistory();

            if (!skipRefresh) {
                initializeTimetable();
                createSubjectPool();
                updateStats();
            }

            return {
                removedSubjects: removedSubjects,
                removedCount: removedSubjects.length
            };
        }

        function addLine(lineLabel, options = {}) {
            const { skipRefresh = false, silent = false } = options;

            if (!lineLabel || typeof lineLabel !== 'string') {
                if (!silent) {
                    alert('Line name cannot be empty.');
                }
                return false;
            }

            const trimmedLabel = lineLabel.trim();
            if (trimmedLabel.length === 0) {
                if (!silent) {
                    alert('Line name cannot be empty.');
                }
                return false;
            }

            if (lines.includes(trimmedLabel)) {
                if (!silent) {
                    alert('This line already exists.');
                }
                return false;
            }

            lines.push(trimmedLabel);
            ensureLineDurationEntry(trimmedLabel);

            if (!skipRefresh) {
                initializeTimetable();
                createSubjectPool();
                updateStats();
            }

            return true;
        }

        function removeLine(lineLabel, options = {}) {
            const { skipRefresh = false, silent = false } = options;
            const index = lines.indexOf(lineLabel);

            if (index === -1) {
                if (!silent) {
                    alert('Line not found.');
                }
                return null;
            }

            const removedSubjects = [];
            const updatedAllocations = {};

            Object.entries(allocations).forEach(([key, value]) => {
                const parsed = parseAllocationKey(key);
                if (!parsed) {
                    delete allocations[key];
                    return;
                }

                const { lineIndex, teacherIndex } = parsed;

                if (lineIndex === index) {
                    const subjectList = Array.isArray(value) ? value : [value];
                    subjectList.forEach(subject => {
                        if (subject) {
                            removedSubjects.push(subject);
                        }
                    });
                    return;
                }

                const newLineIndex = lineIndex > index ? lineIndex - 1 : lineIndex;
                const subjectList = Array.isArray(value) ? [...value] : [value];

                if (subjectList.length > 0) {
                    updatedAllocations[getAllocationKey(newLineIndex, teacherIndex)] = subjectList;
                }
            });

            lines.splice(index, 1);
            rebuildLineDurations();

            Object.keys(subjectLineMapping).forEach(subject => {
                const mappedLine = subjectLineMapping[subject];
                if (mappedLine === index) {
                    delete subjectLineMapping[subject];
                } else if (Number.isInteger(mappedLine) && mappedLine > index) {
                    subjectLineMapping[subject] = mappedLine - 1;
                }
            });

            allocations = {};
            Object.entries(updatedAllocations).forEach(([key, value]) => {
                setAllocationSubjects(key, Array.isArray(value) ? value : [value]);
            });

            clearActionHistory();

            if (!skipRefresh) {
                initializeTimetable();
                createSubjectPool();
                updateStats();
            }

            return {
                removedSubjects: removedSubjects,
                removedCount: removedSubjects.length
            };
        }

        function addSubjectCode(subjectCode, options = {}) {
            const { lineIndex = null, skipRefresh = false, silent = false } = options;

            if (subjectCode === null || subjectCode === undefined) {
                if (!silent) {
                    alert('Subject code cannot be empty.');
                }
                return false;
            }

            const normalizedCode = normalizeSubjectCode(subjectCode);
            if (!normalizedCode) {
                if (!silent) {
                    alert('Subject code cannot be empty.');
                }
                return false;
            }

            if (subjects.includes(normalizedCode)) {
                if (!silent) {
                    alert('This subject already exists.');
                }
                return false;
            }

            subjects.push(normalizedCode);

            if (Number.isInteger(lineIndex) && lineIndex >= 0 && lineIndex < lines.length) {
                subjectLineMapping[normalizedCode] = lineIndex;
            } else {
                delete subjectLineMapping[normalizedCode];
            }

            if (!skipRefresh) {
                createSubjectPool();
                updateStats();
            }

            return true;
        }

        function removeSubjectCode(subjectCode, options = {}) {
            const { skipRefresh = false, silent = false } = options;

            if (!subjectCode) {
                if (!silent) {
                    alert('Subject code cannot be empty.');
                }
                return null;
            }

            const normalizedCode = normalizeSubjectCode(subjectCode);
            const isBaseSubject = Boolean(subjectSplits[normalizedCode]);
            const splitMetadata = getSplitMetadata(normalizedCode);
            const exists = subjects.includes(normalizedCode) || isBaseSubject || Boolean(splitMetadata);

            if (!exists) {
                if (!silent) {
                    alert('Subject not found.');
                }
                return null;
            }

            const removedCodes = new Set();
            let removedFromAllocations = 0;

            function removeAllocationsForSubject(code) {
                if (!code) {
                    return;
                }

                let location = findSubjectLocation(code);
                while (location) {
                    const key = getAllocationKey(location.lineIndex, location.teacherIndex);
                    const subjectsInCell = getAllocationSubjects(key).filter(subject => subject !== code);
                    setAllocationSubjects(key, subjectsInCell);
                    removedFromAllocations++;
                    location = findSubjectLocation(code);
                }
            }

            function removeCodeFromLists(code) {
                if (!code) {
                    return;
                }

                subjects = subjects.filter(subject => subject !== code);
                delete subjectLineMapping[code];
                removeSubjectFromPool(code);
                removedCodes.add(code);
            }

            if (isBaseSubject) {
                const splits = Array.isArray(subjectSplits[normalizedCode]) ? subjectSplits[normalizedCode] : [];
                splits.forEach(split => {
                    if (split && typeof split.code === 'string') {
                        removeAllocationsForSubject(split.code);
                        removeCodeFromLists(split.code);
                    }
                });

                removeAllocationsForSubject(normalizedCode);
                removeCodeFromLists(normalizedCode);

                delete subjectSplits[normalizedCode];
                rebuildSplitLookup();
            } else if (splitMetadata) {
                const baseSubject = splitMetadata.baseSubject;
                removeAllocationsForSubject(normalizedCode);
                removeCodeFromLists(normalizedCode);

                if (baseSubject && Array.isArray(subjectSplits[baseSubject])) {
                    const remainingSplits = subjectSplits[baseSubject]
                        .filter(split => split && split.code !== normalizedCode);

                    if (remainingSplits.length === 0) {
                        delete subjectSplits[baseSubject];
                        rebuildSplitLookup();
                        if (!subjects.includes(baseSubject)) {
                            subjects.push(baseSubject);
                        }
                    } else {
                        subjectSplits[baseSubject] = remainingSplits.map((split, index) => ({
                            ...split,
                            index: index,
                            totalSplits: remainingSplits.length
                        }));
                        rebuildSplitLookup();
                    }
                } else {
                    rebuildSplitLookup();
                }
            } else {
                removeAllocationsForSubject(normalizedCode);
                removeCodeFromLists(normalizedCode);
            }

            removedCodes.forEach(code => {
                clearSubjectRoomAssignments(code);
                removeRoomOverridesForSubject(code);
            });

            clearActionHistory();

            if (!skipRefresh) {
                renderAllAllocations();
                createSubjectPool();
                updateStats();
            }

            return {
                removedSubjects: Array.from(removedCodes),
                removedCount: removedCodes.size,
                removedFromAllocations: removedFromAllocations
            };
        }

        function openManagementHub() {
            const modal = document.getElementById('autocompleteModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalDescription = document.getElementById('modalDescription');
            const container = document.querySelector('.autocomplete-container');
            const managementContainer = document.getElementById('managementActionContainer');
            const confirmBtn = document.getElementById('confirmBtn');
            const cancelBtn = document.getElementById('cancelBtn');
            const list = document.getElementById('autocompleteList');
            const input = document.getElementById('autocompleteInput');

            if (!modal || !modalTitle || !managementContainer) {
                alert('Add / Remove Data tools are currently unavailable.');
                return;
            }

            currentAutocompleteCallback = null;
            selectedIndex = -1;
            filteredItems = [];
            currentDisplayedItems = [];
            currentAutocompleteOptions = {};

            if (container) {
                container.style.display = 'none';
                container.classList.remove('autocomplete-container--static');
            }

            if (input) {
                input.value = '';
            }

            if (list) {
                list.innerHTML = '';
                list.style.display = 'none';
                list.classList.remove('autocomplete-list--grid');
            }

            if (confirmBtn) {
                confirmBtn.style.display = 'none';
            }

            if (cancelBtn) {
                cancelBtn.textContent = 'Close';
            }

            if (modalTitle) {
                modalTitle.textContent = 'Add / Remove Data';
            }

            if (modalDescription) {
                modalDescription.textContent = 'Choose a task to add or remove teachers, subjects, timetable lines or supplemental data.';
                modalDescription.style.display = 'block';
            }

            const sections = [
                {
                    key: 'add',
                    title: 'Add',
                    subtitle: 'Introduce new teachers, subjects or lines.',
                    sectionClass: 'management-actions__section--add',
                    buttonClass: 'management-actions__button--add',
                    actions: [
                        { label: 'Add Teacher', description: 'Create a new teacher profile ready for allocation.', handler: promptAddTeacher },
                        { label: 'Add Subject', description: 'Add a subject code to the available pool.', handler: promptAddSubject },
                        { label: 'Add Line', description: 'Insert a new timetable line for allocations.', handler: promptAddLine }
                    ]
                },
                {
                    key: 'remove',
                    title: 'Remove',
                    subtitle: 'Retire teachers, subjects or lines you no longer need.',
                    sectionClass: 'management-actions__section--remove',
                    buttonClass: 'management-actions__button--remove',
                    actions: [
                        { label: 'Remove Teacher', description: 'Return all allocations and remove a teacher.', handler: promptRemoveTeacher },
                        { label: 'Remove Subject', description: 'Clear allocations and remove a subject code.', handler: promptRemoveSubject },
                        { label: 'Remove Line', description: 'Delete a timetable line and shift allocations.', handler: promptRemoveLine }
                    ]
                }
            ];

            managementContainer.innerHTML = '';

            const tabsContainer = document.createElement('div');
            tabsContainer.className = 'management-actions__tabs';
            tabsContainer.setAttribute('role', 'tablist');

            const sectionsWrapper = document.createElement('div');
            sectionsWrapper.className = 'management-actions__sections';

            managementContainer.appendChild(tabsContainer);
            managementContainer.appendChild(sectionsWrapper);

            const sectionRefs = new Map();
            let actionCount = 0;

            const setActiveSection = (key) => {
                sectionRefs.forEach(({ tab, section }, sectionKey) => {
                    const isActive = sectionKey === key;

                    if (tab) {
                        tab.classList.toggle('management-actions__tab--active', isActive);
                        tab.setAttribute('aria-selected', isActive ? 'true' : 'false');
                    }

                    if (section) {
                        section.classList.toggle('management-actions__section--active', isActive);
                        section.hidden = !isActive;
                    }
                });
            };

            sections.forEach(section => {
                const availableActions = Array.isArray(section.actions)
                    ? section.actions.filter(action => typeof action.handler === 'function')
                    : [];

                if (availableActions.length === 0) {
                    return;
                }

                actionCount += availableActions.length;

                const sectionId = `management-section-${section.key}`;

                const tabButton = document.createElement('button');
                tabButton.type = 'button';
                tabButton.className = 'management-actions__tab';
                tabButton.textContent = section.title;
                tabButton.setAttribute('data-section-key', section.key);
                tabButton.setAttribute('aria-controls', sectionId);
                tabButton.setAttribute('role', 'tab');
                const tabId = `management-tab-${section.key}`;
                tabButton.id = tabId;
                tabsContainer.appendChild(tabButton);

                const sectionElement = document.createElement('section');
                sectionElement.className = `management-actions__section ${section.sectionClass || ''}`.trim();
                sectionElement.id = sectionId;
                sectionElement.dataset.sectionKey = section.key;
                sectionElement.setAttribute('role', 'tabpanel');
                sectionElement.setAttribute('aria-labelledby', tabId);
                sectionElement.hidden = true;

                const header = document.createElement('div');
                header.className = 'management-actions__header';

                const titleEl = document.createElement('div');
                titleEl.className = 'management-actions__title';
                titleEl.textContent = section.title;
                header.appendChild(titleEl);

                if (section.subtitle) {
                    const subtitleEl = document.createElement('div');
                    subtitleEl.className = 'management-actions__subtitle';
                    subtitleEl.textContent = section.subtitle;
                    header.appendChild(subtitleEl);
                }

                sectionElement.appendChild(header);

                const buttonGroup = document.createElement('div');
                buttonGroup.className = 'management-actions__buttons';

                availableActions.forEach(action => {
                    const button = document.createElement('button');
                    button.type = 'button';
                    button.className = `management-actions__button ${section.buttonClass || ''}`.trim();

                    const labelEl = document.createElement('span');
                    labelEl.className = 'management-actions__button-label';
                    labelEl.textContent = action.label;
                    button.appendChild(labelEl);

                    if (action.description) {
                        const descriptionEl = document.createElement('span');
                        descriptionEl.className = 'management-actions__button-description';
                        descriptionEl.textContent = action.description;
                        button.appendChild(descriptionEl);
                    }

                    button.addEventListener('click', () => {
                        closeModal();
                        setTimeout(() => {
                            try {
                                action.handler();
                            } catch (error) {
                                console.error('Error executing management action:', error);
                                alert('Unable to execute the selected management action: ' + error.message);
                            }
                        }, 200);
                    });

                    buttonGroup.appendChild(button);
                });

                sectionElement.appendChild(buttonGroup);
                sectionsWrapper.appendChild(sectionElement);

                sectionRefs.set(section.key, { tab: tabButton, section: sectionElement });

                tabButton.addEventListener('click', () => {
                    setActiveSection(section.key);

                    const firstActionButton = sectionElement.querySelector('button.management-actions__button');
                    if (firstActionButton) {
                        firstActionButton.focus({ preventScroll: true });
                    }
                });
            });

            if (actionCount === 0) {
                managementContainer.innerHTML = '';

                const emptyState = document.createElement('div');
                emptyState.textContent = 'No management actions are currently available.';
                emptyState.style.fontSize = '0.9rem';
                emptyState.style.color = '#5d6d7e';
                emptyState.style.textAlign = 'center';
                managementContainer.appendChild(emptyState);
            } else {
                const preferredDefault = sectionRefs.has('add') ? 'add' : sectionRefs.keys().next().value;
                setActiveSection(preferredDefault);
            }

            managementContainer.style.display = 'flex';

            modal.style.display = 'block';

            setTimeout(() => {
                const firstButton = managementContainer.querySelector('button.management-actions__button');
                if (firstButton) {
                    firstButton.focus();
                } else {
                    const modalContent = document.querySelector('.modal-content');
                    if (modalContent) {
                        modalContent.focus();
                    }
                }
            }, 60);
        }

        async function promptAddTeacher() {
            const name = await showAppPrompt('Enter the name of the new teacher:', {
                confirmLabel: 'Add teacher',
                cancelLabel: 'Cancel',
                placeholder: 'e.g. Ms Thompson'
            });
            if (name === null) {
                return;
            }

            if (addTeacher(name)) {
                alert(`Added ${name.trim()}.`);
            }
        }

        function promptRemoveTeacher() {
            if (!Array.isArray(teachers) || teachers.length === 0) {
                alert('There are no teachers to remove.');
                return;
            }

            const teacherOptions = teachers
                .filter(name => typeof name === 'string' && name.trim().length > 0)
                .map(name => name.trim())
                .sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));

            showAutocomplete('Select teacher to remove', teacherOptions, async function(selectedTeacher) {
                const confirmed = await showAppConfirm(`Remove ${selectedTeacher} and return their allocations to the pool?`, {
                    confirmLabel: 'Remove teacher',
                    cancelLabel: 'Keep teacher'
                });
                if (!confirmed) {
                    return;
                }

                const result = removeTeacher(selectedTeacher);
                if (result) {
                    const removalMessage = result.removedCount > 0
                        ? `${result.removedCount} subject${result.removedCount === 1 ? '' : 's'} returned to the pool.`
                        : 'No subjects were allocated to this teacher.';
                    alert(`Removed ${selectedTeacher}. ${removalMessage}`);
                }
            }, {
                showListOnOpen: true,
                hideSearchInput: true,
                hideConfirmButton: true,
                cancelLabel: 'Close',
                description: 'Select a teacher to remove. Returning a teacher moves all of their allocated subjects back to the pool.'
            });
        }

        async function promptAddSubject() {
            const codeInput = await showAppPrompt('Enter the new subject code:', {
                confirmLabel: 'Add subject',
                cancelLabel: 'Cancel',
                placeholder: 'e.g. BIO12'
            });
            if (codeInput === null) {
                return;
            }

            const normalized = normalizeSubjectCode(codeInput);
            if (!normalized) {
                alert('Subject code cannot be empty.');
                return;
            }

            const lineOptions = Array.isArray(lines) && lines.length > 0 ? [...lines] : [];
            lineOptions.push('Unassigned');

            setTimeout(() => {
                showAutocomplete(`Select default line for ${normalized}`, lineOptions, function(selectedLine) {
                    let lineIndex = null;
                    if (selectedLine && selectedLine !== 'Unassigned') {
                        const index = lines.indexOf(selectedLine);
                        if (index === -1) {
                            alert('Invalid line selection.');
                            return;
                        }
                        lineIndex = index;
                    }

                    if (addSubjectCode(normalized, { lineIndex: lineIndex })) {
                        if (lineIndex !== null && lines[lineIndex]) {
                            alert(`Added subject ${normalized} to ${lines[lineIndex]}.`);
                        } else {
                            alert(`Added subject ${normalized} (unassigned).`);
                        }
                    }
                }, {
                    showListOnOpen: true,
                    hideSearchInput: true,
                    hideConfirmButton: true,
                    cancelLabel: 'Cancel',
                    itemLayout: 'grid',
                    description: 'Select a default line for placement or choose Unassigned to keep it flexible.'
                });
            }, 150);
        }

        async function promptRemoveSubject() {
            const removalOptions = new Set(subjects);
            Object.keys(subjectSplits).forEach(baseSubject => removalOptions.add(baseSubject));

            if (removalOptions.size === 0) {
                alert('There are no subjects to remove.');
                return;
            }

            const options = Array.from(removalOptions)
                .filter(subject => typeof subject === 'string' && subject.trim().length > 0)
                .map(subject => subject.trim())
                .sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));

            showAutocomplete('Select subject to remove', options, async function(selectedSubject) {
                const confirmed = await showAppConfirm(`Remove ${selectedSubject} from the subject pool? Allocations will be cleared.`, {
                    confirmLabel: 'Remove subject',
                    cancelLabel: 'Keep subject'
                });
                if (!confirmed) {
                    return;
                }

                const result = removeSubjectCode(selectedSubject);
                if (result) {
                    const removalSummary = result.removedFromAllocations > 0
                        ? `${result.removedFromAllocations} allocation${result.removedFromAllocations === 1 ? '' : 's'} cleared.`
                        : 'No allocations needed to be cleared.';
                    alert(`Removed ${selectedSubject}. ${removalSummary}`);
                }
            }, {
                showListOnOpen: true,
                hideSearchInput: true,
                hideConfirmButton: true,
                cancelLabel: 'Close',
                description: 'Select a subject to remove. Removing a subject clears any allocations and returns it to the available pool.'
            });
        }

        async function promptAddLine() {
            const label = await showAppPrompt('Enter a name for the new line:', {
                confirmLabel: 'Add line',
                cancelLabel: 'Cancel',
                placeholder: 'e.g. Line 7'
            });
            if (label === null) {
                return;
            }

            if (addLine(label)) {
                alert(`Added ${label.trim()}.`);
            }
        }

        function promptRemoveLine() {
            if (!Array.isArray(lines) || lines.length === 0) {
                alert('There are no lines to remove.');
                return;
            }

            if (lines.length === 1) {
                alert('At least one line must remain.');
                return;
            }

            const options = [...lines];

            showAutocomplete('Select line to remove', options, async function(selectedLine) {
                const confirmed = await showAppConfirm(`Remove ${selectedLine}? Subjects allocated on this line will return to the pool.`, {
                    confirmLabel: 'Remove line',
                    cancelLabel: 'Keep line'
                });
                if (!confirmed) {
                    return;
                }

                const result = removeLine(selectedLine);
                if (result) {
                    const summary = result.removedCount > 0
                        ? `${result.removedCount} subject${result.removedCount === 1 ? '' : 's'} returned to the pool.`
                        : 'No allocations were tied to this line.';
                    alert(`Removed ${selectedLine}. ${summary}`);
                }
            }, {
                showListOnOpen: true,
                hideSearchInput: true,
                hideConfirmButton: true,
                cancelLabel: 'Close',
                itemLayout: 'grid',
                description: 'Select a line to remove. Removing a line returns all allocations on that line to the subject pool.'
            });
        }

        // ---------- Normalise ----------
        function normalizeSubjectCode(raw) {
            const s = String(raw || '').trim().replace(/\s+/g, ' ').toUpperCase();
            if (!s) {
                return '';
            }
            if (/^S[12]\s+\d/.test(s)) {
                return s;
            }
            return s.replace(/\s+/g, '');
        }

        function subjectComparisonKey(code) {
            if (!code) {
                return '';
            }
            return normalizeSubjectCode(code).replace(/\s+/g, '');
        }

        // ---------- CSV parsing (small, robust) ----------
        function splitCsvLine(line) {
            const out = [];
            let cur = '';
            let inQ = false;
            for (let i = 0; i < line.length; i++) {
                const ch = line[i];
                if (ch === '"') {
                    if (inQ && line[i + 1] === '"') {
                        cur += '"';
                        i++;
                    } else {
                        inQ = !inQ;
                    }
                } else if (ch === ',' && !inQ) {
                    out.push(cur);
                    cur = '';
                } else {
                    cur += ch;
                }
            }
            out.push(cur);
            return out;
        }

        function parseCsv(text) {
            return text
                .replace(/\r\n/g, '\n')
                .replace(/\r/g, '\n')
                .split('\n')
                .map(splitCsvLine);
        }

        function normalizeHeaderName(header) {
            return String(header || '')
                .trim()
                .toLowerCase()
                .replace(/[^a-z0-9]/g, '');
        }

        function extractFirstInteger(value) {
            const text = String(value ?? '').trim();
            if (text === '') {
                return NaN;
            }
            if (/^-?\d+$/.test(text)) {
                return Number(text);
            }
            const match = text.match(/-?\d+/);
            return match ? Number(match[0]) : NaN;
        }

        function deriveYearNumberFromCode(subjectCode) {
            if (subjectCode === null || subjectCode === undefined) {
                return null;
            }

            const label = deriveYearLabelFromCode(subjectCode);
            if (!label) {
                return null;
            }

            const match = label.match(/(\d{1,2})$/);
            if (!match) {
                return null;
            }

            const numeric = Number(match[1]);
            if (!Number.isInteger(numeric) || numeric < 7 || numeric > 12) {
                return null;
            }

            return numeric;
        }

        function resolveYearFromCounts(counts) {
            if (!counts || typeof counts !== 'object') {
                return null;
            }

            const entries = Array.from(counts.entries ? counts.entries() : []);
            if (entries.length === 0) {
                return null;
            }

            entries.sort((a, b) => {
                if (b[1] === a[1]) {
                    return a[0] - b[0];
                }
                return b[1] - a[1];
            });

            if (entries.length === 1) {
                return entries[0][0];
            }

            if (entries[0][1] > entries[1][1]) {
                return entries[0][0];
            }

            return null;
        }

        function inferYearFromCodes(codes) {
            if (!Array.isArray(codes) || codes.length === 0) {
                return null;
            }

            const counts = new Map();

            codes.forEach(code => {
                if (code === null || code === undefined) {
                    return;
                }

                const text = String(code).trim();
                if (text === '') {
                    return;
                }

                const numeric = deriveYearNumberFromCode(text);
                if (numeric === null) {
                    return;
                }

                counts.set(numeric, (counts.get(numeric) ?? 0) + 1);
            });

            return resolveYearFromCounts(counts);
        }

        function looksLong(headers) {
            const normalizedHeaders = new Set(headers.map(normalizeHeaderName));
            return ['year', 'row', 'line', 'codes'].every(h => normalizedHeaders.has(h));
        }

        function looksWide(headers) {
            const normalizedHeaders = new Set(headers.map(normalizeHeaderName));
            const base = ['year', 'row'];
            const maxLineNumber = getMaxLineNumber();
            const linesHeaders = Array.from({ length: maxLineNumber }, (_, idx) => 'line' + (idx + 1));
            return base.every(h => normalizedHeaders.has(h)) && linesHeaders.some(h => normalizedHeaders.has(h));
        }

        function looksLikeTeacherHeaders(headers) {
            const normalized = headers.map(normalizeHeaderName);
            if (normalized.length === 0) {
                return false;
            }
            return normalized.some(name => ['teacher', 'teachername', 'staff', 'staffname', 'name'].includes(name));
        }

        function parseNumericValue(value) {
            if (value === null || value === undefined) {
                return null;
            }
            if (typeof value === 'number' && Number.isFinite(value)) {
                return value;
            }
            const text = String(value).replace(/,/g, '').trim();
            if (text === '') {
                return null;
            }
            const match = text.match(/-?\d+(?:\.\d+)?/);
            if (!match) {
                return null;
            }
            const numeric = Number(match[0]);
            return Number.isFinite(numeric) ? numeric : null;
        }

        function parseFteValue(value) {
            const numeric = parseNumericValue(value);
            if (numeric === null) {
                return null;
            }
            return numeric.toFixed(1);
        }

        function sanitizeTeacherSettings(rawSettings) {
            if (!rawSettings || typeof rawSettings !== 'object') {
                return null;
            }

            const settings = {};

            if (rawSettings.fte !== undefined) {
                const fteValue = parseFteValue(rawSettings.fte);
                if (fteValue !== null) {
                    settings.fte = fteValue;
                }
            }

            const allowanceValue = parseNumericValue(rawSettings.periodAllowance ?? rawSettings.allowance);
            if (allowanceValue !== null) {
                settings.periodAllowance = allowanceValue;
            }

            const assemblyFullValue = parseNumericValue(rawSettings.assemblyFullCount ?? rawSettings.assemblyFull);
            if (assemblyFullValue !== null) {
                settings.assemblyFullCount = assemblyFullValue;
            }

            const assemblyShortValue = parseNumericValue(rawSettings.assemblyShortCount ?? rawSettings.assemblyShort);
            if (assemblyShortValue !== null) {
                settings.assemblyShortCount = assemblyShortValue;
            }

            const additionalMinutesValue = parseNumericValue(
                rawSettings.additionalMinutes ?? rawSettings.extraMinutes ?? rawSettings.minutes
            );
            if (additionalMinutesValue !== null) {
                settings.additionalMinutes = additionalMinutesValue;
            }

            return Object.keys(settings).length > 0 ? settings : null;
        }

        function normalizeTeacherSupplemental(teacherCandidates, loadSettingsMap, metadata = {}) {
            const seen = new Map();
            const teachers = [];

            teacherCandidates.forEach(candidate => {
                const trimmed = String(candidate ?? '').trim();
                if (!trimmed) {
                    return;
                }
                const key = trimmed.toLowerCase();
                if (seen.has(key)) {
                    return;
                }
                const entry = loadSettingsMap && loadSettingsMap.get ? loadSettingsMap.get(key) : null;
                const displayName = entry && entry.displayName ? entry.displayName : trimmed;
                seen.set(key, displayName);
                teachers.push(displayName);
            });

            const teacherLoadSettings = {};
            if (loadSettingsMap && loadSettingsMap.forEach) {
                loadSettingsMap.forEach((entry, key) => {
                    const canonical = seen.get(key);
                    if (!canonical) {
                        return;
                    }
                    const sanitized = sanitizeTeacherSettings(entry && entry.settings);
                    if (sanitized) {
                        teacherLoadSettings[canonical] = sanitized;
                    }
                });
            }

            const previewRows = teachers.map(name => {
                const settings = teacherLoadSettings[name] || {};
                return {
                    teacher: name,
                    fte: settings.fte ?? '',
                    periodAllowance: settings.periodAllowance ?? '',
                    assemblyFullCount: settings.assemblyFullCount ?? '',
                    assemblyShortCount: settings.assemblyShortCount ?? '',
                    additionalMinutes: settings.additionalMinutes ?? ''
                };
            });

            const loadEntries = Object.entries(teacherLoadSettings);
            const stats = {
                teacherCount: teachers.length,
                loadCount: loadEntries.length,
                duplicates: metadata.duplicates ?? Math.max(0, teacherCandidates.length - teachers.length),
                blankRows: metadata.blankRows ?? 0,
                totalRows: metadata.totalRows ?? teacherCandidates.length,
                fteOverrides: loadEntries.filter(([, settings]) => typeof settings.fte === 'string' && settings.fte.trim() !== '').length,
                periodAllowanceOverrides: loadEntries.filter(([, settings]) => typeof settings.periodAllowance === 'number').length,
                assemblyFullOverrides: loadEntries.filter(([, settings]) => typeof settings.assemblyFullCount === 'number').length,
                assemblyShortOverrides: loadEntries.filter(([, settings]) => typeof settings.assemblyShortCount === 'number').length,
                additionalMinutesOverrides: loadEntries.filter(([, settings]) => typeof settings.additionalMinutes === 'number').length
            };

            return { teachers, teacherLoadSettings, previewRows, stats };
        }

        function teacherRowsToSupplemental(rows) {
            if (!Array.isArray(rows) || rows.length === 0) {
                throw new Error('Empty CSV');
            }

            const headers = rows[0].map(header => String(header ?? '').trim());
            if (!looksLikeTeacherHeaders(headers)) {
                return null;
            }

            const canonicalHeaders = headers.map(normalizeHeaderName);
            const headerIndex = new Map();
            headers.forEach((header, index) => {
                if (header && !headerIndex.has(header)) {
                    headerIndex.set(header, index);
                }
                const canonical = canonicalHeaders[index];
                if (canonical && !headerIndex.has(canonical)) {
                    headerIndex.set(canonical, index);
                }
            });

            const getIndex = names => {
                for (const name of names) {
                    if (headerIndex.has(name)) {
                        return headerIndex.get(name);
                    }
                }
                return -1;
            };

            const teacherIndex = getIndex(['teacher', 'teachername', 'staff', 'staffname', 'name']);
            if (teacherIndex === -1) {
                throw new Error('Teacher column not found in CSV.');
            }

            const fteIndex = getIndex(['fte', 'load', 'loading']);
            const allowanceIndex = getIndex(['periodallowance', 'allowance', 'allowances', 'periodallowances']);
            const assemblyFullIndex = getIndex(['assemblyfullcount', 'assemblyfull', 'fullassembly']);
            const assemblyShortIndex = getIndex(['assemblyshortcount', 'assemblyshort', 'shortassembly', 'assemblytlc']);
            const additionalMinutesIndex = getIndex(['additionalminutes', 'extraminutes', 'minutes']);

            const teacherCandidates = [];
            const loadSettingsByKey = new Map();
            const seenKeys = new Set();
            let duplicateCount = 0;
            let blankRows = 0;
            let totalRows = 0;

            rows.slice(1).forEach(rawRow => {
                const row = Array.isArray(rawRow) ? rawRow : [];
                const trimmedCells = row.map(cell => (cell === null || cell === undefined ? '' : String(cell).trim()));
                if (trimmedCells.every(cell => cell === '')) {
                    return;
                }

                totalRows++;

                const teacherName = trimmedCells[teacherIndex] || '';
                if (!teacherName) {
                    blankRows++;
                    return;
                }

                teacherCandidates.push(teacherName);
                const key = teacherName.toLowerCase();
                if (seenKeys.has(key)) {
                    duplicateCount++;
                } else {
                    seenKeys.add(key);
                }

                const rawSettings = {};
                if (fteIndex !== -1) {
                    rawSettings.fte = row[fteIndex];
                }
                if (allowanceIndex !== -1) {
                    rawSettings.periodAllowance = row[allowanceIndex];
                }
                if (assemblyFullIndex !== -1) {
                    rawSettings.assemblyFullCount = row[assemblyFullIndex];
                }
                if (assemblyShortIndex !== -1) {
                    rawSettings.assemblyShortCount = row[assemblyShortIndex];
                }
                if (additionalMinutesIndex !== -1) {
                    rawSettings.additionalMinutes = row[additionalMinutesIndex];
                }

                const sanitized = sanitizeTeacherSettings(rawSettings);
                const existing = loadSettingsByKey.get(key) || { displayName: teacherName, settings: {} };
                if (!existing.displayName) {
                    existing.displayName = teacherName;
                }
                if (sanitized) {
                    existing.settings = { ...existing.settings, ...sanitized };
                }
                loadSettingsByKey.set(key, existing);
            });

            const result = normalizeTeacherSupplemental(teacherCandidates, loadSettingsByKey, {
                duplicates: duplicateCount,
                blankRows,
                totalRows
            });

            if (!result || result.teachers.length === 0) {
                throw new Error('No teacher names found in the CSV.');
            }

            return result;
        }

        function isTeacherSupplementalJson(value) {
            return Boolean(value && typeof value === 'object' && Array.isArray(value.teachers));
        }

        function teacherJsonToSupplemental(data) {
            if (!isTeacherSupplementalJson(data)) {
                throw new Error('Teacher JSON must include a "teachers" array.');
            }

            const teacherCandidates = Array.isArray(data.teachers) ? data.teachers : [];
            const loadSettingsMap = new Map();

            if (data.teacherLoadSettings && typeof data.teacherLoadSettings === 'object') {
                Object.entries(data.teacherLoadSettings).forEach(([name, settings]) => {
                    const trimmedName = String(name ?? '').trim();
                    if (!trimmedName) {
                        return;
                    }
                    const key = trimmedName.toLowerCase();
                    const sanitized = sanitizeTeacherSettings(settings);
                    const existing = loadSettingsMap.get(key) || { displayName: trimmedName, settings: {} };
                    if (!existing.displayName) {
                        existing.displayName = trimmedName;
                    }
                    if (sanitized) {
                        existing.settings = { ...existing.settings, ...sanitized };
                    }
                    loadSettingsMap.set(key, existing);
                });
            }

            const result = normalizeTeacherSupplemental(teacherCandidates, loadSettingsMap, {
                duplicates: Math.max(0, teacherCandidates.length - new Set(teacherCandidates.map(name => String(name ?? '').trim().toLowerCase()).filter(Boolean)).size),
                totalRows: teacherCandidates.length,
                blankRows: teacherCandidates.filter(name => !String(name ?? '').trim()).length
            });

            if (!result || result.teachers.length === 0) {
                throw new Error('No teacher names found in the JSON.');
            }

            return result;
        }

        const XLSX_SUPPORTED_EXTENSIONS = ['.xlsx', '.xlsm', '.xls'];
        const MAX_ROWS_PER_YEAR = 6;

        function isXlsxFilename(name = '') {
            const lower = String(name || '').toLowerCase();
            return XLSX_SUPPORTED_EXTENSIONS.some(ext => lower.endsWith(ext));
        }

        function ensureXlsxAvailable() {
            if (typeof XLSX === 'undefined' || !XLSX || typeof XLSX.read !== 'function') {
                throw new Error('XLSX parsing support is not available. Refresh the page and try again.');
            }
            return XLSX;
        }

        function csvEscapeValue(value) {
            if (value === null || value === undefined) {
                return '';
            }
            const text = String(value);
            if (/["\n,]/.test(text)) {
                return `"${text.replace(/"/g, '""')}"`;
            }
            return text;
        }

        function arrayToCsvLine(values) {
            return values.map(csvEscapeValue).join(',');
        }

        function normalizeXlsxHeader(cell) {
            if (cell === null || cell === undefined) {
                return '';
            }
            return String(cell).trim();
        }

        function detectLineHeaderRow(row) {
            if (!Array.isArray(row)) {
                return null;
            }
            const mapping = new Map();
            row.forEach((cell, index) => {
                const text = normalizeXlsxHeader(cell);
                if (!text) {
                    return;
                }
                const token = normalizeLineLabelKey(text);
                if (!token) {
                    return;
                }
                const mappedLine = LINE_TOKEN_TO_INDEX.get(token);
                if (Number.isInteger(mappedLine)) {
                    mapping.set(index, mappedLine);
                }
            });
            return mapping.size >= 2 ? mapping : null;
        }

        function extractYearValue(cell) {
            if (cell === null || cell === undefined) {
                return null;
            }
            if (typeof cell === 'number' && Number.isFinite(cell)) {
                const intValue = Math.round(cell);
                if (intValue >= 7 && intValue <= 12) {
                    return intValue;
                }
            }
            const text = normalizeXlsxHeader(cell);
            if (!text) {
                return null;
            }
            const match = text.match(/(\d{1,2})/);
            if (!match) {
                return null;
            }
            const value = parseInt(match[1], 10);
            return value >= 7 && value <= 12 ? value : null;
        }

        function extractCodesFromCell(cell) {
            if (cell === null || cell === undefined) {
                return [];
            }
            let text;
            if (typeof cell === 'number' && Number.isFinite(cell)) {
                text = cell.toString();
            } else {
                text = String(cell).replace(/\s+/g, ' ').trim();
            }
            if (!text || /^(line|row|year|semester)/i.test(text)) {
                return [];
            }
            return text.split(/\s*\n\s*/).map(part => part.trim()).filter(Boolean);
        }

        function collectLineValuesForRow(row, columnMap) {
            const totalLines = EXTENDED_LINE_LABELS.length;
            const perLine = Array.from({ length: totalLines }, () => []);
            if (!row || !columnMap) {
                return perLine.map(entries => entries.join(' / '));
            }
            columnMap.forEach((lineNumber, columnIndex) => {
                if (!Number.isInteger(lineNumber) || lineNumber < 1 || lineNumber > totalLines) {
                    return;
                }
                const cell = columnIndex < row.length ? row[columnIndex] : '';
                const codes = extractCodesFromCell(cell);
                const target = perLine[lineNumber - 1];
                codes.forEach(code => {
                    if (!target.includes(code)) {
                        target.push(code);
                    }
                });
            });
            return perLine.map(entries => entries.join(' / '));
        }

        function buildAllocationCsvFromRows(rows) {
            const header = ['Year', 'Row', ...EXTENDED_LINE_LABELS.map((_, idx) => `Line${idx + 1}`)];
            const dataRows = [];
            const years = new Set();
            const warnings = new Set();
            let columnMap = null;
            let currentYear = null;
            let rowCounter = 0;

            rows.forEach(row => {
                const headerMap = detectLineHeaderRow(row);
                if (headerMap) {
                    columnMap = headerMap;
                    return;
                }
                const yearValue = extractYearValue(Array.isArray(row) ? row[0] : null);
                if (yearValue !== null) {
                    currentYear = yearValue;
                    rowCounter = 0;
                    years.add(yearValue);
                    return;
                }
                if (!currentYear || !columnMap) {
                    return;
                }
                const lineValues = collectLineValuesForRow(row, columnMap);
                const hasData = lineValues.some(value => value && value.trim() !== '');
                if (!hasData) {
                    return;
                }
                if (rowCounter >= MAX_ROWS_PER_YEAR) {
                    warnings.add(`Extra rows ignored for Year ${currentYear}.`);
                    return;
                }
                rowCounter += 1;
                dataRows.push([currentYear, rowCounter, ...lineValues]);
            });

            if (dataRows.length === 0) {
                return { csv: null, stats: { years: [], rows: 0 }, warnings: Array.from(warnings) };
            }

            const csvLines = [header, ...dataRows];
            return {
                csv: csvLines.map(arrayToCsvLine).join('\n'),
                stats: {
                    years: Array.from(years).sort((a, b) => a - b),
                    rows: dataRows.length
                },
                warnings: Array.from(warnings)
            };
        }

        function detectTeacherHeaderRow(row) {
            if (!Array.isArray(row)) {
                return null;
            }
            const headers = ['Teacher', 'FTE', 'PeriodAllowance', 'AssemblyFullCount', 'AssemblyShortCount', 'AdditionalMinutes'];
            const normalized = row.map(cell => normalizeXlsxHeader(cell).toLowerCase());
            const indices = headers.map(header => normalized.findIndex(value => value === header.toLowerCase()));
            return indices.every(index => index !== -1) ? indices : null;
        }

        function getCellText(row, index) {
            if (!Array.isArray(row) || index < 0 || index >= row.length) {
                return '';
            }
            const value = row[index];
            if (value === null || value === undefined) {
                return '';
            }
            if (typeof value === 'number' && Number.isFinite(value)) {
                return Number.isInteger(value) ? String(value) : String(value);
            }
            return String(value).trim();
        }

        function buildTeacherCsvFromRows(rows) {
            const header = ['Teacher', 'FTE', 'PeriodAllowance', 'AssemblyFullCount', 'AssemblyShortCount', 'AdditionalMinutes'];
            for (let i = 0; i < rows.length; i++) {
                const indices = detectTeacherHeaderRow(rows[i]);
                if (!indices) {
                    continue;
                }
                const teacherRows = [];
                for (let r = i + 1; r < rows.length; r++) {
                    const teacherName = getCellText(rows[r], indices[0]);
                    if (!teacherName) {
                        break;
                    }
                    const entry = indices.map(index => getCellText(rows[r], index));
                    teacherRows.push(entry);
                }
                if (teacherRows.length === 0) {
                    return null;
                }
                const csvLines = [header, ...teacherRows];
                return {
                    csv: csvLines.map(arrayToCsvLine).join('\n'),
                    stats: { teacherCount: teacherRows.length }
                };
            }
            return null;
        }

        function getMatrixSheetRows(workbook) {
            const XLSXLib = ensureXlsxAvailable();
            if (!workbook || !Array.isArray(workbook.SheetNames)) {
                return { rows: null, sheetName: null };
            }
            for (const name of workbook.SheetNames) {
                const sheet = workbook.Sheets[name];
                if (!sheet) {
                    continue;
                }
                const rows = XLSXLib.utils.sheet_to_json(sheet, { header: 1, raw: true, defval: '' });
                if (rows.some(row => detectLineHeaderRow(row))) {
                    return { rows, sheetName: name };
                }
            }
            const fallbackName = workbook.SheetNames[0];
            if (fallbackName) {
                const sheet = workbook.Sheets[fallbackName];
                if (sheet) {
                    const rows = XLSXLib.utils.sheet_to_json(sheet, { header: 1, raw: true, defval: '' });
                    return { rows, sheetName: fallbackName };
                }
            }
            return { rows: null, sheetName: null };
        }

        function convertWorkbookArrayBuffer(buffer) {
            const XLSXLib = ensureXlsxAvailable();
            const workbook = XLSXLib.read(buffer, { type: 'array' });
            const { rows, sheetName } = getMatrixSheetRows(workbook);
            if (!rows || rows.length === 0) {
                throw new Error('Could not find any timetable data in that workbook.');
            }
            const allocation = buildAllocationCsvFromRows(rows);
            if (!allocation.csv) {
                throw new Error('No allocation data detected in that workbook.');
            }
            const teacher = buildTeacherCsvFromRows(rows);
            return {
                sheetName,
                allocationCsv: allocation.csv,
                allocationWarnings: allocation.warnings,
                teacherCsv: teacher ? teacher.csv : null,
                teacherStats: teacher ? teacher.stats : null
            };
        }

        // ---------- CSV -> lineCells patch ----------
        function csvToLineCellsPatch(csvText, { normalizeCodes = true } = {}) {
            const rows = parseCsv(csvText);
            if (rows.length === 0) {
                throw new Error('Empty CSV');
            }
            const headers = rows[0].map(header => String(header ?? '').trim());
            const canonicalHeaders = headers.map(normalizeHeaderName);
            const headerIndex = new Map();
            headers.forEach((header, index) => {
                const trimmed = header;
                if (trimmed && !headerIndex.has(trimmed)) {
                    headerIndex.set(trimmed, index);
                }
                const canonical = canonicalHeaders[index];
                if (canonical && !headerIndex.has(canonical)) {
                    headerIndex.set(canonical, index);
                }
            });
            const getIndex = name => {
                const direct = headerIndex.get(name);
                if (direct !== undefined) {
                    return direct;
                }
                const canonical = normalizeHeaderName(name);
                return headerIndex.has(canonical) ? headerIndex.get(canonical) : -1;
            };
            const shouldNormalize = normalizeCodes !== false;

            const cellsByYear = new Map();
            const addCell = (year, cell) => {
                if (!cellsByYear.has(year)) {
                    cellsByYear.set(year, []);
                }
                cellsByYear.get(year).push(cell);
            };
            const yearsEncountered = new Set();
            const lastRowByYear = new Map();
            let lastExplicitYear = null;
            const maxLineNumber = getMaxLineNumber();

            if (looksLong(headers)) {
                const yearIdx = getIndex('Year');
                const rowIdx = getIndex('Row');
                const lineIdx = getIndex('Line');
                const codesIdx = getIndex('Codes');
                if (yearIdx === -1 || rowIdx === -1 || lineIdx === -1 || codesIdx === -1) {
                    throw new Error('Missing Year/Row/Line/Codes columns');
                }
                for (let r = 1; r < rows.length; r++) {
                    const row = rows[r];
                    if (!row || row.every(cell => String(cell ?? '').trim() === '')) {
                        continue;
                    }
                    const rawYear = yearIdx !== -1 ? row[yearIdx] : '';
                    const rawRow = rowIdx !== -1 ? row[rowIdx] : '';
                    const rawLine = lineIdx !== -1 ? row[lineIdx] : '';
                    const rawCodesCell = codesIdx !== -1 ? row[codesIdx] : '';
                    const codesText = rawCodesCell == null ? '' : String(rawCodesCell).trim();
                    const yearText = rawYear == null ? '' : String(rawYear).trim();
                    const rowText = rawRow == null ? '' : String(rawRow).trim();
                    const lineText = rawLine == null ? '' : String(rawLine).trim();
                    if (yearText === '' && rowText === '' && lineText === '' && codesText === '') {
                        continue;
                    }
                    const rawCodes = codesText === '' ? [] : codesText.split(';');
                    const candidateCodes = rawCodes
                        .map(code => String(code ?? '').trim())
                        .filter(code => code !== '');
                    const inferredYear = inferYearFromCodes(candidateCodes);
                    let year;
                    if (yearText === '') {
                        if (Number.isInteger(inferredYear)) {
                            year = inferredYear;
                            lastExplicitYear = year;
                        } else if (Number.isInteger(lastExplicitYear)) {
                            year = lastExplicitYear;
                        } else {
                            if (candidateCodes.length === 0) {
                                continue;
                            }
                            throw new Error(`Bad Year @ row ${r + 1}`);
                        }
                    } else {
                        year = extractFirstInteger(yearText);
                        if (!Number.isInteger(year) || !(year >= 7 && year <= 12)) {
                            throw new Error(`Bad Year @ row ${r + 1}`);
                        }
                        lastExplicitYear = year;
                    }
                    let rowIndex = extractFirstInteger(rowText);
                    const line = extractFirstInteger(lineText);
                    if (!Number.isInteger(line) || !(line >= 1 && line <= maxLineNumber)) {
                        throw new Error(`Bad Line @ row ${r + 1}`);
                    }
                    if (!Number.isInteger(rowIndex)) {
                        if (codesText === '') {
                            continue;
                        }
                        rowIndex = (lastRowByYear.get(year) ?? 0) + 1;
                    }
                    if (!(rowIndex >= 1 && rowIndex <= 6)) {
                        throw new Error(`Bad Row @ row ${r + 1}`);
                    }
                    lastRowByYear.set(year, rowIndex);
                    yearsEncountered.add(year);
                    const codes = rawCodes
                        .map(c => (shouldNormalize ? normalizeSubjectCode(c) : String(c).trim()))
                        .filter(Boolean);
                    addCell(year, { line, row: rowIndex, codes });
                }
            } else if (looksWide(headers)) {
                const lineCols = [];
                for (let l = 1; l <= maxLineNumber; l++) {
                    let columnIndex = getIndex('Line' + l);
                    if (columnIndex === -1) {
                        const fallbackLabel = getDefaultLineLabel(l - 1);
                        columnIndex = getIndex(fallbackLabel);
                    }
                    if (columnIndex !== -1) {
                        lineCols.push({ line: l, i: columnIndex });
                    }
                }
                const yearIdx = getIndex('Year');
                const rowIdx = getIndex('Row');
                if (yearIdx === -1 || rowIdx === -1) {
                    throw new Error('Missing Year/Row columns');
                }
                for (let r = 1; r < rows.length; r++) {
                    const row = rows[r];
                    if (!row || row.every(cell => String(cell ?? '').trim() === '')) {
                        continue;
                    }
                    const rawYear = row[yearIdx];
                    const rawRow = row[rowIdx];
                    const yearText = rawYear == null ? '' : String(rawYear).trim();
                    const rowText = rawRow == null ? '' : String(rawRow).trim();
                    const rowCodes = [];
                    lineCols.forEach(col => {
                        const value = row[col.i];
                        if (value === undefined || value === null) {
                            return;
                        }
                        const textValue = String(value);
                        if (textValue.trim() === '') {
                            return;
                        }
                        const parts = textValue.split(/\n/);
                        parts.forEach(part => {
                            const trimmed = String(part ?? '').trim();
                            if (trimmed !== '') {
                                rowCodes.push(trimmed);
                            }
                        });
                    });
                    const hasCodes = rowCodes.length > 0;
                    if (yearText === '' && rowText === '' && !hasCodes) {
                        continue;
                    }
                    const inferredYear = hasCodes ? inferYearFromCodes(rowCodes) : null;
                    let year;
                    if (yearText === '') {
                        if (Number.isInteger(inferredYear)) {
                            year = inferredYear;
                            lastExplicitYear = year;
                        } else if (Number.isInteger(lastExplicitYear)) {
                            year = lastExplicitYear;
                        } else {
                            if (!hasCodes) {
                                continue;
                            }
                            throw new Error(`Bad Year @ row ${r + 1}`);
                        }
                    } else {
                        year = extractFirstInteger(yearText);
                        if (!Number.isInteger(year) || !(year >= 7 && year <= 12)) {
                            throw new Error(`Bad Year @ row ${r + 1}`);
                        }
                        lastExplicitYear = year;
                    }
                    let rowIndex = extractFirstInteger(rowText);
                    if (!Number.isInteger(rowIndex)) {
                        if (!hasCodes) {
                            continue;
                        }
                        rowIndex = (lastRowByYear.get(year) ?? 0) + 1;
                    }
                    if (!(rowIndex >= 1 && rowIndex <= 6)) {
                        throw new Error(`Bad Row @ row ${r + 1}`);
                    }
                    lastRowByYear.set(year, rowIndex);
                    yearsEncountered.add(year);
                    for (const col of lineCols) {
                        const raw = row[col.i] ?? '';
                        const text = String(raw);
                        const rawCodes = text === '' ? [] : text.split(/\n/);
                        const codes = rawCodes
                            .map(c => (shouldNormalize ? normalizeSubjectCode(c) : String(c).trim()))
                            .filter(Boolean);
                        addCell(year, { line: col.line, row: rowIndex, codes });
                    }
                }
            } else {
                throw new Error(`CSV shape not recognised. Expected: (Year,Row,Line,Codes) OR (Year,Row,Line1..Line${maxLineNumber})`);
            }

            const uniqueYears = Array.from(yearsEncountered).sort((a, b) => a - b);
            const buildOptions = () => ({
                normalizeCodes: shouldNormalize,
                inheritLineForSplits: true,
                touchAllocations: false
            });

            if (uniqueYears.length <= 1) {
                const year = uniqueYears[0] ?? 7;
                const cells = cellsByYear.get(year) ?? [];
                return {
                    patchType: 'lineCells',
                    year,
                    cells,
                    options: buildOptions()
                };
            }

            const patches = uniqueYears.map(year => ({
                patchType: 'lineCells',
                year,
                cells: cellsByYear.get(year) ?? [],
                options: buildOptions()
            }));

            return {
                patchType: 'lineCellsMulti',
                years: uniqueYears,
                patches,
                options: buildOptions()
            };
        }

        function flattenLineCellsPatch(patch) {
            if (!patch || typeof patch !== 'object') {
                return [];
            }
            if (patch.patchType === 'lineCellsMulti') {
                const out = [];
                const nested = Array.isArray(patch.patches) ? patch.patches : [];
                nested.forEach(subPatch => {
                    if (!subPatch || typeof subPatch !== 'object') {
                        return;
                    }
                    const year = subPatch.year;
                    const cells = Array.isArray(subPatch.cells) ? subPatch.cells : [];
                    cells.forEach(cell => {
                        out.push({
                            year,
                            row: cell?.row,
                            line: cell?.line,
                            codes: Array.isArray(cell?.codes) ? cell.codes.slice() : []
                        });
                    });
                });
                return out;
            }
            const cells = Array.isArray(patch.cells) ? patch.cells : [];
            return cells.map(cell => ({
                row: cell?.row,
                line: cell?.line,
                codes: Array.isArray(cell?.codes) ? cell.codes.slice() : []
            }));
        }

        function collectLineCellsPatchYears(patch) {
            const yearsSet = new Set();
            const walk = target => {
                if (!target || typeof target !== 'object') {
                    return;
                }
                if (target.patchType === 'lineCellsMulti') {
                    if (Array.isArray(target.years)) {
                        target.years.forEach(year => {
                            if (Number.isInteger(year)) {
                                yearsSet.add(year);
                            }
                        });
                    }
                    if (Array.isArray(target.patches)) {
                        target.patches.forEach(walk);
                    }
                    return;
                }
                if (target.patchType === 'lineCells' && Number.isInteger(target.year)) {
                    yearsSet.add(target.year);
                }
            };
            walk(patch);
            return Array.from(yearsSet).sort((a, b) => a - b);
        }

        function summarizeLineCellsPatch(patch) {
            const cells = flattenLineCellsPatch(patch);
            const codeCount = cells.reduce((acc, cell) => acc + (Array.isArray(cell.codes) ? cell.codes.length : 0), 0);
            const years = collectLineCellsPatchYears(patch);
            const patchCount = patch && patch.patchType === 'lineCellsMulti' && Array.isArray(patch.patches)
                ? patch.patches.length
                : (patch && patch.patchType === 'lineCells' ? 1 : 0);
            return { years, cells, cellCount: cells.length, codeCount, patchCount };
        }

        function formatLineCellsYears(years) {
            if (!Array.isArray(years) || years.length === 0) {
                return 'Year ';
            }
            if (years.length === 1) {
                return `Year ${years[0]}`;
            }
            return `Years ${years.join(', ')}`;
        }

        function summarizeSubjectsByYear(patch) {
            const yearToCodes = new Map();

            const ensureSet = yearLabel => {
                if (!yearToCodes.has(yearLabel)) {
                    yearToCodes.set(yearLabel, new Set());
                }
                return yearToCodes.get(yearLabel);
            };

            const visit = target => {
                if (!target || typeof target !== 'object') {
                    return;
                }
                if (target.patchType === 'lineCellsMulti') {
                    const nested = Array.isArray(target.patches) ? target.patches : [];
                    nested.forEach(visit);
                    return;
                }
                if (target.patchType === 'lineCells') {
                    const yearLabel = normalizeYearLabel(target.year) || 'Year ';
                    const codes = ensureSet(yearLabel);
                    const cells = Array.isArray(target.cells) ? target.cells : [];
                    cells.forEach(cell => {
                        if (!cell || !Array.isArray(cell.codes)) {
                            return;
                        }
                        cell.codes.forEach(code => {
                            const key = subjectComparisonKey(code);
                            if (key) {
                                codes.add(key);
                            }
                        });
                    });
                }
            };

            visit(patch);

            return Array.from(yearToCodes.entries())
                .map(([yearLabel, codes]) => {
                    const match = yearLabel && yearLabel.match(/(\d+)/);
                    const order = match ? parseInt(match[1], 10) : Number.POSITIVE_INFINITY;
                    return { yearLabel, count: codes.size, order };
                })
                .sort((a, b) => {
                    if (a.order !== b.order) {
                        return a.order - b.order;
                    }
                    return a.yearLabel.localeCompare(b.yearLabel);
                })
                .map(({ yearLabel, count }) => ({ yearLabel, count }));
        }

        function formatSubjectUploadSummaryLines(subjectSummaries) {
            if (!Array.isArray(subjectSummaries) || subjectSummaries.length === 0) {
                return ['No subjects detected in upload.'];
            }
            return subjectSummaries.map(({ yearLabel, count }) => {
                const baseLabel = typeof yearLabel === 'string' && yearLabel ? yearLabel : 'Subjects';
                const prefix = baseLabel.replace(/^Year\b/i, 'Yr');
                return `${prefix} subjects upload = ${count}`;
            });
        }

        // ---------- JSON validator ----------
        function assertLineCellsPatch(obj) {
            if (!obj || typeof obj !== 'object') {
                throw new Error('Patch must be an object');
            }
            const maxLineNumber = getMaxLineNumber();
            if (obj.patchType === 'lineCellsMulti') {
                if (!Array.isArray(obj.patches) || obj.patches.length === 0) {
                    throw new Error('lineCellsMulti patch must include at least one patch');
                }
                if (obj.options && obj.options.touchAllocations) {
                    throw new Error('touchAllocations is not allowed for lineCells patch');
                }
                obj.options = Object.assign({ touchAllocations: false }, obj.options || {});
                obj.patches = obj.patches.map(assertLineCellsPatch);
                obj.years = collectLineCellsPatchYears(obj);
                return obj;
            }
            if (obj.patchType !== 'lineCells') {
                throw new Error("patchType must be 'lineCells'");
            }
            if (![7, 8, 9, 10, 11, 12].includes(obj.year)) {
                throw new Error('year must be 7..12');
            }
            if (!Array.isArray(obj.cells)) {
                throw new Error('cells must be an array');
            }
            obj.cells.forEach((c, i) => {
                if (!(Number.isInteger(c.line) && c.line >= 1 && c.line <= maxLineNumber)) {
                    throw new Error(`cells[${i}].line must be 1..${maxLineNumber}`);
                }
                if (!(Number.isInteger(c.row) && c.row >= 1 && c.row <= 6)) {
                    throw new Error(`cells[${i}].row must be 1..6`);
                }
                if (!Array.isArray(c.codes)) {
                    throw new Error(`cells[${i}].codes must be string[]`);
                }
            });
            if (obj.options && obj.options.touchAllocations) {
                throw new Error('touchAllocations is not allowed for lineCells patch');
            }
            if (obj.options?.normalizeCodes !== false) {
                obj.cells.forEach(c => {
                    c.codes = c.codes.map(normalizeSubjectCode);
                });
            }
            return obj;
        }

        // ---------- Apply patch to state (allocations untouched) ----------
        function applyLineCellsPatch(state, patch) {
            if (patch.patchType !== 'lineCells') {
                throw new Error('Wrong patchType');
            }
            if (patch.options?.touchAllocations) {
                throw new Error('Not allowed in lineCells patch');
            }
            if (!Array.isArray(state.subjects) || typeof state.subjectYearMapping !== 'object' || typeof state.subjectLineMapping !== 'object') {
                throw new Error('Invalid state for lineCells patch');
            }

            const patchYearLabel = normalizeYearLabel(patch.year);
            if (!patchYearLabel) {
                throw new Error('Invalid year in lineCells patch');
            }

            const changes = [];
            let linesExtended = false;
            const seenThisYear = new Set();
            const stateLines = Array.isArray(state.lines) ? state.lines : lines;
            const shouldUpdateDurations = stateLines === lines;

            const toLineIndex = lineNumber => {
                const numericLine = Number(lineNumber);
                if (!Number.isInteger(numericLine)) {
                    return null;
                }
                return numericLine - 1;
            };

            const findExistingSubject = code => {
                const targetKey = subjectComparisonKey(code);
                if (!targetKey) {
                    return null;
                }
                for (const existing of state.subjects) {
                    if (subjectComparisonKey(existing) === targetKey) {
                        return existing;
                    }
                }
                return null;
            };

            const addChange = change => {
                changes.push(change);
            };

            function upsert(rawCode, rawLine) {
                const normalizedCode = normalizeSubjectCode(rawCode);
                if (!normalizedCode) {
                    return;
                }
                const lineIndex = toLineIndex(rawLine);
                if (lineIndex === null || lineIndex < 0) {
                    throw new Error('Invalid line in lineCells patch');
                }
                if (expandLinesToInclude(lineIndex, stateLines, { updateDurations: shouldUpdateDurations })) {
                    linesExtended = true;
                }

                const existingCode = findExistingSubject(normalizedCode);
                const codeKey = existingCode || normalizedCode;
                const canonicalCode = normalizedCode;

                if (!existingCode) {
                    state.subjects.push(canonicalCode);
                    addChange({ kind: 'addSubject', code: canonicalCode, year: patchYearLabel, line: lineIndex });
                }

                const previousCanonicalYear = state.subjectYearMapping[canonicalCode];
                if (previousCanonicalYear !== patchYearLabel) {
                    state.subjectYearMapping[canonicalCode] = patchYearLabel;
                    addChange({ kind: 'setYear', code: canonicalCode, from: previousCanonicalYear, to: patchYearLabel });
                }
                if (codeKey !== canonicalCode && state.subjectYearMapping[codeKey] !== patchYearLabel) {
                    state.subjectYearMapping[codeKey] = patchYearLabel;
                }

                const previousCanonicalLine = state.subjectLineMapping[canonicalCode];
                if (previousCanonicalLine !== lineIndex) {
                    state.subjectLineMapping[canonicalCode] = lineIndex;
                    addChange({ kind: 'updateMapping', code: canonicalCode, from: previousCanonicalLine, to: lineIndex });
                }
                if (codeKey !== canonicalCode && state.subjectLineMapping[codeKey] !== lineIndex) {
                    state.subjectLineMapping[codeKey] = lineIndex;
                }

                seenThisYear.add(canonicalCode);
                if (codeKey !== canonicalCode) {
                    seenThisYear.add(codeKey);
                }

                if (patch.options?.inheritLineForSplits && state.subjectSplits && typeof state.subjectSplits === 'object') {
                    Object.entries(state.subjectSplits).forEach(([base, splits]) => {
                        if (!Array.isArray(splits)) {
                            return;
                        }
                        const matches = splits.some(split => {
                            const splitCode = typeof split === 'string' ? split : split && split.code;
                            if (!splitCode) {
                                return false;
                            }
                            return subjectComparisonKey(splitCode) === subjectComparisonKey(codeKey);
                        });
                        if (!matches) {
                            return;
                        }
                        const baseCode = findExistingSubject(base) || normalizeSubjectCode(base);
                        if (!baseCode) {
                            return;
                        }
                        const previous = state.subjectLineMapping[baseCode];
                        if (previous !== lineIndex) {
                            state.subjectLineMapping[baseCode] = lineIndex;
                            addChange({ kind: 'updateMapping', code: baseCode, from: previous, to: lineIndex });
                        }
                        seenThisYear.add(baseCode);
                    });
                }
            }

            for (const cell of patch.cells) {
                if (!cell || !Array.isArray(cell.codes)) {
                    continue;
                }
                for (const code of cell.codes) {
                    upsert(code, cell.line);
                }
            }

            if (patch.options?.removeMissingInThisYear) {
                state.subjects.forEach(code => {
                    if (state.subjectYearMapping[code] === patchYearLabel && !seenThisYear.has(code)) {
                        delete state.subjectLineMapping[code];
                    }
                });
            }

            return { changes, allocationsTouched: 0, linesExtended };
        }

        function applyLineCellsPatchBundle(state, patch) {
            if (!patch || typeof patch !== 'object') {
                return { changes: [], allocationsTouched: 0 };
            }
            if (patch.patchType === 'lineCellsMulti') {
                const combinedChanges = [];
                let totalAllocations = 0;
                let linesExtended = false;
                const nested = Array.isArray(patch.patches) ? patch.patches : [];
                nested.forEach(subPatch => {
                    const result = applyLineCellsPatchBundle(state, subPatch);
                    if (Array.isArray(result.changes)) {
                        combinedChanges.push(...result.changes);
                    }
                    if (typeof result.allocationsTouched === 'number') {
                        totalAllocations += result.allocationsTouched;
                    }
                    if (result.linesExtended) {
                        linesExtended = true;
                    }
                });
                return { changes: combinedChanges, allocationsTouched: totalAllocations, linesExtended };
            }
            return applyLineCellsPatch(state, patch);
        }

        async function handleAdditionalInfoImport(file, appState) {
            const text = await file.text();
            const name = file.name.toLowerCase();

            const cloneState = () => {
                let clone;
                if (typeof structuredClone === 'function') {
                    clone = structuredClone(appState);
                } else {
                    clone = JSON.parse(JSON.stringify(appState));
                }
                clone.lines = Array.isArray(appState.lines) ? [...appState.lines] : [...lines];
                return clone;
            };

            if (name.endsWith('.csv')) {
                const patch = csvToLineCellsPatch(text, { normalizeCodes: true });
                const subjectSummaryLines = formatSubjectUploadSummaryLines(summarizeSubjectsByYear(patch));
                applyLineCellsPatchBundle(cloneState(), patch);
                const ok = await showAppConfirm([
                    'Line Cells Patch detected (CSV).',
                    ...subjectSummaryLines,
                    '',
                    'Apply now?'
                ].join('\n'), {
                    confirmLabel: 'Apply patch',
                    cancelLabel: 'Cancel'
                });
                if (!ok) {
                    return;
                }
                const result = applyLineCellsPatchBundle(appState, patch);
                if (result.linesExtended) {
                    initializeTimetable();
                }
                if (result.changes.length > 0) {
                    createSubjectPool();
                    renderAllAllocations();
                    updateStats();
                    clearActionHistory();
                } else {
                    updateStats();
                }
                const appliedLines = ['Applied.', ...subjectSummaryLines];
                if (typeof result.allocationsTouched === 'number') {
                    appliedLines.push(`Allocations touched: ${result.allocationsTouched}`);
                }
                alert(appliedLines.join('\n'));
                return;
            }

            if (name.endsWith('.json')) {
                try {
                    const parsed = JSON.parse(text);
                    if (parsed && (parsed.patchType === 'lineCells' || parsed.patchType === 'lineCellsMulti')) {
                        const patch = assertLineCellsPatch(parsed);
                        const subjectSummaryLines = formatSubjectUploadSummaryLines(summarizeSubjectsByYear(patch));
                        applyLineCellsPatchBundle(cloneState(), patch);
                const ok = await showAppConfirm([
                    'Line Cells Patch detected (JSON).',
                    ...subjectSummaryLines,
                    '',
                    'Apply now?'
                ].join('\n'), {
                    confirmLabel: 'Apply patch',
                    cancelLabel: 'Cancel'
                });
                if (!ok) {
                            return;
                        }
                        const result = applyLineCellsPatchBundle(appState, patch);
                        if (result.linesExtended) {
                            initializeTimetable();
                        }
                        if (result.changes.length > 0) {
                            createSubjectPool();
                            renderAllAllocations();
                            updateStats();
                            clearActionHistory();
                        } else {
                            updateStats();
                        }
                        const appliedLines = ['Applied.', ...subjectSummaryLines];
                        if (typeof result.allocationsTouched === 'number') {
                            appliedLines.push(`Allocations touched: ${result.allocationsTouched}`);
                        }
                        alert(appliedLines.join('\n'));
                        return;
                    }
                } catch (e) {
                    // fall through to legacy path if not valid JSON
                }
            }

            try {
                const supp = JSON.parse(text);
                if (supp && (supp.subjects || supp.subjectLineMapping || supp.subjectYearMapping)) {
                    mergeSupplementalData(supp);
                    return;
                }
            } catch (e) {
                // not JSON
            }

            alert('No new supplemental data detected.');
        }

        function importSupplementalData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json,.csv';

            input.onchange = async function(event) {
                const selectedFile = event.target.files && event.target.files[0];
                if (!selectedFile) {
                    return;
                }

                const appState = {
                    subjects,
                    subjectYearMapping,
                    subjectLineMapping,
                    subjectSplits,
                    allocations,
                    lines
                };

                try {
                    await handleAdditionalInfoImport(selectedFile, appState);
                } catch (error) {
                    alert('Error importing supplemental data: ' + error.message);
                    console.error('Supplemental import error:', error);
                } finally {
                    event.target.value = '';
                }
            };

            input.click();
        }

        function mergeSupplementalData(data) {
            if (!data || typeof data !== 'object') {
                alert('Unsupported supplemental data format.');
                return;
            }

            let teachersAdded = 0;
            let linesAdded = 0;
            let subjectsAdded = 0;
            let mappingUpdated = 0;
            let splitsUpdated = 0;
            let loadUpdated = 0;
            const updatedMappingSubjects = new Set();

            if (Array.isArray(data.lines)) {
                data.lines.forEach(lineLabel => {
                    if (addLine(lineLabel, { skipRefresh: true, silent: true })) {
                        linesAdded++;
                    }
                });
            }

            if (Array.isArray(data.teachers)) {
                data.teachers.forEach(teacherName => {
                    if (addTeacher(teacherName, { skipRefresh: true, silent: true })) {
                        teachersAdded++;
                    }
                });
            }

            const mappingSource = data.subjectLineMapping && typeof data.subjectLineMapping === 'object'
                ? data.subjectLineMapping
                : {};

            if (Array.isArray(data.subjects)) {
                data.subjects.forEach(subjectCode => {
                    const normalized = normalizeSubjectCode(subjectCode);
                    if (!normalized) {
                        return;
                    }

                    let mappedLine = null;
                    if (mappingSource[subjectCode] !== undefined) {
                        mappedLine = resolveLineReference(mappingSource[subjectCode]);
                    } else if (mappingSource[normalized] !== undefined) {
                        mappedLine = resolveLineReference(mappingSource[normalized]);
                    }

                    const added = addSubjectCode(normalized, {
                        lineIndex: mappedLine,
                        skipRefresh: true,
                        silent: true
                    });

                    if (added) {
                        subjectsAdded++;
                    } else if (Number.isInteger(mappedLine) && mappedLine >= 0) {
                        if (subjectLineMapping[normalized] !== mappedLine) {
                            subjectLineMapping[normalized] = mappedLine;
                            if (!updatedMappingSubjects.has(normalized)) {
                                mappingUpdated++;
                                updatedMappingSubjects.add(normalized);
                            }
                        }
                    }
                });
            }

            Object.entries(mappingSource).forEach(([subjectCode, reference]) => {
                const normalized = normalizeSubjectCode(subjectCode);
                if (!normalized) {
                    return;
                }

                const resolvedLine = resolveLineReference(reference);
                if (resolvedLine === null) {
                    return;
                }

                if (subjectLineMapping[normalized] !== resolvedLine) {
                    subjectLineMapping[normalized] = resolvedLine;
                    if (!updatedMappingSubjects.has(normalized)) {
                        mappingUpdated++;
                        updatedMappingSubjects.add(normalized);
                    }
                }
            });

            if (data.subjectSplits && typeof data.subjectSplits === 'object') {
                Object.entries(data.subjectSplits).forEach(([baseSubject, splits]) => {
                    if (!Array.isArray(splits)) {
                        return;
                    }

                    const normalizedBase = normalizeSubjectCode(baseSubject);
                    const sanitizedSplits = splits
                        .map((split, index) => {
                            if (!split || typeof split !== 'object') {
                                return null;
                            }
                            const code = typeof split.code === 'string' ? split.code.trim() : '';
                            if (!code) {
                                return null;
                            }
                            const periodsValue = Number(split.periods);
                            const periods = Number.isFinite(periodsValue) ? periodsValue : parseInt(split.periods, 10);
                            const numericPeriods = Number.isFinite(periods) ? periods : 0;

                            return {
                                code: code,
                                periods: numericPeriods,
                                index: Number.isInteger(split.index) ? split.index : index,
                                totalSplits: Number.isInteger(split.totalSplits) ? split.totalSplits : splits.length
                            };
                        })
                        .filter(split => split && split.code);

                    if (sanitizedSplits.length > 0) {
                        subjectSplits[normalizedBase] = sanitizedSplits.map((split, index) => ({
                            code: split.code,
                            periods: split.periods,
                            index: index,
                            totalSplits: sanitizedSplits.length
                        }));
                        splitsUpdated++;
                    } else {
                        delete subjectSplits[normalizedBase];
                    }
                });

                rebuildSplitLookup();

                if (Object.keys(subjectSplits).length > 0) {
                    const baseSubjects = new Set(Object.keys(subjectSplits));
                    const existingSubjects = new Set(subjects);

                    subjects = subjects.filter(subject => !baseSubjects.has(subject));

                    Object.entries(subjectSplits).forEach(([baseSubject, splits]) => {
                        const baseLine = subjectLineMapping[baseSubject];
                        splits.forEach(split => {
                            if (!existingSubjects.has(split.code)) {
                                subjects.push(split.code);
                                existingSubjects.add(split.code);
                            }

                            if (baseLine !== undefined && subjectLineMapping[split.code] === undefined) {
                                subjectLineMapping[split.code] = baseLine;
                            }
                        });
                    });
                }
            }

            if (data.teacherLoadSettings && typeof data.teacherLoadSettings === 'object') {
                Object.entries(data.teacherLoadSettings).forEach(([teacherName, settings]) => {
                    if (!teacherName || typeof settings !== 'object') {
                        return;
                    }

                    if (!teachers.includes(teacherName)) {
                        if (addTeacher(teacherName, { skipRefresh: true, silent: true })) {
                            teachersAdded++;
                        }
                    }

                    const existingSettings = getTeacherLoadSettings(teacherName);
                    teacherLoadSettings[teacherName] = {
                        ...existingSettings,
                        ...settings
                    };
                    getTeacherLoadSettings(teacherName);
                    loadUpdated++;
                });
            }

            const structureChanged = teachersAdded > 0 || linesAdded > 0;
            const subjectDataChanged = subjectsAdded > 0 || mappingUpdated > 0 || splitsUpdated > 0;

            if (structureChanged) {
                initializeTimetable();
            } else if (subjectDataChanged) {
                renderAllAllocations();
                updateStats();
            }

            createSubjectPool();
            updateStats();

            if (structureChanged || subjectDataChanged) {
                clearActionHistory();
            }

            const summaryParts = [];

            if (teachersAdded > 0) {
                summaryParts.push(`${teachersAdded} teacher${teachersAdded === 1 ? '' : 's'} added`);
            }

            if (linesAdded > 0) {
                summaryParts.push(`${linesAdded} line${linesAdded === 1 ? '' : 's'} added`);
            }

            if (subjectsAdded > 0) {
                summaryParts.push(`${subjectsAdded} subject${subjectsAdded === 1 ? '' : 's'} added`);
            }

            if (mappingUpdated > 0) {
                summaryParts.push(`line mapping updated for ${mappingUpdated} subject${mappingUpdated === 1 ? '' : 's'}`);
            }

            if (splitsUpdated > 0) {
                summaryParts.push(`${splitsUpdated} split definition${splitsUpdated === 1 ? '' : 's'} updated`);
            }

            if (loadUpdated > 0) {
                summaryParts.push(`load settings updated for ${loadUpdated} teacher${loadUpdated === 1 ? '' : 's'}`);
            }

            if (summaryParts.length === 0) {
                alert('No new supplemental data detected.');
            } else {
                alert('Supplemental data imported: ' + summaryParts.join(', ') + '.');
            }
        }

        function getYear8Semester(subjectCode) {
            if (!subjectCode) {
                return null;
            }
            const normalized = subjectCode.toUpperCase().replace(/\s+/g, ' ');
            const match = normalized.match(/^S\s*([12])\s*8/);
            return match ? match[1] : null;
        }

        function normalizeSubjectCodeForPeriods(subjectCode) {
            if (!subjectCode) {
                return '';
            }

            let normalized = subjectCode.toString().toUpperCase().replace(/\s+/g, ' ').trim();
            normalized = normalized.replace(/^S[12]\s*:?\s*/, '');
            normalized = normalized.replace(/^(?:YEAR|YR)\s*/, '');
            return normalized;
        }

        function deriveYearLabelFromCode(subjectCode) {
            if (!subjectCode) {
                return null;
            }

            const normalized = normalizeSubjectCodeForPeriods(subjectCode);
            return normalizeYearLabel(normalized);
        }

        function getSubjectPeriodValue(subjectCode) {
            if (!subjectCode) {
                return 0;
            }

            if (isWednesdaySubjectCode(subjectCode)) {
                return 1;
            }

            const splitInfo = getSplitMetadata(subjectCode);
            if (splitInfo) {
                return Number.isFinite(splitInfo.periods) ? splitInfo.periods : parseInt(splitInfo.periods, 10) || 0;
            }

            const normalized = normalizeSubjectCodeForPeriods(subjectCode);
            if (!normalized) {
                return 0;
            }

            const match = normalized.match(/^(\d{1,2})/);
            if (!match) {
                return 0;
            }

            const year = parseInt(match[1], 10);
            if (!Number.isInteger(year)) {
                return 0;
            }

            if (YEAR_PERIOD_ALLOCATION[year]) {
                return YEAR_PERIOD_ALLOCATION[year];
            }

            const remainder = normalized.slice(match[1].length).trim();
            const compactRemainder = remainder.replace(/\s+/g, '');

            if (year === 8) {
                const techKeyword = /\bTECH\b/.test(remainder) || compactRemainder.includes('TECHMAND');
                const mandatoryKeyword = /(^|\s)MAND(?:ATORY)?\b/.test(remainder) || compactRemainder.includes('MANDATORY');
                const isTechMandatory = compactRemainder.startsWith('TM') || techKeyword || mandatoryKeyword;
                return isTechMandatory ? YEAR8_TECH_MANDATORY_PERIODS : YEAR8_ELECTIVE_PERIODS;
            }

            if (year === 7) {
                return YEAR7_TECH_MANDATORY_PERIODS;
            }

            return 0;
        }

        function calculateTeacherPeriodTotals() {
            const totals = new Array(teachers.length).fill(0);

            Object.entries(allocations).forEach(([key, value]) => {
                const parsed = parseAllocationKey(key);
                if (!parsed) {
                    delete allocations[key];
                    return;
                }

                const teacherIndex = parsed.teacherIndex;
                if (teacherIndex < 0 || teacherIndex >= teachers.length) {
                    return;
                }

                const subjectList = Array.isArray(value) ? value : [value];
                const validSubjects = subjectList.filter(subject => typeof subject === 'string' && subject.trim() !== '');

                if (validSubjects.length === 0) {
                    return;
                }

                const lineMinutes = getLineMinutes(parsed.lineIndex);
                const periodMultiplier = lineMinutes / STANDARD_PERIOD_MINUTES;

                const periodValues = validSubjects.map(subject => getSubjectPeriodValue(subject));

                if (isYear8SemesterPair(validSubjects) && periodValues.every(value => value === YEAR8_ELECTIVE_PERIODS)) {
                    totals[teacherIndex] += YEAR8_ELECTIVE_PERIODS * periodMultiplier;
                    return;
                }

                periodValues.forEach(periodValue => {
                    totals[teacherIndex] += periodValue * periodMultiplier;
                });
            });

            return totals;
        }

        function createDefaultTeacherLoadSettings() {
            return {
                fte: DEFAULT_FTE_VALUE,
                periodAllowance: 0,
                assemblyFullCount: 0,
                assemblyShortCount: 0,
                additionalMinutes: 0
            };
        }

        function normalizeFteValue(value) {
            if (value === null || value === undefined) {
                return DEFAULT_FTE_VALUE;
            }

            const stringValue = String(value).trim();
            if (FTE_BASE_PERIODS_MAPPING[stringValue] !== undefined) {
                return stringValue;
            }

            const numeric = Number(stringValue);
            if (Number.isFinite(numeric)) {
                const fixed = numeric.toFixed(1);
                if (FTE_BASE_PERIODS_MAPPING[fixed] !== undefined) {
                    return fixed;
                }
            }

            return DEFAULT_FTE_VALUE;
        }

        function toNumberOrZero(value) {
            const numeric = Number(value);
            return Number.isFinite(numeric) ? numeric : 0;
        }

        function getFteBasePeriods(value) {
            const normalized = normalizeFteValue(value);
            return FTE_BASE_PERIODS_MAPPING[normalized] !== undefined
                ? FTE_BASE_PERIODS_MAPPING[normalized]
                : FTE_BASE_PERIODS_MAPPING[DEFAULT_FTE_VALUE];
        }

        function getFteBaseMinutes(value) {
            return getFteBasePeriods(value) * PERIOD_MINUTES;
        }

        function getFteHours(value) {
            return getFteBaseMinutes(value) / 60;
        }

        function getTeacherLoadSettings(teacherName) {
            if (!teacherName) {
                return createDefaultTeacherLoadSettings();
            }

            if (!teacherLoadSettings || typeof teacherLoadSettings !== 'object') {
                teacherLoadSettings = {};
            }

            const key = String(teacherName);
            const existing = teacherLoadSettings[key];

            if (!existing) {
                teacherLoadSettings[key] = createDefaultTeacherLoadSettings();
            } else {
                existing.fte = normalizeFteValue(existing.fte);
                existing.periodAllowance = Math.max(0, toNumberOrZero(existing.periodAllowance));
                existing.assemblyFullCount = Math.max(0, toNumberOrZero(existing.assemblyFullCount));
                existing.assemblyShortCount = Math.max(0, toNumberOrZero(existing.assemblyShortCount));
                existing.additionalMinutes = Math.max(0, toNumberOrZero(existing.additionalMinutes));
            }

            return teacherLoadSettings[key];
        }

        function calculateTeacherLoadMetrics(teacherName, teachingPeriods) {
            const settings = getTeacherLoadSettings(teacherName);
            const validTeachingPeriods = Number.isFinite(teachingPeriods) ? teachingPeriods : 0;

            const teachingMinutes = validTeachingPeriods * PERIOD_MINUTES;
            const periodAllowanceMinutes = settings.periodAllowance * PERIOD_MINUTES;
            const assemblyFullMinutes = settings.assemblyFullCount * ASSEMBLY_FULL_MINUTES;
            const assemblyShortMinutes = settings.assemblyShortCount * ASSEMBLY_SHORT_MINUTES;
            const additionalMinutes = settings.additionalMinutes;

            const allowanceMinutes = periodAllowanceMinutes + assemblyFullMinutes + assemblyShortMinutes + additionalMinutes;
            const allowancePeriods = allowanceMinutes / PERIOD_MINUTES;

            const basePeriods = getFteBasePeriods(settings.fte);
            const baseMinutes = getFteBaseMinutes(settings.fte);
            const fteHours = getFteHours(settings.fte);

            const loadUsedMinutes = teachingMinutes + allowanceMinutes;
            const loadUsedPeriods = loadUsedMinutes / PERIOD_MINUTES;

            const balanceMinutes = baseMinutes - loadUsedMinutes;
            const balancePeriods = balanceMinutes / PERIOD_MINUTES;

            return {
                settings,
                teachingPeriods: validTeachingPeriods,
                teachingMinutes,
                allowanceMinutes,
                allowancePeriods,
                loadUsedMinutes,
                loadUsedPeriods,
                baseMinutes,
                basePeriods,
                fteHours,
                balanceMinutes,
                balancePeriods,
                periodAllowanceMinutes,
                assemblyFullMinutes,
                assemblyShortMinutes
            };
        }

        function formatPeriods(value) {
            if (!Number.isFinite(value)) {
                return '0.00';
            }
            return value.toFixed(2);
        }

        function formatMinutes(value) {
            if (!Number.isFinite(value)) {
                return '0 min';
            }
            const decimals = Math.abs(value % 1) < 0.05 ? 0 : 1;
            return `${value.toFixed(decimals)} min`;
        }

        function formatHours(value) {
            if (!Number.isFinite(value)) {
                return '0 h';
            }
            return `${value.toFixed(2)} h`;
        }

        function formatBalanceText(minutes) {
            if (!Number.isFinite(minutes)) {
                return '0.00 periods (0 min) remaining';
            }

            const remaining = minutes >= 0;
            const absoluteMinutes = Math.abs(minutes);
            const absolutePeriods = absoluteMinutes / PERIOD_MINUTES;
            const periodLabel = Math.abs(absolutePeriods - 1) < 0.005 ? 'period' : 'periods';

            const minutesText = formatMinutes(absoluteMinutes);
            const periodsText = formatPeriods(absolutePeriods);

            return remaining
                ? `${periodsText} ${periodLabel} (${minutesText}) remaining`
                : `${periodsText} ${periodLabel} (${minutesText}) over`;
        }

        function formatAllowanceDetails(settings) {
            if (!settings) {
                return 'None';
            }

            const details = [];

            if (settings.periodAllowance > 0) {
                const value = parseFloat(settings.periodAllowance.toFixed(2));
                const label = Math.abs(value - 1) < 0.005 ? 'period allowance' : 'period allowances';
                details.push(`${value} ${label}`);
            }

            if (settings.assemblyFullCount > 0) {
                const value = parseFloat(settings.assemblyFullCount.toFixed(2));
                const label = Math.abs(value - 1) < 0.005 ? 'full assembly' : 'full assemblies';
                details.push(`${value} ${label}`);
            }

            if (settings.assemblyShortCount > 0) {
                const value = parseFloat(settings.assemblyShortCount.toFixed(2));
                const label = Math.abs(value - 1) < 0.005 ? 'short/TLC assembly' : 'short/TLC assemblies';
                details.push(`${value} ${label}`);
            }

            if (settings.additionalMinutes > 0) {
                const value = parseFloat(settings.additionalMinutes.toFixed(1));
                details.push(`${value} min other allowances`);
            }

            return details.length > 0 ? details.join(', ') : 'None';
        }

        function ensureTimetableEmptyState() {
            const container = document.querySelector('.timetable-container');
            if (!container) {
                return null;
            }

            let emptyState = document.getElementById('timetableEmptyState');
            if (!emptyState) {
                emptyState = document.createElement('div');
                emptyState.id = 'timetableEmptyState';
                emptyState.className = 'timetable-empty-state is-hidden';

                const title = document.createElement('h3');
                title.textContent = 'No timetable ready yet';
                emptyState.appendChild(title);

                const message = document.createElement('p');
                message.id = 'timetableEmptyStateMessage';
                message.textContent = 'Import spreadsheet data or add teachers to build the matrix.';
                emptyState.appendChild(message);

                container.appendChild(emptyState);
            }

            return emptyState;
        }

        function ensureTeacherPeriodTotalsContainer() {
            const container = document.querySelector('.timetable-container');
            if (!container) {
                return null;
            }

            let summary = document.getElementById('teacherPeriodTotals');
            if (!summary) {
                summary = document.createElement('div');
                summary.id = 'teacherPeriodTotals';
                summary.className = 'teacher-period-summary';

                const heading = document.createElement('h3');
                heading.textContent = 'Teacher period allocation totals (per fortnight)';
                summary.appendChild(heading);

                const subtitle = document.createElement('p');
                subtitle.className = 'teacher-period-subtitle';
                subtitle.id = 'teacherPeriodSubtitle';
                subtitle.textContent = 'Calculated from subject allocations.';
                summary.appendChild(subtitle);

                const legend = document.createElement('div');
                legend.className = 'teacher-period-legend';
                legend.innerHTML = [
                    '<span>Year 12 = 7</span>',
                    '<span>Year 11 = 7</span>',
                    '<span>Year 10 = 5</span>',
                    '<span>Year 9 = 6</span>',
                    '<span>Year 8 Elective = 3</span>',
                    '<span>Year 8 Tech Mandatory = 5</span>',
                    '<span>Year 7 Tech Mandatory = 5</span>',
                    `<span>Each period = ${PERIOD_MINUTES} minutes</span>`,
                    `<span>Full assembly = ${ASSEMBLY_FULL_PERIOD_EQUIVALENT.toFixed(2)} period (~${formatMinutes(ASSEMBLY_FULL_MINUTES)})</span>`,
                    `<span>Short/TLC assembly = ${ASSEMBLY_SHORT_PERIOD_EQUIVALENT.toFixed(2)} period (${formatMinutes(ASSEMBLY_SHORT_MINUTES)})</span>`
                ].join('');
                summary.appendChild(legend);

                const toggleControls = document.createElement('div');
                toggleControls.className = 'teacher-card-toggle-controls';

                const expandBtn = document.createElement('button');
                expandBtn.type = 'button';
                expandBtn.id = 'expandTeachersBtn';
                expandBtn.className = 'btn btn-secondary btn-compact';
                expandBtn.textContent = 'Expand all cards';
                expandBtn.disabled = true;
                expandBtn.addEventListener('click', function() {
                    toggleAllTeacherCards(true);
                });
                toggleControls.appendChild(expandBtn);

                const collapseBtn = document.createElement('button');
                collapseBtn.type = 'button';
                collapseBtn.id = 'collapseTeachersBtn';
                collapseBtn.className = 'btn btn-secondary btn-compact';
                collapseBtn.textContent = 'Collapse all cards';
                collapseBtn.disabled = true;
                collapseBtn.addEventListener('click', function() {
                    toggleAllTeacherCards(false);
                });
                toggleControls.appendChild(collapseBtn);

                summary.appendChild(toggleControls);

                const grid = document.createElement('div');
                grid.id = 'teacherPeriodTotalsGrid';
                grid.className = 'teacher-period-grid';
                summary.appendChild(grid);
            }

            const containerHasSummary = summary.parentElement === container;
            const subjectPool = document.getElementById('subjectPool');

            if (subjectPool && subjectPool.parentElement === container) {
                if (!containerHasSummary || subjectPool.previousElementSibling !== summary) {
                    container.insertBefore(summary, subjectPool);
                }
            } else if (!containerHasSummary) {
                container.appendChild(summary);
            }

            return summary;
        }

        function toggleAllTeacherCards(open) {
            document.querySelectorAll('.teacher-period-card').forEach(card => {
                card.open = open;
            });
        }

        function formatTlcDisplayValue(value) {
            const numeric = Number(value);
            if (!Number.isFinite(numeric) || numeric <= 0) {
                return '0';
            }

            const sanitized = Math.max(0, numeric);
            const rounded = Math.round(sanitized);

            if (Math.abs(sanitized - rounded) < 0.0001) {
                return String(rounded);
            }

            return sanitized.toFixed(2).replace(/\.?0+$/, '');
        }

        function renderTlcPeriodsRow() {
            const tbody = document.getElementById('timetableBody');
            if (!tbody) {
                return;
            }

            const hasTeachers = Array.isArray(teachers) && teachers.length > 0;
            let row = tbody.querySelector('tr[data-tlc-row="true"]');

            if (!hasTeachers) {
                if (row) {
                    row.remove();
                }
                return;
            }

            if (!row) {
                row = document.createElement('tr');
                row.dataset.tlcRow = 'true';
                tbody.appendChild(row);
            }

            row.innerHTML = '';

            const labelCell = document.createElement('td');
            labelCell.className = 'period-row tlc-period-label';
            labelCell.textContent = 'TLC periods';
            row.appendChild(labelCell);

            teachers.forEach(teacher => {
                const cell = document.createElement('td');
                cell.className = 'tlc-period-cell';
                const settings = getTeacherLoadSettings(teacher);
                const rawValue = settings ? toNumberOrZero(settings.assemblyShortCount) : 0;
                const sanitizedValue = Math.max(0, rawValue);
                const displayValue = formatTlcDisplayValue(sanitizedValue);

                const editor = document.createElement('div');
                editor.className = 'tlc-period-editor';

                const label = document.createElement('span');
                label.className = 'tlc-period-text';
                label.textContent = 'TLC -';
                editor.appendChild(label);

                const input = document.createElement('input');
                input.type = 'number';
                input.className = 'tlc-period-input';
                input.min = '0';
                input.step = '0.01';
                input.value = displayValue;

                const teacherLabel = typeof teacher === 'string' && teacher.trim().length > 0
                    ? teacher.trim()
                    : 'teacher';
                input.setAttribute('aria-label', `Short/TLC assemblies for ${teacherLabel}`);

                input.addEventListener('focus', function() {
                    this.select();
                });

                input.addEventListener('change', function() {
                    const numeric = Number(this.value);
                    const sanitized = Number.isFinite(numeric) ? Math.max(0, numeric) : 0;
                    const rounded = Math.round(sanitized * 100) / 100;
                    const teacherSettings = getTeacherLoadSettings(teacher);
                    const previous = Math.round(Math.max(0, toNumberOrZero(teacherSettings.assemblyShortCount)) * 100) / 100;

                    if (Math.abs(previous - rounded) < 0.0001) {
                        this.value = formatTlcDisplayValue(previous);
                        return;
                    }

                    teacherSettings.assemblyShortCount = rounded;
                    this.value = formatTlcDisplayValue(rounded);
                    updateTeacherPeriodTotals();
                });

                editor.appendChild(input);
                cell.appendChild(editor);

                if (sanitizedValue > 0) {
                    const tooltipLabel = Math.abs(sanitizedValue - 1) < 0.005 ? 'short/TLC assembly' : 'short/TLC assemblies';
                    cell.title = `${displayValue} ${tooltipLabel}`;
                    input.title = cell.title;
                } else {
                    cell.title = 'No short/TLC assemblies';
                    input.title = cell.title;
                }

                row.appendChild(cell);
            });
        }

        function updateTeacherPeriodTotals() {
            const hasTeachers = Array.isArray(teachers) && teachers.length > 0;
            const existingSummary = document.getElementById('teacherPeriodTotals');
            const expandBtn = document.getElementById('expandTeachersBtn');
            const collapseBtn = document.getElementById('collapseTeachersBtn');

            if (!hasTeachers) {
                if (expandBtn) {
                    expandBtn.disabled = true;
                }
                if (collapseBtn) {
                    collapseBtn.disabled = true;
                }
                if (existingSummary) {
                    const grid = existingSummary.querySelector('#teacherPeriodTotalsGrid');
                    if (grid) {
                        grid.innerHTML = '';
                    }
                    const subtitle = existingSummary.querySelector('#teacherPeriodSubtitle');
                    if (subtitle) {
                        subtitle.textContent = 'Import spreadsheet data to configure teacher load allocations.';
                    }
                    existingSummary.style.display = 'none';
                }
                renderTlcPeriodsRow();
                return;
            }

            const summary = ensureTeacherPeriodTotalsContainer();
            if (!summary) {
                return;
            }

            summary.style.display = 'block';

            const grid = summary.querySelector('#teacherPeriodTotalsGrid');
            if (!grid) {
                return;
            }

            grid.innerHTML = '';

            const totals = calculateTeacherPeriodTotals();
            const subtitle = summary.querySelector('#teacherPeriodSubtitle');

            let totalTeachingMinutes = 0;
            let totalAllowanceMinutes = 0;
            let totalBaseMinutes = 0;

            function createSummaryRow(labelText, valueText, extraClasses = []) {
                const row = document.createElement('div');
                row.className = 'teacher-load-row';
                extraClasses.forEach(className => {
                    if (className) {
                        row.classList.add(className);
                    }
                });

                const label = document.createElement('span');
                label.textContent = labelText;
                const value = document.createElement('span');
                value.textContent = valueText;

                row.appendChild(label);
                row.appendChild(value);
                return row;
            }

            teachers.forEach((teacher, index) => {
                const metrics = calculateTeacherLoadMetrics(teacher, totals[index]);
                const settings = metrics.settings;

                totalTeachingMinutes += metrics.teachingMinutes;
                totalAllowanceMinutes += metrics.allowanceMinutes;
                totalBaseMinutes += metrics.baseMinutes;

                const card = document.createElement('details');
                card.className = 'teacher-period-card';
                const balancePositive = metrics.balanceMinutes >= 0;
                card.classList.add(balancePositive ? 'balance-positive' : 'balance-negative');

                const summaryToggle = document.createElement('summary');
                summaryToggle.className = 'teacher-card-summary';

                const summaryMain = document.createElement('div');
                summaryMain.className = 'teacher-card-summary-main teacher-period-name';
                summaryMain.textContent = teacher;
                summaryToggle.appendChild(summaryMain);

                const summaryChips = document.createElement('div');
                summaryChips.className = 'teacher-card-summary-chips';

                const fteChip = document.createElement('span');
                fteChip.className = 'teacher-card-chip fte-chip';
                fteChip.textContent = `FTE ${normalizeFteValue(settings.fte)}`;
                fteChip.title = `${formatPeriods(metrics.basePeriods)} period base (${formatMinutes(metrics.baseMinutes)}  ${formatHours(metrics.fteHours)})`;
                summaryChips.appendChild(fteChip);

                const loadChip = document.createElement('span');
                loadChip.className = 'teacher-card-chip load-chip';
                loadChip.textContent = `${formatPeriods(metrics.loadUsedPeriods)} / ${formatPeriods(metrics.basePeriods)} periods`;
                loadChip.title = `Using ${formatMinutes(metrics.loadUsedMinutes)} of ${formatMinutes(metrics.baseMinutes)}`;
                summaryChips.appendChild(loadChip);

                const balanceChip = document.createElement('span');
                const balanceClass = balancePositive ? 'positive' : 'negative';
                balanceChip.className = `teacher-card-chip balance-chip ${balanceClass}`;
                const balancePeriodsAbs = Math.abs(metrics.balancePeriods);
                balanceChip.textContent = balancePositive
                    ? `${formatPeriods(balancePeriodsAbs)} remaining`
                    : `${formatPeriods(balancePeriodsAbs)} over`;
                balanceChip.title = formatBalanceText(metrics.balanceMinutes);
                summaryChips.appendChild(balanceChip);

                summaryToggle.appendChild(summaryChips);
                card.appendChild(summaryToggle);

                const body = document.createElement('div');
                body.className = 'teacher-card-body';

                const settingsTitle = document.createElement('div');
                settingsTitle.className = 'teacher-card-section-title';
                settingsTitle.textContent = 'FTE & load settings';
                body.appendChild(settingsTitle);

                const controlsRow = document.createElement('div');
                controlsRow.className = 'teacher-card-controls';

                const fteControl = document.createElement('div');
                fteControl.className = 'teacher-fte-control';

                const fteLabel = document.createElement('label');
                fteLabel.textContent = 'FTE';
                fteControl.appendChild(fteLabel);

                const fteSelect = document.createElement('select');
                const normalizedFte = normalizeFteValue(settings.fte);
                FTE_OPTIONS.forEach(optionValue => {
                    const option = document.createElement('option');
                    option.value = optionValue;
                    const basePeriods = FTE_BASE_PERIODS_MAPPING[optionValue];
                    if (basePeriods !== undefined) {
                        const baseHours = (basePeriods * PERIOD_MINUTES) / 60;
                        option.textContent = `${optionValue} (${basePeriods.toFixed(2)} periods  ${baseHours.toFixed(2)} h)`;
                    } else {
                        option.textContent = optionValue;
                    }
                    if (optionValue === normalizedFte) {
                        option.selected = true;
                    }
                    fteSelect.appendChild(option);
                });

                fteSelect.addEventListener('change', function() {
                    settings.fte = normalizeFteValue(this.value);
                    teacherLoadSettings[teacher] = settings;
                    updateTeacherPeriodTotals();
                });

                fteControl.appendChild(fteSelect);
                controlsRow.appendChild(fteControl);
                body.appendChild(controlsRow);

                const allowanceTitle = document.createElement('div');
                allowanceTitle.className = 'teacher-card-section-title';
                allowanceTitle.textContent = 'Allowance configuration';

                const inputsContainer = document.createElement('div');
                inputsContainer.className = 'teacher-load-inputs';

                function createAllowanceInput(labelText, currentValue, options) {
                    const opts = options || {};
                    const wrapper = document.createElement('div');
                    wrapper.className = 'teacher-load-input';

                    const label = document.createElement('label');
                    label.textContent = labelText;
                    wrapper.appendChild(label);

                    const input = document.createElement('input');
                    input.type = 'number';
                    input.step = opts.step !== undefined ? opts.step : '0.01';
                    if (opts.min !== undefined) {
                        input.min = opts.min;
                    }
                    input.value = Number.isFinite(currentValue) ? currentValue : 0;

                    input.addEventListener('change', function() {
                        const numeric = Number(this.value);
                        const sanitized = Number.isFinite(numeric) ? Math.max(0, numeric) : 0;
                        if (typeof opts.onChange === 'function') {
                            opts.onChange(sanitized);
                        }
                    });

                    wrapper.appendChild(input);

                    if (opts.note) {
                        const note = document.createElement('div');
                        note.className = 'teacher-load-input-note';
                        note.textContent = opts.note;
                        wrapper.appendChild(note);
                    }

                    return wrapper;
                }

                inputsContainer.appendChild(createAllowanceInput('Period allowance', settings.periodAllowance, {
                    step: '0.01',
                    min: '0',
                    note: '59 min each',
                    onChange(value) {
                        settings.periodAllowance = Math.round(value * 100) / 100;
                        updateTeacherPeriodTotals();
                    }
                }));

                inputsContainer.appendChild(createAllowanceInput('Full assemblies', settings.assemblyFullCount, {
                    step: '0.01',
                    min: '0',
                    note: `${ASSEMBLY_FULL_PERIOD_EQUIVALENT.toFixed(2)} period (~${formatMinutes(ASSEMBLY_FULL_MINUTES)}) each`,
                    onChange(value) {
                        settings.assemblyFullCount = Math.round(value * 100) / 100;
                        updateTeacherPeriodTotals();
                    }
                }));

                inputsContainer.appendChild(createAllowanceInput('Short/TLC assemblies', settings.assemblyShortCount, {
                    step: '0.01',
                    min: '0',
                    note: `${ASSEMBLY_SHORT_PERIOD_EQUIVALENT.toFixed(2)} period (${formatMinutes(ASSEMBLY_SHORT_MINUTES)}) each`,
                    onChange(value) {
                        settings.assemblyShortCount = Math.round(value * 100) / 100;
                        updateTeacherPeriodTotals();
                    }
                }));

                inputsContainer.appendChild(createAllowanceInput('Other allowance (minutes)', settings.additionalMinutes, {
                    step: '1',
                    min: '0',
                    note: 'Custom minute-based allowance',
                    onChange(value) {
                        settings.additionalMinutes = Math.round(value * 100) / 100;
                        updateTeacherPeriodTotals();
                    }
                }));

                body.appendChild(allowanceTitle);
                body.appendChild(inputsContainer);

                const summaryTitle = document.createElement('div');
                summaryTitle.className = 'teacher-card-section-title';
                summaryTitle.textContent = 'Load summary';

                const summaryContainer = document.createElement('div');
                summaryContainer.className = 'teacher-load-summary';

                summaryContainer.appendChild(createSummaryRow(
                    'Teaching allocation',
                    `${formatPeriods(metrics.teachingPeriods)} periods (${formatMinutes(metrics.teachingMinutes)})`
                ));

                summaryContainer.appendChild(createSummaryRow(
                    'Allowances applied',
                    `${formatPeriods(metrics.allowancePeriods)} periods (${formatMinutes(metrics.allowanceMinutes)})`
                ));

                summaryContainer.appendChild(createSummaryRow(
                    'Combined load',
                    `${formatPeriods(metrics.loadUsedPeriods)} periods (${formatMinutes(metrics.loadUsedMinutes)})`
                ));

                summaryContainer.appendChild(createSummaryRow(
                    'FTE allocation',
                    `${formatPeriods(metrics.basePeriods)} periods (${formatMinutes(metrics.baseMinutes)}  ${formatHours(metrics.fteHours)})`
                ));

                const balanceRow = createSummaryRow(
                    'Balance',
                    formatBalanceText(metrics.balanceMinutes),
                    ['teacher-load-balance', balancePositive ? 'positive' : 'negative']
                );
                summaryContainer.appendChild(balanceRow);

                summaryContainer.appendChild(createSummaryRow(
                    'Allowance detail',
                    formatAllowanceDetails(settings),
                    ['teacher-load-note']
                ));

                body.appendChild(summaryTitle);
                body.appendChild(summaryContainer);

                card.appendChild(body);
                grid.appendChild(card);
            });

            const hasCards = grid.children.length > 0;
            if (expandBtn) {
                expandBtn.disabled = !hasCards;
            }
            if (collapseBtn) {
                collapseBtn.disabled = !hasCards;
            }

            if (subtitle) {
                const teachingPeriods = totalTeachingMinutes / PERIOD_MINUTES;
                const allowancePeriods = totalAllowanceMinutes / PERIOD_MINUTES;
                const totalLoadMinutes = totalTeachingMinutes + totalAllowanceMinutes;
                const totalLoadPeriods = totalLoadMinutes / PERIOD_MINUTES;
                const totalBasePeriods = totalBaseMinutes / PERIOD_MINUTES;
                const totalBaseHours = totalBaseMinutes / 60;
                const balanceMinutes = totalBaseMinutes - totalLoadMinutes;

                subtitle.textContent = [
                    'Calculated from subject allocations and load allowances.',
                    `Teaching: ${formatPeriods(teachingPeriods)} periods (${formatMinutes(totalTeachingMinutes)}).`,
                    `Allowances: ${formatPeriods(allowancePeriods)} periods (${formatMinutes(totalAllowanceMinutes)}).`,
                    `Combined load: ${formatPeriods(totalLoadPeriods)} periods vs capacity ${formatPeriods(totalBasePeriods)} periods (${formatHours(totalBaseHours)}).`,
                    `Balance: ${formatBalanceText(balanceMinutes)}.`
                ].join(' ');
            }

            renderTlcPeriodsRow();
        }

        function getYear8SemesterPairDetails(subjectCode) {
            if (!subjectCode) {
                return null;
            }

            const normalized = subjectCode.toString().toUpperCase().replace(/\s+/g, ' ').trim();
            const match = normalized.match(/^S\s*([12])\s*:?\s*(.+)$/);

            if (!match) {
                return null;
            }

            const semester = match[1];
            const remainder = match[2] ? match[2].trim() : '';
            const remainderKey = remainder.replace(/\s+/g, '');

            if (!remainderKey.startsWith('8')) {
                return null;
            }

            return {
                semester,
                remainder: remainderKey
            };
        }

        function findYear8SemesterPair(subjects) {
            if (!Array.isArray(subjects) || subjects.length < 2) {
                return null;
            }

            const detailedSubjects = subjects.map((subject, index) => {
                const details = getYear8SemesterPairDetails(subject);
                return details
                    ? { subject, index, semester: details.semester, remainder: details.remainder }
                    : null;
            }).filter(entry => entry !== null);

            if (detailedSubjects.length < 2) {
                return null;
            }

            let s1 = null;
            let s2 = null;

            for (const item of detailedSubjects) {
                if (item.semester === '1' && !s1) {
                    s1 = item;
                } else if (item.semester === '2' && !s2) {
                    s2 = item;
                }
            }

            if (s1 && s2) {
                return {
                    firstSubject: s1.subject,
                    secondSubject: s2.subject,
                    firstIndex: s1.index,
                    secondIndex: s2.index
                };
            }

            return null;
        }

        function isYear8SemesterPair(subjects) {
            return findYear8SemesterPair(subjects) !== null;
        }

        function determineCellStatus(subjects) {
            if (!subjects || subjects.length === 0) {
                return 'empty';
            }
            if (subjects.length === 1) {
                return isSplitSubject(subjects[0]) ? 'splitSingle' : 'single';
            }

            const splitMetadata = subjects.map(getSplitMetadata);
            const hasSplit = splitMetadata.some(info => info !== null);

            if (hasSplit) {
                const validSplitMetadata = splitMetadata.filter(info => info !== null);
                if (validSplitMetadata.length === subjects.length) {
                    const baseSubject = validSplitMetadata[0].baseSubject;
                    const allSameBase = validSplitMetadata.every(info => info.baseSubject === baseSubject);
                    if (allSameBase) {
                        return 'splitGroup';
                    }
                }
            }

            if (findYear8SemesterPair(subjects)) {
                return 'semesterPair';
            }
            return 'clash';
        }

        function removeSubjectFromPool(subjectCode) {
            const container = document.getElementById('subjectPoolItems');
            if (!container) {
                return;
            }
            const items = Array.from(container.querySelectorAll('.subject-slot'));
            const target = items.find(element => element.dataset.subject === subjectCode);
            if (target) {
                target.remove();
            }
        }

        function getSubjectPoolColumn(lineIndex) {
            const container = document.getElementById('subjectPoolItems');
            if (!container) {
                return null;
            }

            const numericLine = Number(lineIndex);
            const normalizedLine = Number.isInteger(numericLine) && numericLine >= 0
                ? String(numericLine)
                : 'unassigned';

            const selector = `.subject-pool-column[data-line="${normalizedLine}"] .subject-pool-column-body`;
            const column = container.querySelector(selector);

            if (column) {
                return column;
            }

            return container.querySelector('.subject-pool-column[data-line="unassigned"] .subject-pool-column-body');
        }

        function createSubjectPool() {
            const container = document.querySelector('.timetable-container');
            if (!container) {
                return;
            }

            let subjectPoolSection = document.getElementById('subjectPool');
            if (!subjectPoolSection) {
                subjectPoolSection = document.createElement('div');
                subjectPoolSection.id = 'subjectPool';
                subjectPoolSection.className = 'subject-pool-section';

                const header = document.createElement('div');
                header.className = 'subject-pool-header';

                const title = document.createElement('h3');
                title.id = 'subjectPoolTitle';
                title.textContent = 'Available Subject Pool';
                header.appendChild(title);

                const count = document.createElement('span');
                count.id = 'subjectPoolCount';
                count.className = 'subject-pool-count';
                header.appendChild(count);

                const description = document.createElement('p');
                description.id = 'subjectPoolDescription';
                description.className = 'subject-pool-description';
                description.textContent = 'Drag a subject onto the matrix or click it to allocate quickly.';
                header.appendChild(description);

                subjectPoolSection.appendChild(header);

                const grid = document.createElement('div');
                grid.id = 'subjectPoolItems';
                grid.className = 'subject-pool-grid';
                subjectPoolSection.appendChild(grid);

                container.appendChild(subjectPoolSection);
            }

            const grid = document.getElementById('subjectPoolItems');
            if (!grid) {
                return;
            }

            grid.innerHTML = '';

            const totalLines = getMaxLineNumber();
            const sanitizedLines = Array.from({ length: totalLines }, (_, index) => {
                if (Array.isArray(lines) && index < lines.length) {
                    const line = lines[index];
                    if (typeof line === 'string' && line.trim().length > 0) {
                        return line.trim();
                    }
                }

                return getDefaultLineLabel(index);
            });

            const columnBodies = new Map();

            sanitizedLines.forEach((lineLabel, lineIndex) => {
                const column = document.createElement('div');
                column.className = 'subject-pool-column';
                if (isWednesdayLineLabel(lineLabel)) {
                    column.classList.add('subject-pool-column--wed');
                }
                column.dataset.line = String(lineIndex);

                const heading = document.createElement('h4');
                heading.textContent = lineLabel;
                column.appendChild(heading);

                const body = document.createElement('div');
                body.className = 'subject-pool-column-body';
                body.dataset.line = String(lineIndex);
                makeSubjectPoolColumnDroppable(body);
                column.appendChild(body);

                grid.appendChild(column);
                columnBodies.set(String(lineIndex), body);
            });

            const unassignedColumn = document.createElement('div');
            unassignedColumn.className = 'subject-pool-column subject-pool-column--unassigned';
            unassignedColumn.dataset.line = 'unassigned';

            const unassignedHeading = document.createElement('h4');
            unassignedHeading.textContent = 'Unassigned';
            unassignedColumn.appendChild(unassignedHeading);

            const unassignedBody = document.createElement('div');
            unassignedBody.className = 'subject-pool-column-body';
            unassignedBody.dataset.line = 'unassigned';
            makeSubjectPoolColumnDroppable(unassignedBody);
            unassignedColumn.appendChild(unassignedBody);

            grid.appendChild(unassignedColumn);
            columnBodies.set('unassigned', unassignedBody);

            const allocatedSubjects = new Set(flattenAllocatedSubjects().map(subject => {
                return typeof subject === 'string' ? subject.trim() : subject;
            }));

            const seenSubjects = new Set();
            const availableSubjects = [];

            if (Array.isArray(subjects)) {
                subjects.forEach(subject => {
                    if (typeof subject !== 'string') {
                        return;
                    }

                    const trimmed = subject.trim();
                    if (trimmed.length === 0) {
                        return;
                    }

                    if (allocatedSubjects.has(trimmed)) {
                        return;
                    }

                    const comparisonKey = subjectComparisonKey(trimmed);
                    if (!comparisonKey || seenSubjects.has(comparisonKey)) {
                        return;
                    }

                    seenSubjects.add(comparisonKey);
                    availableSubjects.push(trimmed);
                });
            }

            const countElement = document.getElementById('subjectPoolCount');
            if (countElement) {
                const subjectLabel = availableSubjects.length === 1 ? 'subject' : 'subjects';
                countElement.textContent = `${availableSubjects.length} ${subjectLabel} available`;
            }

            const groups = new Map();

            availableSubjects.forEach(subject => {
                const mappedLine = getMappedLineForSubject(subject);
                const numericLine = Number.isInteger(mappedLine) ? mappedLine : null;

                const key = numericLine !== null && numericLine >= 0 && numericLine < sanitizedLines.length
                    ? String(numericLine)
                    : 'unassigned';

                if (!groups.has(key)) {
                    groups.set(key, []);
                }

                groups.get(key).push(subject);
            });

            let hasSubjects = false;

            groups.forEach((list, key) => {
                list.sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base', numeric: true }));
                const body = columnBodies.get(key) || columnBodies.get('unassigned');

                if (!body) {
                    return;
                }

                list.forEach(subject => {
                    const element = createSubjectElement(subject);
                    body.appendChild(element);
                    hasSubjects = true;
                });
            });

            if (!hasSubjects) {
                const emptyMessage = document.createElement('div');
                emptyMessage.className = 'subject-pool-empty';
                emptyMessage.textContent = 'No available subjects. Import spreadsheet data or adjust allocations to add subjects back to the pool.';
                unassignedBody.appendChild(emptyMessage);
            }

            ensureTeacherPeriodTotalsContainer();
        }

        function focusSubjectPool() {
            requestAnimationFrame(() => {
                const subjectPoolSection = document.getElementById('subjectPool');
                if (!subjectPoolSection) {
                    return;
                }

                try {
                    subjectPoolSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                } catch (error) {
                    subjectPoolSection.scrollIntoView(true);
                }

                const focusTarget = document.getElementById('subjectPoolTitle') || subjectPoolSection;
                let shouldRemoveTabIndex = false;

                if (!focusTarget.hasAttribute('tabindex')) {
                    focusTarget.setAttribute('tabindex', '-1');
                    shouldRemoveTabIndex = true;
                }

                try {
                    focusTarget.focus({ preventScroll: true });
                } catch (error) {
                    try {
                        focusTarget.focus();
                    } catch (focusError) {
                        // Element could not be focused; ignore.
                    }
                }

                if (shouldRemoveTabIndex) {
                    focusTarget.addEventListener('blur', () => {
                        focusTarget.removeAttribute('tabindex');
                    }, { once: true });
                }
            });
        }

        function createSubjectElement(subjectCode) {
            const subjectElement = document.createElement('div');
            subjectElement.className = 'subject-slot';
            subjectElement.draggable = true;
            subjectElement.dataset.subject = subjectCode;

            const mappedLine = getMappedLineForSubject(subjectCode);
            subjectElement.dataset.line = Number.isInteger(mappedLine) ? String(mappedLine) : 'unassigned';
            markElementAsWednesday(subjectElement, mappedLine);

            applySubjectDisplay(subjectElement, subjectCode);
            appendSubjectRoomDetails(subjectElement, subjectCode, { context: 'pool' });

            subjectElement.addEventListener('dragstart', handleDragStart);
            subjectElement.addEventListener('dragend', handleDragEnd);
            subjectElement.addEventListener('click', function(e) {
                if (draggedElement || subjectElement.classList.contains('dragging')) {
                    return;
                }
                e.preventDefault();
                e.stopPropagation();
                handleSubjectPoolSubjectClick(subjectCode);
            });

            return subjectElement;
        }

        function handleSubjectPoolSubjectClick(subjectCode) {
            if (!subjectCode) {
                return;
            }

            if (!Array.isArray(teachers) || teachers.length === 0) {
                alert('Please import spreadsheet data first!');
                return;
            }

            const availableSubjects = new Set(getAvailableSubjects());
            if (!availableSubjects.has(subjectCode)) {
                alert('This subject has already been allocated.');
                return;
            }

            const mappedLine = getMappedLineForSubject(subjectCode);
            const hasMappedLine = typeof mappedLine === 'number' && mappedLine >= 0 && mappedLine < lines.length;
            const teacherPrompt = hasMappedLine && lines[mappedLine]
                ? `Select teacher for ${subjectCode} (${lines[mappedLine]})`
                : `Select teacher for ${subjectCode}`;

            showAutocomplete(teacherPrompt, teachers, function(selectedTeacher) {
                const teacherIndex = teachers.indexOf(selectedTeacher);

                if (teacherIndex === -1) {
                    alert('Invalid teacher selection!');
                    return;
                }

                const finalizeAllocation = (lineIndex) => {
                    const allocationSucceeded = allocateSubjectToTeacher(subjectCode, teacherIndex, lineIndex);

                    if (!allocationSucceeded) {
                        if (!wasLastAllocationBlockedByClash()) {
                            alert('Unable to allocate this subject to the selected teacher.');
                        }
                        return;
                    }

                    const lineName = typeof lineIndex === 'number' && lines[lineIndex]
                        ? ` on ${lines[lineIndex]}`
                        : '';
                    alert(`Subject ${subjectCode} allocated to ${selectedTeacher}${lineName}!`);
                };

                if (hasMappedLine) {
                    finalizeAllocation(mappedLine);
                } else {
                    setTimeout(() => {
                        showAutocomplete(`Select line for ${subjectCode}`, lines, function(selectedLine) {
                            const lineIndex = lines.indexOf(selectedLine);

                            if (lineIndex === -1) {
                                alert('Invalid line selection!');
                                return;
                            }

                            finalizeAllocation(lineIndex);
                        });
                    }, 200);
                }
            });
        }

        function addSubjectToPool(subjectCode) {
            const container = document.getElementById('subjectPoolItems');
            if (!container) {
                return;
            }

            const exists = Array.from(container.querySelectorAll('.subject-slot'))
                .some(element => element.dataset.subject === subjectCode);

            if (exists) {
                return;
            }

            const columnBody = getSubjectPoolColumn(getMappedLineForSubject(subjectCode));
            if (!columnBody) {
                return;
            }

            const subjectElement = createSubjectElement(subjectCode);
            columnBody.appendChild(subjectElement);
        }

        function removeSubjectFromCell(lineIndex, teacherIndex, subjectCode, addBackToPool = false) {
            const key = getAllocationKey(lineIndex, teacherIndex);
            const subjects = getAllocationSubjects(key);
            const subjectPosition = subjects.indexOf(subjectCode);

            if (subjectPosition === -1) {
                return;
            }

            subjects.splice(subjectPosition, 1);
            setAllocationSubjects(key, subjects);

            if (addBackToPool) {
                addSubjectToPool(subjectCode);
            }

            clearAllocationRoomAssignments(lineIndex, teacherIndex, subjectCode);
        }

        function getTeacherLabel(teacherIndex) {
            if (!Number.isInteger(teacherIndex) || teacherIndex < 0 || teacherIndex >= teachers.length) {
                return 'Teacher not set';
            }

            const name = teachers[teacherIndex];
            return typeof name === 'string' && name.trim().length > 0
                ? name.trim()
                : `Teacher ${teacherIndex + 1}`;
        }

        function getLineLabel(lineIndex) {
            if (!Number.isInteger(lineIndex) || lineIndex < 0 || lineIndex >= lines.length) {
                return 'Line not set';
            }

            const label = lines[lineIndex];
            return typeof label === 'string' && label.trim().length > 0
                ? label.trim()
                : `Line ${lineIndex + 1}`;
        }

        function promptMoveSubjectToLine(currentLineIndex, teacherIndex, subjectCode) {
            const availableLines = Array.isArray(lines)
                ? lines.map((lineLabel, index) => ({
                    index,
                    label: typeof lineLabel === 'string' && lineLabel.trim().length > 0
                        ? lineLabel.trim()
                        : `Line ${index + 1}`
                }))
                : [];

            const targetLines = availableLines.filter(option => option.index !== currentLineIndex);

            if (targetLines.length === 0) {
                showAppAlert('No other lines are available for this teacher.', {
                    title: 'Move unavailable',
                    icon: ''
                });
                return;
            }

            const teacherLabel = getTeacherLabel(teacherIndex);
            const currentLineLabel = getLineLabel(currentLineIndex);

            const optionMap = new Map();
            const displayOptions = targetLines.map(option => {
                const display = `${option.label} (Line ${option.index + 1})`;
                optionMap.set(display, option.index);
                return display;
            });

            showAutocomplete(`Select new line for ${subjectCode}`, displayOptions, function(selectedOption) {
                if (!optionMap.has(selectedOption)) {
                    return;
                }

                const targetLineIndex = optionMap.get(selectedOption);
                if (!Number.isInteger(targetLineIndex)) {
                    return;
                }

                const moved = allocateSubjectToTeacher(subjectCode, teacherIndex, targetLineIndex);
                if (!moved) {
                    if (!wasLastAllocationBlockedByClash()) {
                        showAppAlert(`Unable to move ${subjectCode} to ${teacherLabel} on ${getLineLabel(targetLineIndex)}.`, {
                            title: 'Move failed',
                            icon: ''
                        });
                    }
                    return;
                }

                showAppAlert(`${subjectCode} moved to ${teacherLabel} on ${getLineLabel(targetLineIndex)}.`, {
                    title: 'Subject moved',
                    icon: ''
                });
            }, {
                showListOnOpen: true,
                description: `Current line: ${currentLineLabel}. Choose a new line for ${subjectCode}.`,
                confirmLabel: 'Move subject',
                cancelLabel: 'Cancel'
            });
        }

        async function handleAllocatedSubjectAction(lineIndex, teacherIndex, subjectCode) {
            if (!subjectCode) {
                return;
            }

            if (typeof window.showAppDialog === 'function') {
                const teacherLabel = getTeacherLabel(teacherIndex);
                const lineLabel = getLineLabel(lineIndex);
                const message = [
                    `Subject: ${subjectCode}`,
                    `Teacher: ${teacherLabel}`,
                    `Line: ${lineLabel}`,
                    '',
                    'Choose an action for this allocation.'
                ].join('\n');

                try {
                    const choice = await showAppDialog(message, {
                        title: 'Manage allocation',
                        icon: '',
                        actions: [
                            { label: 'Move to another line', value: 'move', variant: 'primary', role: 'option', focus: true },
                            { label: 'Remove from teacher', value: 'remove', variant: 'danger', role: 'option' },
                            { label: 'Cancel', value: 'cancel', variant: 'secondary', role: 'cancel' }
                        ],
                        dismissValue: 'cancel'
                    });

                    if (choice === 'move') {
                        promptMoveSubjectToLine(lineIndex, teacherIndex, subjectCode);
                    } else if (choice === 'remove') {
                        await handleSubjectRemoval(lineIndex, teacherIndex, subjectCode);
                    }
                    return;
                } catch (error) {
                    console.error('Unable to show allocation options dialog:', error);
                }
            }

            await handleSubjectRemoval(lineIndex, teacherIndex, subjectCode);
        }

        async function handleSubjectRemoval(lineIndex, teacherIndex, subjectCode) {
            const teacherLabel = getTeacherLabel(teacherIndex);
            const confirmed = await showAppConfirm('Remove ' + subjectCode + ' from ' + teacherLabel + '', {
                confirmLabel: 'Remove',
                cancelLabel: 'Cancel'
            });
            if (!confirmed) {
                return;
            }

            removeSubjectFromCell(lineIndex, teacherIndex, subjectCode, true);
            renderCell(lineIndex, teacherIndex);
            updateStats();
        }

        function enhanceAllocatedSubjectElement(element, subjectCode, lineIndex, teacherIndex) {
            if (!element) {
                return;
            }

            element.dataset.subject = subjectCode;
            element.dataset.teacher = teacherIndex;
            element.dataset.line = lineIndex;
            element.dataset.allocationState = 'allocated';
            element.draggable = true;

            element.addEventListener('dragstart', handleDragStart);
            element.addEventListener('dragend', handleDragEnd);
            element.addEventListener('click', async function(e) {
                e.preventDefault();
                e.stopPropagation();

                if (draggedElement || element.classList.contains('dragging')) {
                    return;
                }

                try {
                    await handleAllocatedSubjectAction(lineIndex, teacherIndex, subjectCode);
                } catch (error) {
                    console.error('Error handling allocated subject action:', error);
                }
            });
        }

        function initializeTimetable() {
            const head = document.getElementById('timetableHead');
            const body = document.getElementById('timetableBody');
            const table = document.getElementById('timetable');
            const emptyState = ensureTimetableEmptyState();

            if (!head || !body || !table) {
                return;
            }

            const teacherList = Array.isArray(teachers) ? teachers : [];
            const hasTeachers = teacherList.length > 0;

            if (!hasTeachers) {
                head.innerHTML = '';
                body.innerHTML = '';

                if (table) {
                    table.classList.add('is-hidden');
                }

                if (emptyState) {
                    emptyState.classList.remove('is-hidden');
                }

                renderTlcPeriodsRow();
                ensureTeacherPeriodTotalsContainer();
                return;
            }

            if (table) {
                table.classList.remove('is-hidden');
            }

            if (emptyState) {
                emptyState.classList.add('is-hidden');
            }

            let headerRow = head.querySelector('tr');
            if (!headerRow) {
                headerRow = document.createElement('tr');
                head.appendChild(headerRow);
            }

            headerRow.innerHTML = '';

            const lineHeader = document.createElement('th');
            lineHeader.textContent = 'Line';
            lineHeader.setAttribute('scope', 'col');
            headerRow.appendChild(lineHeader);

            teacherList.forEach((teacherName, index) => {
                const columnHeader = document.createElement('th');
                columnHeader.className = 'teacher-column';
                columnHeader.dataset.teacher = index;

                const label = typeof teacherName === 'string' && teacherName.trim().length > 0
                    ? teacherName.trim()
                    : `Teacher ${index + 1}`;

                columnHeader.textContent = label;
                headerRow.appendChild(columnHeader);
            });

            body.innerHTML = '';

            const lineList = Array.isArray(lines) ? lines : [];

            lineList.forEach((lineLabel, lineIndex) => {
                const row = document.createElement('tr');

                const labelCell = document.createElement('td');
                labelCell.className = 'period-row';
                const lineText = typeof lineLabel === 'string' && lineLabel.trim().length > 0
                    ? lineLabel.trim()
                    : `Line ${lineIndex + 1}`;
                labelCell.textContent = lineText;

                if (isWednesdayLineLabel(lineText)) {
                    row.classList.add('timetable-row--wed');
                    labelCell.classList.add('period-row--wed');
                }

                row.appendChild(labelCell);

                teacherList.forEach((teacherName, teacherIndex) => {
                    const cell = document.createElement('td');
                    cell.className = 'drop-zone';
                    if (isWednesdayLineIndex(lineIndex)) {
                        cell.classList.add('drop-zone--wed');
                    }
                    cell.dataset.period = String(lineIndex);
                    cell.dataset.teacher = String(teacherIndex);

                    const teacherLabel = typeof teacherName === 'string' && teacherName.trim().length > 0
                        ? teacherName.trim()
                        : `Teacher ${teacherIndex + 1}`;

                    cell.tabIndex = 0;
                    cell.setAttribute('role', 'button');
                    cell.setAttribute('aria-label', `Allocate subject to ${teacherLabel} on ${lineText}`);

                    cell.addEventListener('click', function() {
                        showAllocationPopup(lineIndex, teacherIndex);
                    });

                    cell.addEventListener('keydown', function(event) {
                        if (event.key === 'Enter' || event.key === ' ') {
                            event.preventDefault();
                            showAllocationPopup(lineIndex, teacherIndex);
                        }
                    });

                    cell.addEventListener('dragover', handleDragOver);
                    cell.addEventListener('dragenter', handleDragEnter);
                    cell.addEventListener('dragleave', handleDragLeave);
                    cell.addEventListener('drop', handleDrop);

                    row.appendChild(cell);
                });

                body.appendChild(row);
            });

            renderAllAllocations();
            renderTlcPeriodsRow();
            ensureTeacherPeriodTotalsContainer();
        }

        function renderCell(lineIndex, teacherIndex) {
            const cell = document.querySelector(`[data-period="${lineIndex}"][data-teacher="${teacherIndex}"]`);
            if (!cell) {
                return;
            }

            cell.classList.remove('clash-cell', 'semester-pair-cell', 'split-allocation-cell');
            cell.querySelectorAll('.subject-slot, .split-allocation-header').forEach(element => element.remove());

            const key = getAllocationKey(lineIndex, teacherIndex);
            const subjects = getAllocationSubjects(key);
            const status = determineCellStatus(subjects);

            if (status === 'empty') {
                scheduleRoomClashRefresh();
                return;
            }

            if (status === 'semesterPair') {
                const pair = findYear8SemesterPair(subjects);
                if (pair) {
                    cell.classList.add('semester-pair-cell');

                    const wrapper = document.createElement('div');
                    wrapper.className = 'subject-slot allocated semester-pair';
                    wrapper.dataset.teacher = teacherIndex;
                    wrapper.dataset.line = lineIndex;
                    markElementAsWednesday(wrapper, lineIndex);

                    [pair.firstSubject, pair.secondSubject].forEach(subject => {
                        const subjectRow = document.createElement('div');
                        subjectRow.className = 'semester-pair-item';
                        subjectRow.textContent = subject;
                        appendSubjectRoomDetails(subjectRow, subject, {
                            context: 'cell',
                            lineIndex: lineIndex,
                            teacherIndex: teacherIndex
                        });
                        enhanceAllocatedSubjectElement(subjectRow, subject, lineIndex, teacherIndex);
                        wrapper.appendChild(subjectRow);
                    });

                    const label = document.createElement('div');
                    label.className = 'semester-pair-label';
                    label.textContent = 'S1/S2 Pair';
                    wrapper.appendChild(label);

                    cell.appendChild(wrapper);

                    const extras = subjects.filter((subject, index) => index !== pair.firstIndex && index !== pair.secondIndex);

                    extras.forEach(subject => {
                        const subjectElement = document.createElement('div');
                        subjectElement.className = 'subject-slot allocated';
                        markElementAsWednesday(subjectElement, lineIndex);

                        const shouldForceSegment = isSplitSubject(subject);
                        applySubjectDisplay(subjectElement, subject, {
                            hideBaseLabel: false,
                            forceSegmentStyle: shouldForceSegment
                        });

                        appendSubjectRoomDetails(subjectElement, subject, {
                            context: 'cell',
                            lineIndex: lineIndex,
                            teacherIndex: teacherIndex
                        });

                        enhanceAllocatedSubjectElement(subjectElement, subject, lineIndex, teacherIndex);
                        cell.appendChild(subjectElement);
                    });

                    scheduleRoomClashRefresh();
                    return;
                }

                cell.classList.add('semester-pair-cell');
                const wrapper = document.createElement('div');
                wrapper.className = 'subject-slot allocated semester-pair';
                wrapper.dataset.teacher = teacherIndex;
                wrapper.dataset.line = lineIndex;
                markElementAsWednesday(wrapper, lineIndex);

                subjects.forEach(subject => {
                    const subjectRow = document.createElement('div');
                    subjectRow.className = 'semester-pair-item';
                    subjectRow.textContent = subject;
                    appendSubjectRoomDetails(subjectRow, subject, {
                        context: 'cell',
                        lineIndex: lineIndex,
                        teacherIndex: teacherIndex
                    });
                    enhanceAllocatedSubjectElement(subjectRow, subject, lineIndex, teacherIndex);
                    wrapper.appendChild(subjectRow);
                });

                const label = document.createElement('div');
                label.className = 'semester-pair-label';
                label.textContent = 'S1/S2 Pair';
                wrapper.appendChild(label);

                cell.appendChild(wrapper);
                scheduleRoomClashRefresh();
                return;
            }

            if (status === 'splitGroup' || status === 'splitSingle') {
                cell.classList.add('split-allocation-cell');
            }

            if (status === 'splitGroup') {
                const metadata = getSplitMetadata(subjects[0]);
                if (metadata) {
                    const header = document.createElement('div');
                    header.className = 'split-allocation-header';
                    header.textContent = `${metadata.baseSubject}  split allocation`;
                    cell.appendChild(header);
                }
            }

            if (status === 'clash') {
                cell.classList.add('clash-cell');
            }

            subjects.forEach(subject => {
                const subjectElement = document.createElement('div');
                subjectElement.className = 'subject-slot allocated';
                markElementAsWednesday(subjectElement, lineIndex);
                if (status === 'clash') {
                    subjectElement.classList.add('clash');
                }

                const shouldForceSegment = status === 'splitGroup' || status === 'splitSingle' || isSplitSubject(subject);
                applySubjectDisplay(subjectElement, subject, {
                    hideBaseLabel: status === 'splitGroup',
                    forceSegmentStyle: shouldForceSegment
                });

                appendSubjectRoomDetails(subjectElement, subject, {
                    context: 'cell',
                    lineIndex: lineIndex,
                    teacherIndex: teacherIndex
                });

                enhanceAllocatedSubjectElement(subjectElement, subject, lineIndex, teacherIndex);
                cell.appendChild(subjectElement);
            });

            scheduleRoomClashRefresh();
        }

        function renderAllAllocations() {
            document.querySelectorAll('.drop-zone').forEach(cell => {
                cell.classList.remove('clash-cell', 'semester-pair-cell', 'split-allocation-cell');
                cell.querySelectorAll('.subject-slot, .split-allocation-header').forEach(slot => slot.remove());
            });

            Object.keys(allocations).forEach(key => {
                const parsed = parseAllocationKey(key);
                if (!parsed) {
                    delete allocations[key];
                    return;
                }

                renderCell(parsed.lineIndex, parsed.teacherIndex);
            });

            syncSubjectPool();
            scheduleRoomClashRefresh();
        }

        function syncSubjectPool() {
            const container = document.getElementById('subjectPoolItems');
            if (!container) {
                return;
            }

            const allocatedSubjects = new Set(flattenAllocatedSubjects());
            Array.from(container.querySelectorAll('.subject-slot')).forEach(item => {
                if (allocatedSubjects.has(item.dataset.subject)) {
                    item.remove();
                }
            });
        }

        // Autocomplete functionality
        let currentAutocompleteCallback = null;
        let selectedIndex = -1;
        let filteredItems = [];
        let currentDisplayedItems = [];
        let currentAutocompleteOptions = {};
        const DEFAULT_CONFIRM_LABEL = 'Confirm';
        const DEFAULT_CANCEL_LABEL = 'Cancel';
        const DEFAULT_PLACEHOLDER = 'Start typing to search...';

        function normalizeSubjectList(subjectList) {
            if (!Array.isArray(subjectList)) {
                return [];
            }

            const seen = new Set();
            const normalized = [];

            subjectList.forEach(subject => {
                if (typeof subject !== 'string') {
                    return;
                }

                const normalizedCode = normalizeSubjectCode(subject);
                if (!normalizedCode) {
                    return;
                }

                const comparisonKey = normalizedCode.replace(/\s+/g, '');
                if (seen.has(comparisonKey)) {
                    return;
                }

                seen.add(comparisonKey);
                normalized.push(normalizedCode);
            });

            return normalized;
        }

        function normalizeSubjectMapping(source) {
            if (!source || typeof source !== 'object') {
                return {};
            }

            const normalized = {};

            Object.entries(source).forEach(([code, value]) => {
                if (typeof code !== 'string') {
                    return;
                }

                const normalizedCode = normalizeSubjectCode(code);
                if (!normalizedCode) {
                    return;
                }

                normalized[normalizedCode] = value;
            });

            return normalized;
        }

        function canonicalizeSubjectData() {
            if (!Array.isArray(subjects)) {
                subjects = [];
            }

            subjects = normalizeSubjectList(subjects);

            subjectLineMapping = normalizeSubjectMapping(subjectLineMapping);
            subjectYearMapping = normalizeSubjectMapping(subjectYearMapping);

            if (!allocations || typeof allocations !== 'object') {
                allocations = {};
            } else {
                const normalizedAllocations = {};

                Object.entries(allocations).forEach(([key, value]) => {
                    const parsed = parseAllocationKey(key);
                    if (!parsed) {
                        delete allocations[key];
                        return;
                    }

                    const subjectList = Array.isArray(value) ? value : [value];
                    const seenSubjects = new Set();
                    const normalizedSubjects = [];

                    subjectList.forEach(subjectCode => {
                        if (typeof subjectCode !== 'string') {
                            return;
                        }

                        const normalizedCode = normalizeSubjectCode(subjectCode);
                        if (!normalizedCode || seenSubjects.has(normalizedCode)) {
                            return;
                        }

                        seenSubjects.add(normalizedCode);
                        normalizedSubjects.push(normalizedCode);
                    });

                    if (normalizedSubjects.length > 0) {
                        normalizedAllocations[parsed.key] = normalizedSubjects;
                    }
                });

                allocations = {};
                Object.entries(normalizedAllocations).forEach(([key, value]) => {
                    setAllocationSubjects(key, value);
                });
            }

            if (subjectSplits && typeof subjectSplits === 'object') {
                const normalizedSplits = {};

                Object.entries(subjectSplits).forEach(([baseSubject, splits]) => {
                    if (!Array.isArray(splits)) {
                        return;
                    }

                    const normalizedBase = normalizeSubjectCode(baseSubject);
                    if (!normalizedBase) {
                        return;
                    }

                    const seenSplitCodes = new Set();
                    const sanitizedSplits = [];

                    splits.forEach(split => {
                        if (!split || typeof split !== 'object' || typeof split.code !== 'string') {
                            return;
                        }

                        const normalizedSplitCode = normalizeSubjectCode(split.code);
                        if (!normalizedSplitCode || seenSplitCodes.has(normalizedSplitCode)) {
                            return;
                        }

                        seenSplitCodes.add(normalizedSplitCode);
                        sanitizedSplits.push({ ...split, code: normalizedSplitCode });
                    });

                    if (sanitizedSplits.length > 0) {
                        normalizedSplits[normalizedBase] = sanitizedSplits;
                    }
                });

                subjectSplits = normalizedSplits;
                rebuildSplitLookup();
            }

            selfHealSubjectLineMapping();
        }

        function canonicalizeRoomAssignments() {
            if (!subjectRoomAssignments || typeof subjectRoomAssignments !== 'object') {
                subjectRoomAssignments = {};
            } else {
                const normalizedRooms = {};
                Object.entries(subjectRoomAssignments).forEach(([subjectCode, entries]) => {
                    const normalizedCode = normalizeSubjectCode(subjectCode);
                    if (!normalizedCode) {
                        return;
                    }
                    const sanitizedEntries = normalizeRoomEntries(entries);
                    if (sanitizedEntries.length > 0) {
                        normalizedRooms[normalizedCode] = sanitizedEntries;
                    }
                });
                subjectRoomAssignments = normalizedRooms;
            }

            if (!allocationRoomOverrides || typeof allocationRoomOverrides !== 'object') {
                allocationRoomOverrides = {};
                return;
            }

            const normalizedOverrides = {};
            Object.entries(allocationRoomOverrides).forEach(([key, mapping]) => {
                const parsed = parseAllocationKey(key);
                if (!parsed) {
                    return;
                }

                const subjectsInCell = new Set(getAllocationSubjects(parsed.key).map(code => normalizeSubjectCode(code)));
                if (!mapping || typeof mapping !== 'object') {
                    return;
                }

                const sanitizedMapping = {};
                Object.entries(mapping).forEach(([subjectCode, entries]) => {
                    const normalizedCode = normalizeSubjectCode(subjectCode);
                    if (!normalizedCode || !subjectsInCell.has(normalizedCode)) {
                        return;
                    }
                    const sanitizedEntries = normalizeRoomEntries(entries);
                    if (sanitizedEntries.length > 0) {
                        sanitizedMapping[normalizedCode] = sanitizedEntries;
                    }
                });

                if (Object.keys(sanitizedMapping).length > 0) {
                    normalizedOverrides[parsed.key] = sanitizedMapping;
                }
            });

            allocationRoomOverrides = normalizedOverrides;

            scheduleRoomClashRefresh();
        }

        // Drag and drop event handlers
        function handleDragStart(e) {
            const source = e.currentTarget || e.target;
            if (!source) {
                return;
            }

            draggedElement = source;
            source.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', source.outerHTML);
        }

        function handleDragEnd(e) {
            const source = e.currentTarget || e.target;
            if (source) {
                source.classList.remove('dragging');
            }

            if (!draggedElement || draggedElement === source) {
                draggedElement = null;
            }
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDragEnter(e) {
            e.preventDefault();
            e.currentTarget.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            const cell = e.currentTarget;
            cell.classList.remove('drag-over');

            if (!draggedElement) {
                return;
            }

            const subject = draggedElement.dataset.subject;
            if (!subject) {
                return;
            }

            const period = parseInt(cell.dataset.period, 10);
            const teacher = parseInt(cell.dataset.teacher, 10);
            const isAllocatedElement = draggedElement.classList.contains('allocated')
                || draggedElement.dataset.allocationState === 'allocated';

            if (allocateSubjectToTeacher(subject, teacher, period)) {
                if (!isAllocatedElement) {
                    draggedElement.remove();
                }
            }
        }

        function isSubjectPoolDraggable(element) {
            if (!element || !element.classList) {
                return false;
            }
            const isAllocated = element.classList.contains('allocated')
                || element.dataset.allocationState === 'allocated';
            return element.classList.contains('subject-slot') && !isAllocated;
        }

        function handleSubjectPoolDragEnter(e) {
            if (!isSubjectPoolDraggable(draggedElement)) {
                return;
            }
            e.preventDefault();
            e.currentTarget.classList.add('drag-over');
        }

        function handleSubjectPoolDragLeave(e) {
            if (e.currentTarget.contains(e.relatedTarget)) {
                return;
            }
            e.currentTarget.classList.remove('drag-over');
        }

        function handleSubjectPoolDragOver(e) {
            if (!isSubjectPoolDraggable(draggedElement)) {
                return;
            }
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleSubjectPoolDrop(e) {
            if (!isSubjectPoolDraggable(draggedElement)) {
                return;
            }

            e.preventDefault();
            const target = e.currentTarget;
            target.classList.remove('drag-over');

            const subjectCode = draggedElement.dataset.subject;
            if (!subjectCode) {
                return;
            }

            const lineKey = target.dataset.line;
            const numericLine = lineKey === 'unassigned' ? null : parseInt(lineKey, 10);

            let mappingChanged = false;
            if (numericLine === null || Number.isNaN(numericLine)) {
                mappingChanged = clearLineMappingForSubject(subjectCode);
            } else {
                mappingChanged = applyLineMappingToSubject(subjectCode, numericLine);
            }

            if (mappingChanged) {
                createSubjectPool();
                updateStats();
            } else if (numericLine !== null && !Number.isNaN(numericLine)) {
                if (target !== draggedElement.parentElement) {
                    target.appendChild(draggedElement);
                }
            }

            if (draggedElement) {
                draggedElement.classList.remove('dragging');
            }
            draggedElement = null;
        }

        function makeSubjectPoolColumnDroppable(columnBody) {
            if (!columnBody) {
                return;
            }

            columnBody.addEventListener('dragenter', handleSubjectPoolDragEnter);
            columnBody.addEventListener('dragover', handleSubjectPoolDragOver);
            columnBody.addEventListener('dragleave', handleSubjectPoolDragLeave);
            columnBody.addEventListener('drop', handleSubjectPoolDrop);
        }

        // CSV Import functionality
        function hasExistingData() {
            const hasTeachers = Array.isArray(teachers) && teachers.length > 0;
            const hasSubjects = Array.isArray(subjects) && subjects.length > 0;
            const hasAllocations = allocations && Object.keys(allocations).length > 0;
            return hasTeachers || hasSubjects || hasAllocations;
        }

        // Autocomplete functions
        function showAutocomplete(title, items, callback, options = {}) {
            const modal = document.getElementById('autocompleteModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalDescription = document.getElementById('modalDescription');
            const input = document.getElementById('autocompleteInput');
            const list = document.getElementById('autocompleteList');
            const confirmBtn = document.getElementById('confirmBtn');
            const cancelBtn = document.getElementById('cancelBtn');
            const container = document.querySelector('.autocomplete-container');
            const managementContainer = document.getElementById('managementActionContainer');

            if (managementContainer) {
                managementContainer.innerHTML = '';
                managementContainer.style.display = 'none';
            }

            if (container) {
                container.style.display = 'block';
            }

            const normalizedItems = Array.isArray(items) ? [...items] : [];

            const config = {
                showListOnOpen: Boolean(options.showListOnOpen),
                hideSearchInput: Boolean(options.hideSearchInput),
                placeholder: typeof options.placeholder === 'string' && options.placeholder.trim().length > 0
                    ? options.placeholder.trim()
                    : '',
                description: typeof options.description === 'string' ? options.description.trim() : '',
                confirmLabel: typeof options.confirmLabel === 'string' && options.confirmLabel.trim().length > 0
                    ? options.confirmLabel.trim()
                    : DEFAULT_CONFIRM_LABEL,
                cancelLabel: typeof options.cancelLabel === 'string' && options.cancelLabel.trim().length > 0
                    ? options.cancelLabel.trim()
                    : DEFAULT_CANCEL_LABEL,
                hideConfirmButton: Boolean(options.hideConfirmButton),
                emptyStateMessage: typeof options.emptyStateMessage === 'string' && options.emptyStateMessage.trim().length > 0
                    ? options.emptyStateMessage.trim()
                    : 'No matches found',
                itemLayout: typeof options.itemLayout === 'string' && options.itemLayout.trim().length > 0
                    ? options.itemLayout.trim()
                    : 'list'
            };

            const defaultPlaceholder = config.showListOnOpen
                ? 'Click an option or start typing to filter...'
                : DEFAULT_PLACEHOLDER;
            const placeholderText = config.placeholder || defaultPlaceholder;

            currentAutocompleteOptions = config;
            currentAutocompleteCallback = callback;
            filteredItems = normalizedItems;
            currentDisplayedItems = [];
            selectedIndex = -1;

            if (modalTitle) {
                modalTitle.textContent = title;
            }

            if (modalDescription) {
                if (config.description) {
                    modalDescription.textContent = config.description;
                    modalDescription.style.display = 'block';
                } else {
                    modalDescription.textContent = '';
                    modalDescription.style.display = 'none';
                }
            }

            if (confirmBtn) {
                confirmBtn.textContent = config.confirmLabel;
                confirmBtn.style.display = config.hideConfirmButton ? 'none' : 'inline-block';
            }

            if (cancelBtn) {
                cancelBtn.textContent = config.cancelLabel || DEFAULT_CANCEL_LABEL;
            }

            if (container) {
                if (config.hideSearchInput) {
                    container.classList.add('autocomplete-container--static');
                } else {
                    container.classList.remove('autocomplete-container--static');
                }
            }

            input.value = '';
            input.placeholder = placeholderText;
            input.style.display = config.hideSearchInput ? 'none' : 'block';

            list.innerHTML = '';
            list.style.display = 'none';
            list.classList.toggle('autocomplete-list--grid', config.itemLayout === 'grid');

            modal.style.display = 'block';

            if (config.hideSearchInput) {
                const modalContent = document.querySelector('.modal-content');
                if (modalContent) {
                    setTimeout(() => modalContent.focus(), 0);
                }
            } else {
                setTimeout(() => input.focus(), 0);
            }

            if (config.showListOnOpen) {
                renderAutocompleteItems(normalizedItems);
            } else {
                updateFilteredList('');
            }
        }

        function renderAutocompleteItems(items) {
            const list = document.getElementById('autocompleteList');

            const useGridLayout = currentAutocompleteOptions.itemLayout === 'grid';
            list.classList.toggle('autocomplete-list--grid', useGridLayout);

            currentDisplayedItems = Array.isArray(items) ? [...items] : [];
            list.innerHTML = '';

            if (currentDisplayedItems.length === 0) {
                const emptyDiv = document.createElement('div');
                emptyDiv.className = 'autocomplete-item autocomplete-item--empty';
                emptyDiv.textContent = currentAutocompleteOptions.emptyStateMessage || 'No matches found';
                emptyDiv.tabIndex = -1;
                list.appendChild(emptyDiv);
                list.style.display = 'block';
                selectedIndex = -1;
                updateSelection();
                return;
            }

            currentDisplayedItems.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'autocomplete-item';
                if (useGridLayout) {
                    div.classList.add('autocomplete-item--grid');
                }
                div.textContent = item;
                div.tabIndex = 0;

                div.addEventListener('focus', () => {
                    selectedIndex = index;
                    updateSelection();
                });

                div.addEventListener('click', () => {
                    selectedIndex = index;
                    updateSelection();

                    if (!currentAutocompleteOptions.hideSearchInput) {
                        const input = document.getElementById('autocompleteInput');
                        input.value = item;
                    }

                    if (currentAutocompleteCallback) {
                        currentAutocompleteCallback(item);
                        closeModal();
                    }
                });

                div.addEventListener('keydown', event => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        selectedIndex = index;
                        updateSelection();
                        if (currentAutocompleteCallback) {
                            currentAutocompleteCallback(item);
                            closeModal();
                        }
                    }
                });

                list.appendChild(div);
            });

            list.style.display = 'block';
            selectedIndex = -1;
            updateSelection();
        }

        function updateFilteredList(query) {
            const list = document.getElementById('autocompleteList');
            const normalizedQuery = (query || '').trim().toLowerCase();

            if (!Array.isArray(filteredItems) || filteredItems.length === 0) {
                list.innerHTML = '';
                list.style.display = 'none';
                currentDisplayedItems = [];
                selectedIndex = -1;
                return;
            }

            if (!currentAutocompleteOptions.showListOnOpen && normalizedQuery.length === 0) {
                list.innerHTML = '';
                list.style.display = 'none';
                currentDisplayedItems = [];
                selectedIndex = -1;
                return;
            }

            const filtered = normalizedQuery.length === 0
                ? [...filteredItems]
                : filteredItems.filter(item => item.toLowerCase().includes(normalizedQuery));

            renderAutocompleteItems(filtered);
        }

        function selectItem(index) {
            selectedIndex = index;
            updateSelection();

            const input = document.getElementById('autocompleteInput');
            if (index >= 0 && index < currentDisplayedItems.length) {
                input.value = currentDisplayedItems[index];
            }

            const list = document.getElementById('autocompleteList');
            list.style.display = 'none';
        }

        function updateSelection() {
            const items = document.querySelectorAll('.autocomplete-item');
            items.forEach((item, index) => {
                if (index === selectedIndex) {
                    item.classList.add('selected');
                } else {
                    item.classList.remove('selected');
                }
            });
        }

        function confirmSelection() {
            const input = document.getElementById('autocompleteInput');

            if (selectedIndex >= 0 && selectedIndex < currentDisplayedItems.length) {
                const selectedItem = currentDisplayedItems[selectedIndex];
                if (currentAutocompleteCallback) {
                    currentAutocompleteCallback(selectedItem);
                }
                closeModal();
                return;
            }

            const typedValue = (input.value || '').trim();
            if (typedValue.length > 0) {
                const exactMatch = filteredItems.find(item =>
                    item.toLowerCase() === typedValue.toLowerCase()
                );

                if (exactMatch && currentAutocompleteCallback) {
                    currentAutocompleteCallback(exactMatch);
                    closeModal();
                    return;
                }
            }

            alert('Please select a valid option from the list.');
        }

        function closeModal() {
            const modal = document.getElementById('autocompleteModal');
            const input = document.getElementById('autocompleteInput');
            const list = document.getElementById('autocompleteList');
            const confirmBtn = document.getElementById('confirmBtn');
            const cancelBtn = document.getElementById('cancelBtn');
            const container = document.querySelector('.autocomplete-container');
            const modalDescription = document.getElementById('modalDescription');
            const managementContainer = document.getElementById('managementActionContainer');

            modal.style.display = 'none';
            input.value = '';
            input.placeholder = DEFAULT_PLACEHOLDER;
            input.style.display = 'block';

            list.innerHTML = '';
            list.style.display = 'none';
            list.classList.remove('autocomplete-list--grid');

            if (confirmBtn) {
                confirmBtn.textContent = DEFAULT_CONFIRM_LABEL;
                confirmBtn.style.display = 'inline-block';
            }

            if (cancelBtn) {
                cancelBtn.textContent = DEFAULT_CANCEL_LABEL;
            }

            if (container) {
                container.style.display = 'block';
                container.classList.remove('autocomplete-container--static');
            }

            if (modalDescription) {
                modalDescription.textContent = '';
                modalDescription.style.display = 'none';
            }

            if (managementContainer) {
                managementContainer.innerHTML = '';
                managementContainer.style.display = 'none';
            }

            currentAutocompleteCallback = null;
            selectedIndex = -1;
            filteredItems = [];
            currentDisplayedItems = [];
            currentAutocompleteOptions = {};

            // Small delay to ensure modal is fully closed before next operation
        }

        // Get available (unallocated) subjects
        function getAvailableSubjects() {
            const allocatedSubjects = new Set(flattenAllocatedSubjects());
            return subjects.filter(subject => {
                if (subjectSplits[subject]) {
                    return false;
                }
                return !allocatedSubjects.has(subject);
            });
        }

        // Get allocated subjects with their current teacher
        function getAllocatedSubjects() {
            const allocatedList = [];
            Object.entries(allocations).forEach(([key, value]) => {
                const parsed = parseAllocationKey(key);
                if (!parsed) {
                    delete allocations[key];
                    return;
                }

                const subjectList = Array.isArray(value) ? value : [value];
                const teacherName = Array.isArray(teachers) && teachers[parsed.teacherIndex] !== undefined
                    ? teachers[parsed.teacherIndex]
                    : `Teacher ${parsed.teacherIndex + 1}`;
                const lineLabel = Array.isArray(lines) && lines[parsed.lineIndex] !== undefined
                    ? lines[parsed.lineIndex]
                    : `Line ${parsed.lineIndex + 1}`;

                subjectList.forEach(subject => {
                    allocatedList.push({
                        subject: subject,
                        teacher: teacherName,
                        teacherIndex: parsed.teacherIndex,
                        line: lineLabel,
                        lineIndex: parsed.lineIndex
                    });
                });
            });
            return allocatedList;
        }

        // Allocate new subject code
        function allocateNewSubject() {
            if (subjects.length === 0) {
                alert('Please import spreadsheet data first!');
                return;
            }

            const availableSubjects = getAvailableSubjects();
            if (availableSubjects.length === 0) {
                alert('No available subject codes to allocate!');
                return;
            }

            // Show subject code autocomplete
            showAutocomplete('Select Subject Code', availableSubjects, function(selectedSubject) {
                // Show teacher autocomplete with a small delay
                setTimeout(() => {
                    showAutocomplete('Select Teacher for ' + selectedSubject, teachers, function(selectedTeacher) {
                        const teacherIndex = teachers.indexOf(selectedTeacher);
                        const allocationSucceeded = allocateSubjectToTeacher(selectedSubject, teacherIndex);

                        if (allocationSucceeded) {
                            alert('Subject ' + selectedSubject + ' allocated to ' + selectedTeacher + ' successfully!');
                        } else if (!wasLastAllocationBlockedByClash()) {
                            alert('Unable to allocate this subject to the selected teacher.');
                        }
                    });
                }, 200); // 200ms delay to ensure first modal is fully closed
            });
        }

        async function configureSplitForSubject(baseSubject) {
            if (!baseSubject) {
                alert('Invalid subject selection.');
                return;
            }

            const existingLocation = findSubjectLocation(baseSubject);
            if (existingLocation) {
                alert('Please remove this subject from the timetable before splitting it.');
                return;
            }

            const existingSplits = subjectSplits[baseSubject] || [];
            const activeSplit = existingSplits.find(split => findSubjectLocation(split.code));
            if (activeSplit) {
                alert('Please remove all allocated split portions for this subject before changing the split.');
                return;
            }

            const totalPeriods = getSubjectPeriodValue(baseSubject);
            if (!Number.isFinite(totalPeriods) || totalPeriods <= 0) {
                alert('Unable to determine the period value for the selected subject.');
                return;
            }

            const input = await showAppPrompt(`Enter the number of periods for each portion of ${baseSubject} (total ${totalPeriods} periods). Separate values with commas, e.g. 4,3.`, {
                confirmLabel: 'Split subject',
                cancelLabel: 'Cancel',
                placeholder: 'e.g. 4,3'
            });
            if (input === null) {
                return;
            }

            const sanitized = input.replace(/\+/g, ',');
            const splitValues = sanitized
                .split(',')
                .map(value => parseInt(value.trim(), 10))
                .filter(value => Number.isFinite(value) && value > 0);

            if (splitValues.length === 0) {
                alert('Please enter at least one positive number.');
                return;
            }

            const sum = splitValues.reduce((acc, value) => acc + value, 0);
            if (sum !== totalPeriods) {
                alert(`The split values must add up to ${totalPeriods} periods. Currently they add up to ${sum}.`);
                return;
            }

            const existingSplitCodes = new Set(existingSplits.map(split => split.code));
            const removalSet = new Set(existingSplitCodes);
            removalSet.add(baseSubject);

            let insertIndex = subjects.findIndex(subject => removalSet.has(subject));
            if (insertIndex === -1 && existingSplits.length > 0) {
                const firstExistingSplitIndex = subjects.findIndex(subject => existingSplitCodes.has(subject));
                if (firstExistingSplitIndex !== -1) {
                    insertIndex = firstExistingSplitIndex;
                }
            }
            if (insertIndex === -1) {
                insertIndex = subjects.length;
            }

            subjects = subjects.filter(subject => !removalSet.has(subject));

            existingSplits.forEach(split => {
                if (split && typeof split.code === 'string') {
                    delete subjectLineMapping[split.code];
                    delete subjectYearMapping[split.code];
                }
            });

            const mappedLine = subjectLineMapping[baseSubject];
            const baseYearLabel = subjectYearMapping[baseSubject] || deriveYearLabelFromCode(baseSubject);

            if (splitValues.length === 1 && splitValues[0] === totalPeriods) {
                delete subjectSplits[baseSubject];
                rebuildSplitLookup();

                subjects.splice(insertIndex, 0, baseSubject);

                if (mappedLine !== undefined) {
                    setLineMappingForCode(baseSubject, mappedLine);
                }

                if (baseYearLabel) {
                    setYearMappingForCode(baseSubject, baseYearLabel);
                }

                removalSet.forEach(subject => removeSubjectFromPool(subject));

                createSubjectPool();
                updateStats();

                alert(`${baseSubject} has been restored to a single ${totalPeriods}-period allocation.`);
                return;
            }

            removeParentSubjectReferences(baseSubject);

            const totalSplits = splitValues.length;
            const newSplits = splitValues.map((periods, index) => {
                const code = `${baseSubject}  ${periods}p (Split ${index + 1}/${totalSplits})`;
                return {
                    code: code,
                    periods: periods,
                    index: index,
                    totalSplits: totalSplits
                };
            });

            subjectSplits[baseSubject] = newSplits;
            rebuildSplitLookup();

            const newCodes = newSplits.map(split => split.code);
            subjects.splice(insertIndex, 0, ...newCodes);

            if (mappedLine !== undefined) {
                newSplits.forEach(split => setLineMappingForCode(split.code, mappedLine));
            }

            if (baseYearLabel) {
                newSplits.forEach(split => setYearMappingForCode(split.code, baseYearLabel));
            }

            removalSet.forEach(subject => removeSubjectFromPool(subject));

            createSubjectPool();
            updateStats();

            alert(`Created ${newSplits.length} split allocation${newSplits.length === 1 ? '' : 's'} for ${baseSubject}.`);
        }

        function splitSubject() {
            if (subjects.length === 0) {
                alert('Please import spreadsheet data first!');
                return;
            }

            const labelToSubject = new Map();

            subjects.forEach(subject => {
                if (!isSplitSubject(subject) && !subjectSplits[subject]) {
                    labelToSubject.set(subject, subject);
                }
            });

            Object.keys(subjectSplits).forEach(baseSubject => {
                const label = `${baseSubject} (currently split)`;
                labelToSubject.set(label, baseSubject);
            });

            const labels = Array.from(labelToSubject.keys());

            if (labels.length === 0) {
                alert('No subjects are available to split at this time.');
                return;
            }

            showAutocomplete('Select subject to split', labels, function(selectedLabel) {
                const baseSubject = labelToSubject.get(selectedLabel);

                if (!baseSubject) {
                    alert('Invalid subject selection.');
                    return;
                }

                setTimeout(() => {
                    configureSplitForSubject(baseSubject).catch(error => {
                        console.error('Error configuring split for subject:', error);
                    });
                }, 200);
            });
        }

        // Move existing allocation between teachers
        function moveExistingAllocation() {
            const allocatedSubjects = getAllocatedSubjects();
            if (allocatedSubjects.length === 0) {
                alert('No allocated subjects to move!');
                return;
            }

            if (!Array.isArray(lines) || lines.length === 0) {
                alert('No timetable lines are available to move allocations.');
                return;
            }

            const subjectList = allocatedSubjects.map(item =>
                `${item.subject} (currently with ${item.teacher} on ${getLineSummaryLabel(item.lineIndex)})`
            );

            const lineLabelMap = new Map();
            const lineOptions = lines.map((lineName, index) => {
                const label = getLineSummaryLabel(index);
                lineLabelMap.set(label, index);
                return label;
            });

            if (lineOptions.length === 0) {
                alert('No timetable lines are available to move allocations.');
                return;
            }

            const selectTeacherForMove = (allocation, targetLineIndex) => {
                if (!Array.isArray(teachers) || teachers.length === 0) {
                    alert('No teachers are available to receive this allocation.');
                    return;
                }

                showAutocomplete(`Move ${allocation.subject} to which teacher?`, teachers, function(selectedTeacher) {
                    const newTeacherIndex = teachers.indexOf(selectedTeacher);
                    if (newTeacherIndex === -1) {
                        alert('Teacher selection not recognized.');
                        return;
                    }

                    if (newTeacherIndex === allocation.teacherIndex && targetLineIndex === allocation.lineIndex) {
                        alert(`${allocation.subject} is already allocated to ${selectedTeacher} on ${getLineSummaryLabel(targetLineIndex)}.`);
                        return;
                    }

                    const allocationSucceeded = allocateSubjectToTeacher(
                        allocation.subject,
                        newTeacherIndex,
                        targetLineIndex
                    );

                    if (allocationSucceeded) {
                        applyLineMappingToSubject(allocation.subject, targetLineIndex);
                        const originLine = getLineSummaryLabel(allocation.lineIndex);
                        const destinationLine = getLineSummaryLabel(targetLineIndex);
                        alert(`${allocation.subject} moved from ${allocation.teacher} on ${originLine} to ${selectedTeacher} on ${destinationLine} successfully!`);
                    } else if (!wasLastAllocationBlockedByClash()) {
                        alert(`${allocation.subject} is already allocated to ${selectedTeacher} on ${getLineSummaryLabel(targetLineIndex)}.`);
                    }
                }, {
                    showListOnOpen: true,
                    description: 'Select the teacher who should receive this subject.'
                });
            };

            // Show subject selection autocomplete
            showAutocomplete('Select Subject to Move', subjectList, function(selectedSubjectText) {
                // Find the allocation
                const allocation = allocatedSubjects.find(item => selectedSubjectText.includes(item.subject));
                if (!allocation) {
                    alert('Subject allocation not found!');
                    return;
                }

                setTimeout(() => {
                    showAutocomplete(`Move ${allocation.subject}: choose new line`, lineOptions, function(selectedLineLabel) {
                        const newLineIndex = lineLabelMap.get(selectedLineLabel);
                        if (newLineIndex === undefined) {
                            alert('Line selection not recognized.');
                            return;
                        }

                        setTimeout(() => selectTeacherForMove(allocation, newLineIndex), 200);
                    }, {
                        showListOnOpen: true,
                        description: 'Select the timetable line that should contain this subject allocation.'
                    });
                }, 200); // Delay ensures the subject modal fully closes before opening the next step
            });
        }

        function getLineSummaryLabel(index) {
            const fallbackIndex = Number.isFinite(index) ? Math.trunc(index) + 1 : null;

            if (!Array.isArray(lines) || lines.length === 0) {
                return fallbackIndex ? `Line ${fallbackIndex}` : 'Line ?';
            }

            if (!Number.isInteger(index) || index < 0 || index >= lines.length) {
                return fallbackIndex ? `Line ${fallbackIndex}` : 'Line ?';
            }

            const name = typeof lines[index] === 'string' ? lines[index].trim() : '';
            return name.length > 0 ? `Line ${index + 1}  ${name}` : `Line ${index + 1}`;
        }

        // Function to record actions for undo functionality
        function recordAction(actionType, subjectCode, fromTeacher, toTeacher, lineIndex, fromLineIndex = null, previousMapping = null, previousMappingExists = false) {
            actionHistory.push({
                type: actionType,
                subject: subjectCode,
                fromTeacher: fromTeacher,
                toTeacher: toTeacher,
                lineIndex: lineIndex,
                fromLineIndex: fromLineIndex,
                previousMapping: previousMapping,
                previousMappingExists: Boolean(previousMappingExists),
                timestamp: Date.now()
            });

            if (actionHistory.length > 10) {
                actionHistory.shift();
            }

            const undoBtn = document.getElementById('undoBtn');
            if (undoBtn) {
                undoBtn.disabled = actionHistory.length === 0;
            }

            redoStack = [];
            const redoBtn = document.getElementById('redoBtn');
            if (redoBtn) {
                redoBtn.disabled = true;
            }

            console.log('Action recorded:', actionHistory[actionHistory.length - 1]);
        }

        function closeClashModal() {
            const modal = document.getElementById('clashModal');
            if (modal) {
                modal.style.display = 'none';
            }

            const messageContainer = document.getElementById('clashModalMessage');
            if (messageContainer) {
                messageContainer.innerHTML = '';
            }

            pendingClashContext = null;
        }

        function handleClashCancel() {
            const context = pendingClashContext;
            closeClashModal();

            if (context && typeof context.onCancel === 'function') {
                try {
                    context.onCancel();
                } catch (error) {
                    console.error('Error handling clash cancel callback:', error);
                }
            }
        }

        function showClashResolutionDialog(config) {
            const variant = config && config.variant === 'room' ? 'room' : 'subject';
            const teacherIndex = config.teacherIndex;
            const lineIndex = config.lineIndex;
            const subjectCode = config.subjectCode;

            const teacherName = typeof teachers[teacherIndex] === 'string' && teachers[teacherIndex].trim().length > 0
                ? teachers[teacherIndex].trim()
                : `Teacher ${teacherIndex + 1}`;

            const lineName = typeof lines[lineIndex] === 'string' && lines[lineIndex].trim().length > 0
                ? lines[lineIndex].trim()
                : `Line ${lineIndex + 1}`;

            if (typeof window.showAppDialog === 'function') {
                const existingSubjectsList = Array.isArray(config.existingSubjects)
                    ? config.existingSubjects
                    : [];
                const rooms = Array.isArray(config.rooms) ? config.rooms : [];
                const conflicts = Array.isArray(config.conflicts) ? config.conflicts : [];

                const messageParts = [];

                if (variant === 'room') {
                    if (rooms.length > 0) {
                        const roomLabel = rooms.length === 1 ? 'room' : 'rooms';
                        messageParts.push(`Allocating ${subjectCode} to ${teacherName} on ${lineName} will reuse ${roomLabel} ${rooms.join(', ')} already allocated on this line.`);
                    } else {
                        messageParts.push(`Allocating ${subjectCode} to ${teacherName} on ${lineName} will reuse rooms already allocated on this line.`);
                    }

                    if (conflicts.length > 0) {
                        const conflictLines = conflicts.map(conflict => {
                            const conflictRooms = Array.isArray(conflict.rooms) && conflict.rooms.length > 0
                                ? ` (${conflict.rooms.join(', ')})`
                                : '';
                            const teacherNameText = typeof conflict.teacherName === 'string' && conflict.teacherName.trim().length > 0
                                ? conflict.teacherName.trim()
                                : 'Unknown teacher';
                            const subjectText = typeof conflict.subjectCode === 'string' && conflict.subjectCode.trim().length > 0
                                ? conflict.subjectCode.trim()
                                : 'Unknown subject';
                            return ` ${teacherNameText}: ${subjectText}${conflictRooms}`;
                        });
                        const allocationLabel = conflicts.length === 1 ? 'Existing allocation using these rooms:' : 'Existing allocations using these rooms:';
                        messageParts.push(allocationLabel + '\n' + conflictLines.join('\n'));
                    }

                    messageParts.push('Continue keeps the shared rooms. Change rooms lets you adjust this allocation now. Divide subject configures a split allocation. Cancel will stop this allocation.');
                } else {
                    messageParts.push(`Allocating ${subjectCode} to ${teacherName} on ${lineName} will clash with an existing allocation.`);

                    if (existingSubjectsList.length > 0) {
                        const subjectLines = existingSubjectsList.map(subject => ` ${subject}`);
                        messageParts.push('Existing subject(s) in this cell:\n' + subjectLines.join('\n'));
                    }

                    messageParts.push('Proceed keeps all subjects and records the clash. Replace removes the existing subject(s) before allocating the new one. Cancel will stop this allocation.');
                }

                const message = messageParts.join('\n\n');

                const actions = [];
                actions.push({
                    label: variant === 'room'
                        ? (config.proceedLabel || 'Continue')
                        : (config.proceedLabel || 'Proceed'),
                    value: 'proceed',
                    variant: 'primary',
                    role: 'primary',
                    focus: true
                });

                if (variant === 'room') {
                    if (typeof config.onChange === 'function') {
                        actions.push({
                            label: config.changeLabel || 'Change rooms',
                            value: 'change',
                            variant: 'secondary',
                            role: 'option'
                        });
                    }

                    if (typeof config.onDivide === 'function') {
                        actions.push({
                            label: config.divideLabel || 'Divide subject',
                            value: 'divide',
                            variant: 'secondary',
                            role: 'option'
                        });
                    }
                } else if (typeof config.onReplace === 'function') {
                    actions.push({
                        label: config.replaceLabel || 'Replace',
                        value: 'replace',
                        variant: 'danger',
                        role: 'option'
                    });
                }

                actions.push({
                    label: config.cancelLabel || 'Cancel',
                    value: 'cancel',
                    variant: 'secondary',
                    role: 'cancel'
                });

                window.showAppDialog(message, {
                    title: variant === 'room' ? 'Room clash detected' : 'Allocation clash detected',
                    icon: '',
                    actions: actions,
                    dismissValue: 'cancel'
                }).then(choice => {
                    const callSafely = (callback, errorLabel) => {
                        if (typeof callback !== 'function') {
                            return;
                        }
                        try {
                            callback();
                        } catch (error) {
                            console.error(errorLabel, error);
                        }
                    };

                    switch (choice) {
                        case 'proceed':
                            callSafely(config.onProceed, 'Error handling clash proceed callback:');
                            break;
                        case 'replace':
                            callSafely(config.onReplace, 'Error handling clash replace callback:');
                            break;
                        case 'change':
                            callSafely(config.onChange, 'Error handling room clash change callback:');
                            break;
                        case 'divide':
                            callSafely(config.onDivide, 'Error handling room clash divide callback:');
                            break;
                        default:
                            callSafely(config.onCancel, 'Error handling clash cancel callback:');
                            break;
                    }
                }).catch(error => {
                    console.error('Unable to present clash dialog:', error);
                    if (typeof config.onCancel === 'function') {
                        try {
                            config.onCancel();
                        } catch (cancelError) {
                            console.error('Error handling clash cancel callback:', cancelError);
                        }
                    }
                });

                pendingClashContext = null;
                return;
            }

            const modal = document.getElementById('clashModal');
            const title = document.getElementById('clashModalTitle');
            const messageContainer = document.getElementById('clashModalMessage');
            const proceedBtn = document.getElementById('clashProceedBtn');
            const cancelBtn = document.getElementById('clashCancelBtn');
            const replaceBtn = document.getElementById('clashReplaceBtn');
            const changeBtn = document.getElementById('clashChangeBtn');
            const divideBtn = document.getElementById('clashDivideBtn');

            if (!modal || !title || !messageContainer || !proceedBtn || !cancelBtn || !replaceBtn || (variant === 'room' && (!changeBtn || !divideBtn))) {
                const rooms = Array.isArray(config.rooms) && config.rooms.length > 0
                    ? config.rooms.join(', ')
                    : null;
                const continuationText = variant === 'room'
                    ? rooms
                        ? ` will reuse room${config.rooms.length === 1 ? '' : 's'} ${rooms} already allocated on this line. Continue?`
                        : ' will reuse rooms already allocated on this line. Continue?'
                    : ' will clash with an existing subject. Continue?';
                const confirmationMessage = `Allocating ${subjectCode} to ${teacherName} on ${lineName}${continuationText}`;
                showAppConfirm(confirmationMessage, {
                    confirmLabel: 'Continue',
                    cancelLabel: 'Cancel'
                }).then(confirmed => {
                    if (confirmed) {
                        if (typeof config.onProceed === 'function') {
                            config.onProceed();
                        }
                    } else if (typeof config.onCancel === 'function') {
                        config.onCancel();
                    }
                });
                return;
            }

            const existingSubjects = Array.isArray(config.existingSubjects)
                ? config.existingSubjects
                : [];

            messageContainer.innerHTML = '';

            if (variant === 'room') {
                title.textContent = 'Room clash detected';

                const lead = document.createElement('p');
                lead.className = 'modal-message__lead';
                lead.append('Allocating ');
                const subjectStrong = document.createElement('strong');
                subjectStrong.textContent = subjectCode;
                lead.appendChild(subjectStrong);
                lead.append(' to ');
                const teacherStrong = document.createElement('strong');
                teacherStrong.textContent = teacherName;
                lead.appendChild(teacherStrong);
                lead.append(' on ');
                const lineStrong = document.createElement('strong');
                lineStrong.textContent = lineName;
                lead.appendChild(lineStrong);

                const rooms = Array.isArray(config.rooms) ? config.rooms.filter(room => typeof room === 'string' && room.trim().length > 0) : [];
                if (rooms.length > 0) {
                    lead.append(' will reuse room');
                    if (rooms.length > 1) {
                        lead.append('s ');
                    } else {
                        lead.append(' ');
                    }
                    const roomsStrong = document.createElement('strong');
                    roomsStrong.textContent = rooms.join(', ');
                    lead.appendChild(roomsStrong);
                    lead.append(' already allocated on this line.');
                } else {
                    lead.append(' will reuse rooms already allocated on this line.');
                }
                messageContainer.appendChild(lead);

                const conflicts = Array.isArray(config.conflicts) ? config.conflicts : [];
                if (conflicts.length > 0) {
                    const intro = document.createElement('p');
                    intro.textContent = conflicts.length === 1
                        ? 'Existing allocation using these rooms:'
                        : 'Existing allocations using these rooms:';
                    messageContainer.appendChild(intro);

                    const list = document.createElement('ul');
                    conflicts.forEach(conflict => {
                        const item = document.createElement('li');
                        const conflictRooms = Array.isArray(conflict.rooms) && conflict.rooms.length > 0
                            ? conflict.rooms.join(', ')
                            : 'No room set';
                        const conflictSubject = typeof conflict.subjectCode === 'string' && conflict.subjectCode.trim().length > 0
                            ? conflict.subjectCode.trim()
                            : 'Unknown subject';
                        const conflictTeacher = typeof conflict.teacherName === 'string' && conflict.teacherName.trim().length > 0
                            ? conflict.teacherName.trim()
                            : 'Unknown teacher';
                        item.textContent = `${conflictRooms}  ${conflictSubject} (${conflictTeacher})`;
                        list.appendChild(item);
                    });
                    messageContainer.appendChild(list);
                }

                const note = document.createElement('p');
                note.className = 'modal-message__note';
                note.textContent = 'Continue keeps the shared rooms. Change rooms lets you adjust this allocation now. Divide subject configures a split allocation. Cancel will stop this allocation.';
                messageContainer.appendChild(note);
            } else {
                title.textContent = 'Allocation clash detected';

                const lead = document.createElement('p');
                lead.className = 'modal-message__lead';
                lead.append('Adding ');
                const subjectStrong = document.createElement('strong');
                subjectStrong.textContent = subjectCode;
                lead.appendChild(subjectStrong);
                lead.append(' to ');
                const teacherStrong = document.createElement('strong');
                teacherStrong.textContent = teacherName;
                lead.appendChild(teacherStrong);
                lead.append(' on ');
                const lineStrong = document.createElement('strong');
                lineStrong.textContent = lineName;
                lead.appendChild(lineStrong);
                lead.append(' will clash with an existing allocation.');
                messageContainer.appendChild(lead);

                if (existingSubjects.length > 0) {
                    const intro = document.createElement('p');
                    intro.textContent = 'Existing subject(s) in this cell:';
                    messageContainer.appendChild(intro);

                    const list = document.createElement('ul');
                    existingSubjects.forEach(subject => {
                        const item = document.createElement('li');
                        item.textContent = subject;
                        list.appendChild(item);
                    });
                    messageContainer.appendChild(list);
                }

                const note = document.createElement('p');
                note.className = 'modal-message__note';
                note.textContent = 'Proceed keeps all subjects and records the clash. Replace removes the existing subject(s) before allocating the new one. Cancel will stop this allocation.';
                messageContainer.appendChild(note);
            }

            proceedBtn.textContent = variant === 'room'
                ? (config.proceedLabel || 'Continue')
                : (config.proceedLabel || 'Proceed');
            cancelBtn.textContent = config.cancelLabel || 'Cancel';

            if (variant === 'room') {
                replaceBtn.classList.add('is-hidden');
                if (changeBtn) {
                    changeBtn.classList.remove('is-hidden');
                    changeBtn.textContent = config.changeLabel || 'Change rooms';
                }
                if (divideBtn) {
                    divideBtn.classList.remove('is-hidden');
                    divideBtn.textContent = config.divideLabel || 'Divide subject';
                }
            } else {
                replaceBtn.classList.remove('is-hidden');
                replaceBtn.textContent = config.replaceLabel || 'Replace';
                if (changeBtn) {
                    changeBtn.classList.add('is-hidden');
                }
                if (divideBtn) {
                    divideBtn.classList.add('is-hidden');
                }
            }

            pendingClashContext = {
                variant: variant,
                onProceed: config.onProceed,
                onCancel: config.onCancel
            };

            if (variant === 'room') {
                pendingClashContext.onChange = config.onChange;
                pendingClashContext.onDivide = config.onDivide;
            } else {
                pendingClashContext.onReplace = config.onReplace;
            }

            modal.style.display = 'block';

            setTimeout(() => {
                try {
                    proceedBtn.focus();
                } catch (error) {
                    console.error('Unable to focus clash proceed button:', error);
                }
            }, 0);
        }

        function setupClashModalEventListeners() {
            const modal = document.getElementById('clashModal');
            if (!modal) {
                return;
            }

            const proceedBtn = document.getElementById('clashProceedBtn');
            const cancelBtn = document.getElementById('clashCancelBtn');
            const replaceBtn = document.getElementById('clashReplaceBtn');
            const changeBtn = document.getElementById('clashChangeBtn');
            const divideBtn = document.getElementById('clashDivideBtn');
            const closeBtn = document.getElementById('clashModalClose');
            const modalContent = modal.querySelector('.modal-content');

            if (proceedBtn) {
                proceedBtn.addEventListener('click', function() {
                    const context = pendingClashContext;
                    closeClashModal();
                    if (context && typeof context.onProceed === 'function') {
                        try {
                            context.onProceed();
                        } catch (error) {
                            console.error('Error handling clash proceed callback:', error);
                        }
                    }
                });
            }

            if (replaceBtn) {
                replaceBtn.addEventListener('click', function() {
                    const context = pendingClashContext;
                    closeClashModal();
                    if (context && typeof context.onReplace === 'function') {
                        try {
                            context.onReplace();
                        } catch (error) {
                            console.error('Error handling clash replace callback:', error);
                        }
                    }
                });
            }

            if (changeBtn) {
                changeBtn.addEventListener('click', function() {
                    const context = pendingClashContext;
                    closeClashModal();
                    if (context && typeof context.onChange === 'function') {
                        try {
                            context.onChange();
                        } catch (error) {
                            console.error('Error handling clash change callback:', error);
                        }
                    }
                });
            }

            if (divideBtn) {
                divideBtn.addEventListener('click', function() {
                    const context = pendingClashContext;
                    closeClashModal();
                    if (context && typeof context.onDivide === 'function') {
                        try {
                            context.onDivide();
                        } catch (error) {
                            console.error('Error handling clash divide callback:', error);
                        }
                    }
                });
            }

            if (cancelBtn) {
                cancelBtn.addEventListener('click', handleClashCancel);
            }

            if (closeBtn) {
                closeBtn.addEventListener('click', handleClashCancel);
            }

            modal.addEventListener('click', function(event) {
                if (event.target === modal) {
                    handleClashCancel();
                }
            });

            if (modalContent) {
                modalContent.addEventListener('keydown', function(event) {
                    if (event.key === 'Escape') {
                        event.preventDefault();
                        handleClashCancel();
                    }
                });
            }
        }

        function evaluateRoomClashForAllocation(subjectCode, lineIndex, teacherIndex) {
            const effectiveAssignments = getEffectiveRoomAssignmentsForCell(subjectCode, lineIndex, teacherIndex);
            const rooms = getUniqueRoomsFromEntries(effectiveAssignments);

            if (rooms.length === 0) {
                return { rooms: [], conflicts: [] };
            }

            const roomSet = new Set(rooms);
            const normalizedTargetSubject = normalizeSubjectCode(subjectCode);
            const conflicts = [];

            const addConflictsForTeacher = (lineIdx, targetTeacherIndex) => {
                if (!Number.isInteger(targetTeacherIndex) || targetTeacherIndex < 0 || targetTeacherIndex >= teachers.length) {
                    return;
                }

                const otherSubjects = getAllocationSubjects(getAllocationKey(lineIdx, targetTeacherIndex));
                if (!Array.isArray(otherSubjects) || otherSubjects.length === 0) {
                    return;
                }

                otherSubjects.forEach(existingSubject => {
                    if (!existingSubject) {
                        return;
                    }

                    const normalizedExisting = normalizeSubjectCode(existingSubject);
                    if (targetTeacherIndex === teacherIndex && normalizedExisting === normalizedTargetSubject) {
                        return;
                    }

                    const entries = getEffectiveRoomAssignmentsForCell(existingSubject, lineIdx, targetTeacherIndex);
                    const otherRooms = getUniqueRoomsFromEntries(entries);
                    const overlap = otherRooms.filter(room => roomSet.has(room));

                    if (overlap.length === 0) {
                        return;
                    }

                    const teacherName = typeof teachers[targetTeacherIndex] === 'string' && teachers[targetTeacherIndex].trim().length > 0
                        ? teachers[targetTeacherIndex].trim()
                        : `Teacher ${targetTeacherIndex + 1}`;

                    conflicts.push({
                        teacherIndex: targetTeacherIndex,
                        teacherName: teacherName,
                        subjectCode: existingSubject,
                        rooms: Array.from(new Set(overlap))
                    });
                });
            };

            addConflictsForTeacher(lineIndex, teacherIndex);

            teachers.forEach((_, otherTeacherIndex) => {
                if (otherTeacherIndex === teacherIndex) {
                    return;
                }
                addConflictsForTeacher(lineIndex, otherTeacherIndex);
            });

            return { rooms, conflicts };
        }

        function allocateSubjectToTeacher(subjectCode, teacherIndex, preferredLine = null, options = {}) {
            lastAllocationOutcome = { status: 'failure', reason: 'unknown' };

            if (teacherIndex < 0 || teacherIndex >= teachers.length) {
                lastAllocationOutcome = { status: 'failure', reason: 'invalid-teacher' };
                return false;
            }

            const normalizedSubjectCode = normalizeSubjectCode(subjectCode);
            const effectiveSubjectCode = normalizedSubjectCode || subjectCode;

            let targetLine = preferredLine;

            if (targetLine === null && subjectLineMapping[effectiveSubjectCode] !== undefined) {
                targetLine = subjectLineMapping[effectiveSubjectCode];
                console.log(`Subject ${subjectCode} must stay in Line ${targetLine + 1}`);
            }

            if (targetLine === null) {
                const teacherCells = document.querySelectorAll(`[data-teacher="${teacherIndex}"]`);
                if (teacherCells.length === 0) {
                    lastAllocationOutcome = { status: 'failure', reason: 'no-available-cells' };
                    return false;
                }
                targetLine = parseInt(teacherCells[0].dataset.period, 10);
            }

            const cell = document.querySelector(`[data-period="${targetLine}"][data-teacher="${teacherIndex}"]`);
            if (!cell) {
                lastAllocationOutcome = { status: 'failure', reason: 'cell-not-found' };
                return false;
            }

            const key = getAllocationKey(targetLine, teacherIndex);
            let currentSubjects = getAllocationSubjects(key);
            if (currentSubjects.includes(effectiveSubjectCode)) {
                lastAllocationOutcome = { status: 'failure', reason: 'duplicate' };
                return false;
            }

            const prospectiveSubjects = [...currentSubjects, effectiveSubjectCode];
            const clashAction = typeof options.clashAction === 'string' ? options.clashAction : null;
            const statusIfAllocated = determineCellStatus(prospectiveSubjects);

            if (statusIfAllocated === 'clash' && clashAction !== 'proceed' && clashAction !== 'replace') {
                showClashResolutionDialog({
                    subjectCode: subjectCode,
                    teacherIndex: teacherIndex,
                    lineIndex: targetLine,
                    existingSubjects: currentSubjects,
                    onProceed: () => {
                        allocateSubjectToTeacher(subjectCode, teacherIndex, targetLine, { ...options, clashAction: 'proceed' });
                    },
                    onReplace: () => {
                        allocateSubjectToTeacher(subjectCode, teacherIndex, targetLine, { ...options, clashAction: 'replace' });
                    },
                    onCancel: options.onClashCancelled
                });
                lastAllocationOutcome = { status: 'clash', reason: 'pending-resolution' };
                return false;
            }

            const roomClashAction = typeof options.roomClashAction === 'string' ? options.roomClashAction : null;
            const roomClashDetails = evaluateRoomClashForAllocation(effectiveSubjectCode, targetLine, teacherIndex);
            if (roomClashDetails.conflicts.length > 0 && roomClashAction !== 'continue') {
                const onRoomClashCancelled = typeof options.onRoomClashCancelled === 'function'
                    ? options.onRoomClashCancelled
                    : options.onClashCancelled;

                showClashResolutionDialog({
                    variant: 'room',
                    subjectCode: subjectCode,
                    teacherIndex: teacherIndex,
                    lineIndex: targetLine,
                    rooms: roomClashDetails.rooms,
                    conflicts: roomClashDetails.conflicts,
                    onProceed: () => {
                        allocateSubjectToTeacher(subjectCode, teacherIndex, targetLine, { ...options, roomClashAction: 'continue' });
                    },
                    onChange: () => {
                        if (typeof options.onRoomClashChange === 'function') {
                            try {
                                options.onRoomClashChange();
                            } catch (error) {
                                console.error('Error handling room clash change callback:', error);
                            }
                        }
                        setTimeout(() => {
                            try {
                                openRoomModal({ subjectCode: subjectCode, mode: 'subject' });
                            } catch (error) {
                                console.error('Unable to open room editor from clash dialog:', error);
                            }
                        }, 0);
                    },
                    onDivide: () => {
                        const splitMetadata = getSplitMetadata(subjectCode);
                        const baseSubject = splitMetadata && splitMetadata.baseSubject ? splitMetadata.baseSubject : subjectCode;
                        setTimeout(() => {
                            configureSplitForSubject(baseSubject).catch(error => {
                                console.error('Error launching split configuration:', error);
                            });
                        }, 0);
                        if (typeof options.onRoomClashDivide === 'function') {
                            try {
                                options.onRoomClashDivide();
                            } catch (error) {
                                console.error('Error handling room clash divide callback:', error);
                            }
                        }
                    },
                    onCancel: () => {
                        if (typeof onRoomClashCancelled === 'function') {
                            onRoomClashCancelled();
                        }
                    }
                });

                lastAllocationOutcome = { status: 'clash', reason: 'room' };
                return false;
            }

            if (clashAction === 'replace' && currentSubjects.length > 0) {
                const subjectsToRemove = [...currentSubjects];
                subjectsToRemove.forEach(existingSubject => {
                    removeSubjectFromCell(targetLine, teacherIndex, existingSubject, true);
                });
            }

            currentSubjects = getAllocationSubjects(key);

            const existingLocation = findSubjectLocation(effectiveSubjectCode);
            const fromTeacher = existingLocation ? existingLocation.teacherIndex : null;
            const fromLineIndex = existingLocation ? existingLocation.lineIndex : null;
            const hadPreviousMapping = Object.prototype.hasOwnProperty.call(subjectLineMapping, effectiveSubjectCode);
            const previousMapping = hadPreviousMapping ? subjectLineMapping[effectiveSubjectCode] : null;

            if (existingLocation && existingLocation.lineIndex === targetLine && existingLocation.teacherIndex === teacherIndex) {
                renderCell(targetLine, teacherIndex);
                updateStats();
                lastAllocationOutcome = { status: 'success', reason: null };
                return true;
            }

            commitSubjectMove(
                effectiveSubjectCode,
                fromLineIndex,
                fromTeacher,
                targetLine,
                teacherIndex
            );

            renderCell(targetLine, teacherIndex);
            if (existingLocation && (existingLocation.lineIndex !== targetLine || existingLocation.teacherIndex !== teacherIndex)) {
                renderCell(existingLocation.lineIndex, existingLocation.teacherIndex);
            }

            removeSubjectFromPool(effectiveSubjectCode);

            if (options.recordAction !== false) {
                recordAction(
                    fromTeacher !== null ? 'move' : 'allocate',
                    effectiveSubjectCode,
                    fromTeacher,
                    teacherIndex,
                    targetLine,
                    fromLineIndex,
                    previousMapping,
                    hadPreviousMapping
                );
            }

            updateStats();
            lastAllocationOutcome = { status: 'success', reason: null };
            return true;
        }

        function wasLastAllocationBlockedByClash() {
            return lastAllocationOutcome && lastAllocationOutcome.status === 'clash';
        }

        // Undo functionality
        function undoLastAction() {
            if (actionHistory.length === 0) {
                alert('No actions to undo');
                return;
            }

            const lastAction = actionHistory.pop();
            console.log('Undoing action:', lastAction);

            let undone = false;

            if (lastAction.type === 'allocate') {
                const allocationKey = getAllocationKey(lastAction.lineIndex, lastAction.toTeacher);
                const remainingSubjects = getAllocationSubjects(allocationKey)
                    .filter(subject => subject !== lastAction.subject);
                setAllocationSubjects(allocationKey, remainingSubjects);

                if (lastAction.previousMappingExists) {
                    subjectLineMapping[lastAction.subject] = lastAction.previousMapping;
                } else {
                    delete subjectLineMapping[lastAction.subject];
                }

                renderCell(lastAction.lineIndex, lastAction.toTeacher);
                addSubjectToPool(lastAction.subject);
                if (IS_DEV_ENV) {
                    validateMappingAgainstAllocations();
                }
                undone = true;
            } else if (lastAction.type === 'move') {
                const originalLine = lastAction.fromLineIndex !== null ? lastAction.fromLineIndex : lastAction.lineIndex;

                if (lastAction.fromTeacher !== null && Number.isInteger(lastAction.fromTeacher)) {
                    commitSubjectMove(
                        lastAction.subject,
                        lastAction.lineIndex,
                        lastAction.toTeacher,
                        originalLine,
                        lastAction.fromTeacher
                    );

                    renderCell(lastAction.lineIndex, lastAction.toTeacher);
                    renderCell(originalLine, lastAction.fromTeacher);
                } else {
                    const currentKey = getAllocationKey(lastAction.lineIndex, lastAction.toTeacher);
                    const remainingSubjects = getAllocationSubjects(currentKey)
                        .filter(subject => subject !== lastAction.subject);
                    setAllocationSubjects(currentKey, remainingSubjects);
                    renderCell(lastAction.lineIndex, lastAction.toTeacher);
                }

                if (lastAction.previousMappingExists) {
                    subjectLineMapping[lastAction.subject] = lastAction.previousMapping;
                } else {
                    delete subjectLineMapping[lastAction.subject];
                }

                if (IS_DEV_ENV) {
                    validateMappingAgainstAllocations();
                }

                undone = true;
            }

            if (!undone) {
                actionHistory.push(lastAction);
                return;
            }

            redoStack.push(lastAction);
            if (redoStack.length > 10) {
                redoStack.shift();
            }

            const redoBtn = document.getElementById('redoBtn');
            if (redoBtn) {
                redoBtn.disabled = false;
            }

            updateStats();

            const undoBtn = document.getElementById('undoBtn');
            if (undoBtn) {
                undoBtn.disabled = actionHistory.length === 0;
            }
        }

        function redoLastAction() {
            if (redoStack.length === 0) {
                alert('No actions to redo');
                return;
            }

            const actionToRedo = redoStack.pop();
            console.log('Redoing action:', actionToRedo);

            let success = false;

            if (actionToRedo.type === 'allocate') {
                success = allocateSubjectToTeacher(actionToRedo.subject, actionToRedo.toTeacher, actionToRedo.lineIndex, {
                    recordAction: false,
                    clashAction: 'proceed'
                });
            } else if (actionToRedo.type === 'move') {
                success = allocateSubjectToTeacher(actionToRedo.subject, actionToRedo.toTeacher, actionToRedo.lineIndex, {
                    recordAction: false,
                    clashAction: 'proceed'
                });
            }

            if (!success) {
                redoStack.push(actionToRedo);
                alert('Unable to redo the last action.');
                return;
            }

            actionHistory.push(actionToRedo);
            if (actionHistory.length > 10) {
                actionHistory.shift();
            }

            const undoBtn = document.getElementById('undoBtn');
            if (undoBtn) {
                undoBtn.disabled = false;
            }

            if (redoStack.length === 0) {
                const redoBtn = document.getElementById('redoBtn');
                if (redoBtn) {
                    redoBtn.disabled = true;
                }
            }
        }

        function showAllocationPopup(lineIndex, teacherIndex) {
            if (subjects.length === 0) {
                alert('Please import spreadsheet data first!');
                return;
            }

            // Validate indices
            if (teacherIndex < 0 || teacherIndex >= teachers.length) {
                alert('Invalid teacher selection!');
                return;
            }
            if (lineIndex < 0 || lineIndex >= lines.length) {
                alert('Invalid line selection!');
                return;
            }

            const teacherName = teachers[teacherIndex];
            const lineName = lines[lineIndex];
            const availableSubjects = getAvailableSubjects();
            
            if (availableSubjects.length === 0) {
                alert('No available subject codes to allocate!');
                return;
            }

            // Show subject autocomplete
            showAutocomplete(`Allocate subject to ${teacherName} on ${lineName}`, availableSubjects, function(selectedSubject) {
                const allocationSucceeded = allocateSubjectToTeacher(selectedSubject, teacherIndex, lineIndex);

                if (!allocationSucceeded && !wasLastAllocationBlockedByClash()) {
                    alert('Unable to allocate ' + selectedSubject + ' to ' + teacherName + ' on ' + lineName + '.');
                }
            });
        }

        function openRoomAllocationManager() {
            const subjectSet = new Set();

            if (Array.isArray(subjects)) {
                subjects.forEach(subject => {
                    const normalized = normalizeSubjectCode(subject);
                    if (normalized) {
                        subjectSet.add(normalized);
                    }
                });
            }

            if (subjectSplits && typeof subjectSplits === 'object') {
                Object.keys(subjectSplits).forEach(baseSubject => {
                    const normalized = normalizeSubjectCode(baseSubject);
                    if (normalized) {
                        subjectSet.add(normalized);
                    }
                });
            }

            if (subjectRoomAssignments && typeof subjectRoomAssignments === 'object') {
                Object.keys(subjectRoomAssignments).forEach(subjectCode => {
                    const normalized = normalizeSubjectCode(subjectCode);
                    if (normalized) {
                        subjectSet.add(normalized);
                    }
                });
            }

            const options = Array.from(subjectSet).sort((a, b) => a.localeCompare(b, 'en', { numeric: true }));

            if (options.length === 0) {
                alert('No subjects are available to manage rooms.');
                return;
            }

            showAutocomplete('Select subject to manage rooms', options, function(selectedSubject) {
                if (!selectedSubject) {
                    return;
                }

                setTimeout(() => {
                    openRoomModal({ subjectCode: selectedSubject, mode: 'subject' });
                }, 200);
            }, {
                showListOnOpen: true,
                description: 'Choose a subject to assign default rooms or adjust existing room sets.',
                confirmLabel: 'Manage rooms',
                cancelLabel: 'Close'
            });
        }

        function closeRoomModal() {
            const modal = document.getElementById('roomModal');
            if (modal) {
                modal.style.display = 'none';
                modal.setAttribute('aria-hidden', 'true');
            }
            currentRoomModalContext = null;
        }

        function openRoomModal(config = {}) {
            const subjectCode = normalizeSubjectCode(config.subjectCode);
            if (!subjectCode) {
                alert('Invalid subject selected.');
                return;
            }

            const mode = config.mode === 'allocation' ? 'allocation' : 'subject';
            const lineIndex = Number.isInteger(config.lineIndex) ? config.lineIndex : null;
            const teacherIndex = Number.isInteger(config.teacherIndex) ? config.teacherIndex : null;
            const teacherName = Number.isInteger(teacherIndex) && teachers[teacherIndex]
                ? teachers[teacherIndex]
                : null;
            const lineName = Number.isInteger(lineIndex) && lines[lineIndex]
                ? lines[lineIndex]
                : null;

            const directEntries = getDirectSubjectRoomAssignments(subjectCode);
            const inheritedEntries = getInheritedSubjectRoomAssignments(subjectCode);
            const defaultEntries = getSubjectRoomAssignments(subjectCode);
            const overrideEntries = mode === 'allocation'
                ? getAllocationRoomAssignments(lineIndex, teacherIndex, subjectCode)
                : [];

            let editEntries = [];
            if (mode === 'allocation') {
                if (overrideEntries.length > 0) {
                    editEntries = cloneRoomEntries(overrideEntries);
                } else if (defaultEntries.length > 0) {
                    editEntries = cloneRoomEntries(defaultEntries);
                }
            } else if (directEntries.length > 0) {
                editEntries = cloneRoomEntries(directEntries);
            } else if (inheritedEntries.length > 0) {
                editEntries = cloneRoomEntries(inheritedEntries);
            }

            currentRoomModalContext = {
                subjectCode,
                mode,
                lineIndex,
                teacherIndex,
                teacherName,
                lineName,
                directEntries,
                inheritedEntries,
                defaultEntries,
                overrideEntries,
                editEntries: Array.isArray(editEntries) ? editEntries : []
            };

            renderRoomModal();

            const modal = document.getElementById('roomModal');
            if (modal) {
                modal.style.display = 'block';
                modal.setAttribute('aria-hidden', 'false');
                const modalContent = modal.querySelector('.modal-content');
                if (modalContent) {
                    modalContent.setAttribute('tabindex', '-1');
                    try {
                        modalContent.focus();
                    } catch (error) {
                        // Unable to focus; safe to ignore.
                    }
                }
            }
        }

        function renderRoomModal() {
            const context = currentRoomModalContext;
            const modal = document.getElementById('roomModal');
            if (!context || !modal) {
                return;
            }

            const { subjectCode, mode, teacherIndex, lineIndex, teacherName, lineName } = context;
            const titleEl = document.getElementById('roomModalTitle');
            if (titleEl) {
                titleEl.textContent = mode === 'allocation'
                    ? `Rooms  ${subjectCode}`
                    : `Rooms for ${subjectCode}`;
            }

            const summaryEl = document.getElementById('roomModalSummary');
            if (summaryEl) {
                const parts = [`Subject: ${subjectCode}`];
                const totalPeriods = getSubjectPeriodValue(subjectCode);
                if (Number.isFinite(totalPeriods) && totalPeriods > 0) {
                    parts.push(`${totalPeriods} period${totalPeriods === 1 ? '' : 's'}`);
                }
                if (mode === 'allocation') {
                    const teacherLabel = teacherName || (Number.isInteger(teacherIndex) ? `Teacher ${teacherIndex + 1}` : 'Teacher not set');
                    const lineLabel = lineName || (Number.isInteger(lineIndex) ? `Line ${lineIndex + 1}` : 'Line not set');
                    parts.push(`Teacher: ${teacherLabel}`);
                    parts.push(`Line: ${lineLabel}`);
                }
                summaryEl.textContent = parts.join('  ');
            }

            const infoEl = document.getElementById('roomModalInfo');
            if (infoEl) {
                let message = '';
                if (mode === 'allocation') {
                    if (context.overrideEntries.length > 0) {
                        message = 'This allocation currently uses custom rooms.';
                    } else if (context.defaultEntries.length > 0) {
                        message = 'This allocation inherits the subject default rooms.';
                    } else {
                        message = 'No rooms are defined for this subject yet.';
                    }
                } else if (context.directEntries.length > 0) {
                    message = 'These rooms apply directly to this subject.';
                } else if (context.inheritedEntries.length > 0) {
                    const metadata = getSplitMetadata(subjectCode);
                    const baseSubject = metadata && metadata.baseSubject ? metadata.baseSubject : null;
                    message = baseSubject
                        ? `Currently inheriting rooms from ${baseSubject}.`
                        : 'Currently inheriting rooms from a parent subject.';
                } else {
                    message = 'No rooms are stored for this subject yet.';
                }
                infoEl.textContent = message;
            }

            const hintEl = document.getElementById('roomModalHint');
            if (hintEl) {
                const totalPeriods = getSubjectPeriodValue(subjectCode);
                hintEl.textContent = Number.isFinite(totalPeriods) && totalPeriods > 0
                    ? `Subject total: ${totalPeriods} period${totalPeriods === 1 ? '' : 's'}.`
                    : '';
            }

            const contextActions = document.getElementById('roomModalContextActions');
            const copyBtn = document.getElementById('roomModalCopyDefaults');
            const shouldShowCopy = mode === 'allocation'
                ? (context.overrideEntries.length === 0 && context.defaultEntries.length > 0)
                : (context.directEntries.length === 0 && context.inheritedEntries.length > 0);
            if (contextActions && copyBtn) {
                contextActions.hidden = !shouldShowCopy;
                copyBtn.disabled = !shouldShowCopy;
            }

            const listEl = document.getElementById('roomModalList');
            if (listEl) {
                listEl.innerHTML = '';

                if (!Array.isArray(context.editEntries)) {
                    context.editEntries = [];
                } else {
                    context.editEntries = context.editEntries.filter((entry, index, array) => {
                        if (!isRoomEntryEmpty(entry)) {
                            return true;
                        }
                        return index === array.length - 1;
                    });
                }

                let ensureTrailingRow = () => {};

                const buildRow = (entry, index) => {
                    if (!context.editEntries[index] || typeof context.editEntries[index] !== 'object') {
                        context.editEntries[index] = createEmptyRoomEntry();
                    }

                    const row = document.createElement('div');
                    row.className = 'room-modal-row';

                    const roomSelect = document.createElement('select');
                    roomSelect.className = 'room-modal-room';
                    const defaultOption = document.createElement('option');
                    defaultOption.value = '';
                    defaultOption.textContent = 'Choose room';
                    roomSelect.appendChild(defaultOption);
                    AVAILABLE_ROOMS.forEach(room => {
                        const option = document.createElement('option');
                        option.value = room;
                        option.textContent = room;
                        roomSelect.appendChild(option);
                    });
                    roomSelect.value = typeof entry.room === 'string' ? entry.room : '';
                    roomSelect.addEventListener('change', event => {
                        context.editEntries[index].room = event.target.value;
                        ensureTrailingRow();
                    });
                    row.appendChild(roomSelect);

                    const periodsInput = document.createElement('input');
                    periodsInput.type = 'number';
                    periodsInput.min = '0';
                    periodsInput.step = '1';
                    periodsInput.className = 'room-modal-periods';
                    periodsInput.placeholder = 'Periods';
                    periodsInput.value = entry && entry.periods !== undefined && entry.periods !== null && entry.periods !== ''
                        ? entry.periods
                        : '';
                    periodsInput.addEventListener('input', event => {
                        context.editEntries[index].periods = event.target.value;
                        ensureTrailingRow();
                    });
                    row.appendChild(periodsInput);

                    const noteInput = document.createElement('input');
                    noteInput.type = 'text';
                    noteInput.className = 'room-modal-note';
                    noteInput.placeholder = 'Note (optional)';
                    noteInput.value = entry && typeof entry.label === 'string' ? entry.label : '';
                    noteInput.addEventListener('input', event => {
                        context.editEntries[index].label = event.target.value;
                        ensureTrailingRow();
                    });
                    row.appendChild(noteInput);

                    const removeBtn = document.createElement('button');
                    removeBtn.type = 'button';
                    removeBtn.className = 'room-modal-remove';
                    removeBtn.textContent = 'Remove';
                    removeBtn.addEventListener('click', () => {
                        context.editEntries.splice(index, 1);
                        renderRoomModal();
                    });
                    row.appendChild(removeBtn);

                    return row;
                };

                ensureTrailingRow = () => {
                    if (context.editEntries.length === 0 || !isRoomEntryEmpty(context.editEntries[context.editEntries.length - 1])) {
                        const newIndex = context.editEntries.length;
                        context.editEntries.push(createEmptyRoomEntry());
                        const newRow = buildRow(context.editEntries[newIndex], newIndex);
                        listEl.appendChild(newRow);
                    }
                };

                context.editEntries.forEach((entry, index) => {
                    listEl.appendChild(buildRow(entry, index));
                });

                ensureTrailingRow();
            }

            const clearBtn = document.getElementById('roomModalClearRooms');
            if (clearBtn) {
                if (mode === 'allocation') {
                    clearBtn.textContent = 'Clear Override';
                    clearBtn.disabled = context.overrideEntries.length === 0;
                } else {
                    clearBtn.textContent = 'Remove Rooms';
                    clearBtn.disabled = context.directEntries.length === 0;
                }
            }
        }

        async function handleRoomModalClear() {
            if (!currentRoomModalContext) {
                return;
            }

            const { subjectCode, mode, lineIndex, teacherIndex } = currentRoomModalContext;

            if (mode === 'allocation') {
                if (currentRoomModalContext.overrideEntries.length === 0) {
                    return;
                }
                const confirmed = await showAppConfirm('Remove the custom room override for this allocation?', {
                    confirmLabel: 'Remove override',
                    cancelLabel: 'Cancel'
                });
                if (!confirmed) {
                    return;
                }
                clearAllocationRoomAssignments(lineIndex, teacherIndex, subjectCode);
                canonicalizeRoomAssignments();
                closeRoomModal();
                renderCell(lineIndex, teacherIndex);
                showAppAlert(`Room override removed for ${subjectCode}.`, { icon: '' });
            } else {
                if (currentRoomModalContext.directEntries.length === 0) {
                    return;
                }
                const confirmed = await showAppConfirm(`Remove stored rooms for ${subjectCode}?`, {
                    confirmLabel: 'Remove rooms',
                    cancelLabel: 'Keep rooms'
                });
                if (!confirmed) {
                    return;
                }
                clearSubjectRoomAssignments(subjectCode);
                canonicalizeRoomAssignments();
                closeRoomModal();
                renderAllAllocations();
                createSubjectPool();
                showAppAlert(`Rooms cleared for ${subjectCode}.`, { icon: '' });
            }
        }

        async function handleRoomModalSave() {
            if (!currentRoomModalContext) {
                return;
            }

            const { subjectCode, mode, lineIndex, teacherIndex } = currentRoomModalContext;
            const sanitizedEntries = normalizeRoomEntries(currentRoomModalContext.editEntries);

            if (mode === 'allocation') {
                const defaultEntries = getSubjectRoomAssignments(subjectCode);
                if (sanitizedEntries.length === 0 || (defaultEntries.length > 0 && areRoomEntriesEqual(sanitizedEntries, defaultEntries))) {
                    clearAllocationRoomAssignments(lineIndex, teacherIndex, subjectCode);
                } else {
                    setAllocationRoomAssignments(lineIndex, teacherIndex, subjectCode, sanitizedEntries);
                }
                canonicalizeRoomAssignments();
                closeRoomModal();
                renderCell(lineIndex, teacherIndex);
                showAppAlert(`Rooms updated for ${subjectCode}.`, { icon: '' });
            } else {
                const inheritedEntries = getInheritedSubjectRoomAssignments(subjectCode);
                if (sanitizedEntries.length === 0 || (inheritedEntries.length > 0 && areRoomEntriesEqual(sanitizedEntries, inheritedEntries))) {
                    clearSubjectRoomAssignments(subjectCode);
                } else {
                    setSubjectRoomAssignments(subjectCode, sanitizedEntries);
                }
                canonicalizeRoomAssignments();
                closeRoomModal();
                renderAllAllocations();
                createSubjectPool();
                showAppAlert(`Rooms updated for ${subjectCode}.`, { icon: '' });
            }
        }

        function handleRoomModalCopyDefaults() {
            if (!currentRoomModalContext) {
                return;
            }

            if (currentRoomModalContext.mode === 'allocation') {
                currentRoomModalContext.editEntries = cloneRoomEntries(currentRoomModalContext.defaultEntries);
            } else {
                currentRoomModalContext.editEntries = cloneRoomEntries(currentRoomModalContext.inheritedEntries);
            }

            renderRoomModal();
        }

        function setupRoomModal() {
            const modal = document.getElementById('roomModal');
            if (!modal) {
                return;
            }

            const closeBtn = document.getElementById('roomModalClose');
            const saveBtn = document.getElementById('roomModalSaveRooms');
            const clearBtn = document.getElementById('roomModalClearRooms');
            const copyBtn = document.getElementById('roomModalCopyDefaults');
            const modalContent = modal.querySelector('.modal-content');

            if (closeBtn) {
                closeBtn.addEventListener('click', closeRoomModal);
            }

            if (saveBtn) {
                saveBtn.addEventListener('click', () => {
                    handleRoomModalSave();
                });
            }

            if (clearBtn) {
                clearBtn.addEventListener('click', () => {
                    handleRoomModalClear();
                });
            }

            if (copyBtn) {
                copyBtn.addEventListener('click', () => handleRoomModalCopyDefaults());
            }

            window.addEventListener('click', event => {
                if (event.target === modal) {
                    closeRoomModal();
                }
            });

            if (modalContent) {
                modalContent.addEventListener('keydown', event => {
                    if (event.key === 'Escape') {
                        event.preventDefault();
                        closeRoomModal();
                    }
                });
            }
        }

        function saveAllocations() {
            const data = {
                allocations: allocations,
                timestamp: new Date().toISOString(),
                subjects: subjects,
                teachers: teachers,
                lines: lines,
                csvData: csvData,
                subjectLineMapping: subjectLineMapping,
                subjectSplits: subjectSplits,
                subjectYearMapping: subjectYearMapping,
                teacherLoadSettings: teacherLoadSettings,
                subjectRoomAssignments: subjectRoomAssignments,
                allocationRoomOverrides: allocationRoomOverrides
            };

            localStorage.setItem('facultyAllocations', JSON.stringify(data));
            alert('Allocations saved successfully!');
        }

        async function resetAllocations() {
            const confirmed = await showAppConfirm('Are you sure you want to reset all allocations? This action cannot be undone.', {
                confirmLabel: 'Reset allocations',
                cancelLabel: 'Cancel'
            });
            if (!confirmed) {
                return;
            }

            allocations = {};
            allocationRoomOverrides = {};
            actionHistory = []; // Clear undo history
            redoStack = [];

            renderAllAllocations();

            // Disable undo button
            const undoBtn = document.getElementById('undoBtn');
            if (undoBtn) {
                undoBtn.disabled = true;
            }

            const redoBtn = document.getElementById('redoBtn');
            if (redoBtn) {
                redoBtn.disabled = true;
            }

            // Recreate subject pool
            createSubjectPool();
            updateStats();
        }

        async function clearAllData() {
            const confirmed = await showAppConfirm('This will remove all imported teachers, subjects, allocations and saved settings. Continue?', {
                confirmLabel: 'Clear everything',
                cancelLabel: 'Cancel'
            });
            if (!confirmed) {
                return;
            }

            try {
                localStorage.removeItem('facultyAllocations');
            } catch (error) {
                console.error('Unable to remove saved data from localStorage:', error);
            }

            subjects = [];
            teachers = [];
            lines = [...DEFAULT_LINES];
            rebuildLineDurations();
            allocations = {};
            subjectRoomAssignments = {};
            allocationRoomOverrides = {};
            teacherAllocations = {};
            subjectLineMapping = {};
            subjectYearMapping = {};
            csvData = [];
            teacherLoadSettings = {};
            pendingClashContext = null;
            lastAllocationOutcome = { status: 'idle', reason: null };

            resetSplitData();
            clearActionHistory();

            initializeTimetable();
            createSubjectPool();
            updateStats();

            alert('All planner data has been cleared. You can now import new information or start building from scratch.');
        }

        function getSubjectYearLabel(subjectCode) {
            if (!subjectCode) {
                return null;
            }

            if (subjectYearMapping && subjectYearMapping[subjectCode]) {
                return subjectYearMapping[subjectCode];
            }

            const splitInfo = getSplitMetadata(subjectCode);
            const baseSubject = splitInfo ? splitInfo.baseSubject : subjectCode;

            if (baseSubject && subjectYearMapping && subjectYearMapping[baseSubject]) {
                applyYearMappingToSubject(baseSubject, subjectYearMapping[baseSubject]);
                return subjectYearMapping[subjectCode] || subjectYearMapping[baseSubject] || null;
            }

            if (!baseSubject) {
                return null;
            }

            const derivedLabel = deriveYearLabelFromCode(baseSubject);
            if (!derivedLabel) {
                return null;
            }

            applyYearMappingToSubject(baseSubject, derivedLabel);
            return subjectYearMapping[subjectCode] || derivedLabel;
        }

        function formatSubjectForExport(subject) {
            if (typeof subject !== 'string') {
                return '';
            }

            const cleanedSubject = subject.trim();
            if (cleanedSubject === '') {
                return '';
            }

            const yearLabel = getSubjectYearLabel(cleanedSubject);
            const splitInfo = getSplitMetadata(cleanedSubject);

            let formattedSubject = '';

            if (!splitInfo) {
                formattedSubject = cleanedSubject;
            } else {
                const baseLabel = (typeof splitInfo.baseSubject === 'string' && splitInfo.baseSubject.trim() !== '')
                    ? splitInfo.baseSubject.trim()
                    : cleanedSubject;

                const periodLabel = Number.isFinite(splitInfo.periods) && splitInfo.periods > 0
                    ? `${splitInfo.periods}p`
                    : '';

                const hasValidTotal = Number.isFinite(splitInfo.totalSplits) && splitInfo.totalSplits > 0;
                const partIndex = Number.isFinite(splitInfo.index) ? splitInfo.index + 1 : null;

                let splitLabel = '';
                if (partIndex !== null && hasValidTotal) {
                    splitLabel = `Split ${partIndex}/${splitInfo.totalSplits}`;
                } else if (partIndex !== null) {
                    splitLabel = `Split ${partIndex}`;
                } else if (hasValidTotal && splitInfo.totalSplits > 1) {
                    splitLabel = `Split of ${splitInfo.totalSplits}`;
                }

                if (!periodLabel && !splitLabel) {
                    formattedSubject = baseLabel;
                } else if (periodLabel && splitLabel) {
                    formattedSubject = `${baseLabel} - ${periodLabel} (${splitLabel})`;
                } else if (periodLabel) {
                    formattedSubject = `${baseLabel} - ${periodLabel}`;
                } else {
                    formattedSubject = `${baseLabel} - ${splitLabel}`;
                }
            }

            return yearLabel ? `${yearLabel}  ${formattedSubject}` : formattedSubject;
        }

        function formatSubjectsForCellExport(subjects) {
            if (!Array.isArray(subjects) || subjects.length === 0) {
                return '';
            }

            const sanitizedSubjects = subjects
                .map(subject => (typeof subject === 'string' ? subject.trim() : ''))
                .filter(subject => subject !== '');

            if (sanitizedSubjects.length === 0) {
                return '';
            }

            const sortedSubjects = sanitizedSubjects
                .map(subject => {
                    const splitInfo = getSplitMetadata(subject);
                    const baseSubject = splitInfo ? splitInfo.baseSubject : subject;
                    const normalizedBase = baseSubject ? normalizeSubjectCodeForPeriods(baseSubject) : '';
                    const match = normalizedBase.match(/^(\d{1,2})/);
                    const yearValue = match ? parseInt(match[1], 10) : null;
                    const sortKey = normalizedBase && normalizedBase.trim().length > 0
                        ? normalizedBase
                        : (baseSubject || subject);

                    return {
                        subject: subject,
                        baseSubject: baseSubject || subject,
                        year: Number.isInteger(yearValue) ? yearValue : null,
                        splitIndex: splitInfo && Number.isFinite(splitInfo.index) ? splitInfo.index : 0,
                        sortKey: sortKey
                    };
                })
                .sort((a, b) => {
                    if (a.year !== null && b.year !== null && a.year !== b.year) {
                        return b.year - a.year;
                    }

                    if (a.sortKey !== b.sortKey) {
                        return a.sortKey.localeCompare(b.sortKey);
                    }

                    if (a.splitIndex !== b.splitIndex) {
                        return a.splitIndex - b.splitIndex;
                    }

                    return a.subject.localeCompare(b.subject);
                })
                .map(item => item.subject);

            const formatted = sortedSubjects.map(formatSubjectForExport);
            return formatted.join(formatted.length > 1 ? ' | ' : '');
        }

        function buildAllocationSpreadsheetRows() {
            const teacherList = Array.isArray(teachers) ? teachers : [];
            const lineList = Array.isArray(lines) ? lines : [];

            const rows = [];
            rows.push(['Line', ...teacherList]);

            lineList.forEach((lineNameValue, lineIndex) => {
                const lineName = typeof lineNameValue === 'string' && lineNameValue.trim() !== ''
                    ? lineNameValue
                    : `Line ${lineIndex + 1}`;

                const row = [lineName];

                teacherList.forEach((_, teacherIndex) => {
                    const key = getAllocationKey(lineIndex, teacherIndex);
                    const subjects = getAllocationSubjects(key);
                    row.push(formatSubjectsForCellExport(subjects));
                });

                rows.push(row);
            });

            if (teacherList.length > 0) {
                const totals = calculateTeacherPeriodTotals();
                const totalRow = ['Total Periods (per fortnight)'];

                teacherList.forEach((_, teacherIndex) => {
                    const totalValue = Array.isArray(totals) && Number.isFinite(totals[teacherIndex])
                        ? totals[teacherIndex]
                        : 0;
                    totalRow.push(totalValue);
                });

                rows.push(totalRow);
            }

            return rows;
        }

        function convertRowsToCSV(rows) {
            if (!Array.isArray(rows)) {
                return '';
            }

            const csvLines = rows.map(row => {
                const cells = Array.isArray(row) ? row : [];
                return cells.map(cell => {
                    let value = cell === null || cell === undefined ? '' : String(cell);
                    value = value.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
                    value = value.replace(/[\u2013\u2014]/g, '-');

                    if (value.includes('"')) {
                        value = value.replace(/"/g, '""');
                    }

                    if (/[",\n]/.test(value)) {
                        value = `"${value}"`;
                    }

                    return value;
                }).join(',');
            });

            return csvLines.join('\r\n');
        }

        function downloadAllocationSpreadsheet() {
            if (!Array.isArray(teachers) || teachers.length === 0) {
                alert('No teacher data available to export. Import spreadsheet data to begin.');
                return;
            }

            const rows = buildAllocationSpreadsheetRows();
            if (!rows || rows.length === 0) {
                alert('No allocation data available to export.');
                return;
            }

            const csvContent = convertRowsToCSV(rows);
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const today = new Date().toISOString().split('T')[0];
            a.href = url;
            a.download = `teacher-allocations-${today}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showDownloadNotification('Allocation spreadsheet exported as CSV.', { icon: '' });
        }

        function exportData() {
            if (!Array.isArray(teachers) || teachers.length === 0) {
                alert('No teacher data available to export. Import spreadsheet data to begin.');
                return;
            }

            const payload = {
                allocations: allocations,
                timestamp: new Date().toISOString(),
                subjects: subjects,
                teachers: teachers,
                lines: lines,
                csvData: csvData,
                subjectLineMapping: subjectLineMapping,
                subjectSplits: subjectSplits,
                subjectYearMapping: subjectYearMapping,
                teacherLoadSettings: teacherLoadSettings,
                subjectRoomAssignments: subjectRoomAssignments,
                allocationRoomOverrides: allocationRoomOverrides
            };

            const jsonContent = JSON.stringify(payload, null, 2);
            const blob = new Blob([jsonContent], { type: 'application/json;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const today = new Date().toISOString().split('T')[0];
            a.href = url;
            a.download = `faculty-allocations-${today}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showDownloadNotification('Allocation data exported as JSON file.', { icon: '' });
        }

        async function importData() {
            if (hasExistingData()) {
                const confirmImport = await showAppConfirm('Importing saved data will replace your current teachers, subjects and allocations. Continue?', {
                    confirmLabel: 'Replace data',
                    cancelLabel: 'Cancel'
                });
                if (!confirmImport) {
                    return;
                }
            }

            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json,application/json';
            input.style.display = 'none';
            input.value = '';

            const handleCleanup = () => {
                input.value = '';
                input.removeEventListener('change', handleFileSelection);
                if (input.parentNode) {
                    input.parentNode.removeChild(input);
                }
            };

            const handleFileSelection = function(event) {
                const file = event.target.files && event.target.files[0];
                if (!file) {
                    handleCleanup();
                    return;
                }

                const reader = new FileReader();
                reader.onload = function(loadEvent) {
                    const content = loadEvent && loadEvent.target ? loadEvent.target.result : null;
                    if (typeof content !== 'string') {
                        alert('Error importing data: unable to read file contents.');
                        handleCleanup();
                        return;
                    }

                    try {
                        const data = JSON.parse(content);
                        loadAllocations(data);
                    } catch (error) {
                        alert('Error importing data: ' + error.message);
                    }
                    handleCleanup();
                };

                reader.onerror = function(errorEvent) {
                    const errorMessage = errorEvent && errorEvent.target && errorEvent.target.error
                        ? errorEvent.target.error.message
                        : 'Unknown file read error.';
                    alert('Error reading file: ' + errorMessage);
                    handleCleanup();
                };

                reader.readAsText(file);
            };

            input.addEventListener('change', handleFileSelection);
            document.body.appendChild(input);

            setTimeout(() => {
                input.click();
            }, 0);
        }

        function loadAllocations(data) {
            allocations = {};
            actionHistory = [];
            redoStack = [];

            const undoBtn = document.getElementById('undoBtn');
            if (undoBtn) {
                undoBtn.disabled = true;
            }

            const redoBtn = document.getElementById('redoBtn');
            if (redoBtn) {
                redoBtn.disabled = true;
            }

            if (data.subjects) subjects = Array.isArray(data.subjects) ? [...data.subjects] : data.subjects;
            if (data.teachers) teachers = data.teachers;
            if (Array.isArray(data.lines)) {
                lines = data.lines.map((line, index) => {
                    if (typeof line === 'string') {
                        const trimmed = line.trim();
                        if (trimmed.length > 0) {
                            return trimmed;
                        }
                    }
                    return getDefaultLineLabel(index);
                });
            } else {
                lines = [...DEFAULT_LINES];
            }

            if (lines.length < DEFAULT_LINES.length) {
                for (let i = lines.length; i < DEFAULT_LINES.length; i++) {
                    lines.push(getDefaultLineLabel(i));
                }
            }

            rebuildLineDurations();

            if (!Array.isArray(teachers)) {
                teachers = [];
            }

            if (data.teacherLoadSettings && typeof data.teacherLoadSettings === 'object') {
                try {
                    teacherLoadSettings = JSON.parse(JSON.stringify(data.teacherLoadSettings));
                } catch (error) {
                    teacherLoadSettings = { ...data.teacherLoadSettings };
                }
            } else if (!teacherLoadSettings || typeof teacherLoadSettings !== 'object') {
                teacherLoadSettings = {};
            }

            teachers.forEach(teacher => {
                getTeacherLoadSettings(teacher);
            });

            if (!Array.isArray(subjects)) {
                subjects = [];
            }

            if (data.subjectSplits) {
                try {
                    subjectSplits = JSON.parse(JSON.stringify(data.subjectSplits));
                } catch (error) {
                    subjectSplits = data.subjectSplits;
                }
                rebuildSplitLookup();
            } else {
                resetSplitData();
            }

            if (Array.isArray(subjects) && Object.keys(subjectSplits).length > 0) {
                const splitCodes = [];
                Object.values(subjectSplits).forEach(splits => {
                    if (!Array.isArray(splits)) {
                        return;
                    }
                    splits.forEach(split => {
                        if (split && typeof split.code === 'string') {
                            splitCodes.push(split.code);
                        }
                    });
                });

                const baseSubjects = new Set(Object.keys(subjectSplits));
                subjects = subjects.filter(subject => !baseSubjects.has(subject));

                splitCodes.forEach(code => {
                    if (!subjects.includes(code)) {
                        subjects.push(code);
                    }
                });
            }

            if (Array.isArray(data.csvData)) {
                csvData = data.csvData;
            } else {
                csvData = [];
            }

            if (data.subjectLineMapping) {
                subjectLineMapping = normalizeSubjectMapping(data.subjectLineMapping);
            } else {
                subjectLineMapping = {};
            }

            if (data.subjectYearMapping && typeof data.subjectYearMapping === 'object') {
                let yearMappingSource;
                try {
                    yearMappingSource = JSON.parse(JSON.stringify(data.subjectYearMapping));
                } catch (error) {
                    yearMappingSource = { ...data.subjectYearMapping };
                }
                subjectYearMapping = normalizeSubjectMapping(yearMappingSource);
            } else {
                subjectYearMapping = {};
            }

            if (data.subjectRoomAssignments && typeof data.subjectRoomAssignments === 'object') {
                try {
                    subjectRoomAssignments = JSON.parse(JSON.stringify(data.subjectRoomAssignments));
                } catch (error) {
                    subjectRoomAssignments = { ...data.subjectRoomAssignments };
                }
            } else {
                subjectRoomAssignments = {};
            }

            if (data.allocationRoomOverrides && typeof data.allocationRoomOverrides === 'object') {
                try {
                    allocationRoomOverrides = JSON.parse(JSON.stringify(data.allocationRoomOverrides));
                } catch (error) {
                    allocationRoomOverrides = { ...data.allocationRoomOverrides };
                }
            } else {
                allocationRoomOverrides = {};
            }

            if (!Array.isArray(subjects)) {
                subjects = [];
            }

            if (data.allocations) {
                Object.entries(data.allocations).forEach(([key, value]) => {
                    const subjectsList = Array.isArray(value) ? value : [value];
                    const normalizedSubjects = [];
                    const seenSubjects = new Set();

                    subjectsList.forEach(subjectCode => {
                        if (typeof subjectCode !== 'string') {
                            return;
                        }

                        const normalizedCode = normalizeSubjectCode(subjectCode);
                        if (!normalizedCode || seenSubjects.has(normalizedCode)) {
                            return;
                        }

                        seenSubjects.add(normalizedCode);
                        normalizedSubjects.push(normalizedCode);
                    });

                    setAllocationSubjects(key, normalizedSubjects);
                });
            }

            canonicalizeSubjectData();
            canonicalizeRoomAssignments();
            populateYearMappingFromSubjects();

            initializeTimetable();
            createSubjectPool();
            updateStats();
        }

        function updateStats() {
            const totalSubjects = subjects.length;
            const allocatedSubjects = flattenAllocatedSubjects().length;
            const availableSubjects = getAvailableSubjects().length;
            const allocationPercentage = totalSubjects > 0 ? Math.round((allocatedSubjects / totalSubjects) * 100) : 0;

            document.getElementById('totalSubjects').textContent = totalSubjects;
            document.getElementById('allocatedSubjects').textContent = allocatedSubjects;
            document.getElementById('remainingSubjects').textContent = availableSubjects;
            document.getElementById('allocationPercentage').textContent = allocationPercentage + '%';

            updateTeacherPeriodTotals();
        }

        function initializeLineCellsConverter() {
            const fileInput = document.getElementById('converterFile');
            const fileButton = document.getElementById('converterFileButton');
            const detectedEl = document.getElementById('converterDetected');
            const summaryEl = document.getElementById('converterSummary');
            const jsonOutput = document.getElementById('converterJson');
            const cellsEl = document.getElementById('converterCells');
            const normalizeCheckbox = document.getElementById('converterNormalize');
            const inheritCheckbox = document.getElementById('converterInherit');
            const removeCheckbox = document.getElementById('converterRemove');
            const forceYearInput = document.getElementById('converterForceYear');
            const downloadBtn = document.getElementById('converterDownloadJson');
            const validateBtn = document.getElementById('converterValidate');
            const copyBtn = document.getElementById('converterCopy');
            const clearBtn = document.getElementById('converterClear');
            const downloadTemplateBtn = document.getElementById('converterDownloadTemplate');
            const downloadTeacherTemplateBtn = document.getElementById('converterDownloadTeacherTemplate');
            const statusEl = document.getElementById('converterStatus');
            const applyBtn = document.getElementById('converterApply');
            const fileInfo = document.getElementById('converterFileInfo');
            const modeToggle = document.getElementById('converterModeToggle');
            const modeSubjectsBtn = document.getElementById('converterModeSubjects');
            const modeTeachersBtn = document.getElementById('converterModeTeachers');
            const defaultFileInfoText = fileInfo && fileInfo.textContent
                ? fileInfo.textContent.trim() || 'No file selected yet.'
                : 'No file selected yet.';
            const fallbackButtonDefaultLabel = 'Choose File';
            const fallbackButtonActiveLabel = 'Choose another file';
            const fileButtonDefaultLabel = fileButton
                ? (fileButton.dataset.labelDefault || fileButton.textContent.trim() || fallbackButtonDefaultLabel)
                : fallbackButtonDefaultLabel;
            const fileButtonActiveLabel = fileButton
                ? (fileButton.dataset.labelActive || fallbackButtonActiveLabel)
                : fallbackButtonActiveLabel;

            if (!fileInput || !fileButton || !fileInfo || !detectedEl || !summaryEl || !jsonOutput || !cellsEl || !downloadBtn || !validateBtn || !copyBtn || !clearBtn || !downloadTemplateBtn || !statusEl || !applyBtn) {
                return;
            }

            let currentOutput = { kind: 'none' };
            let cachedXlsxPatch = null;
            let cachedPatchLabel = '';
            let cachedTeacherResult = null;
            let cachedTeacherLabel = '';
            let currentMode = 'subjects';
            const defaultStatusMessage = 'Load a CSV, JSON, or XLSX file to enable Add to Matrix.';

            const allocationTemplateHeader = ['Year', 'Row', ...EXTENDED_LINE_LABELS.map((_, idx) => `Line${idx + 1}`)].join(',');
            const allocationTemplateRow = new Array(2 + EXTENDED_LINE_LABELS.length).fill('').join(',');
            const allocationTemplateCsv = [
                allocationTemplateHeader,
                ...Array.from({ length: 12 }, () => allocationTemplateRow)
            ].join('\n');
            const allocationTemplateFilename = 'allocation-data-template.csv';

            const escapeHtml = value => String(value ?? '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');

            const downloadFile = (filename, mimeType, data) => {
                const blob = data instanceof Blob ? data : new Blob([data ?? ''], { type: mimeType });
                const url = URL.createObjectURL(blob);
                const anchor = document.createElement('a');
                anchor.href = url;
                anchor.download = filename;
                document.body.appendChild(anchor);
                anchor.click();
                document.body.removeChild(anchor);
                setTimeout(() => URL.revokeObjectURL(url), 300);
            };

            const setDetected = text => {
                detectedEl.textContent = text;
            };

            const setStatus = (message, variant = 'idle') => {
                statusEl.textContent = message;
                statusEl.classList.remove('converter-status--ready', 'converter-status--error', 'converter-status--success');
                if (variant === 'ready') {
                    statusEl.classList.add('converter-status--ready');
                } else if (variant === 'error') {
                    statusEl.classList.add('converter-status--error');
                } else if (variant === 'success') {
                    statusEl.classList.add('converter-status--success');
                }
            };

            const renderCells = cells => {
                if (!Array.isArray(cells) || cells.length === 0) {
                    cellsEl.innerHTML = '<div class="converter-muted">No cells parsed yet.</div>';
                    return;
                }

                const max = 30;
                const hasYear = cells.some(cell => cell && cell.year !== undefined && cell.year !== null && cell.year !== '');
                const previewCells = cells.slice(0, max);
                const headerHtml = hasYear
                    ? '<th>Year</th><th>Row</th><th>Line</th><th>Codes</th>'
                    : '<th>Row</th><th>Line</th><th>Codes</th>';

                const rowsHtml = previewCells.map(cell => {
                    const codes = Array.isArray(cell.codes) ? cell.codes : [];
                    const codesHtml = codes.length > 0
                        ? codes.map(code => `<span class="converter-pill">${escapeHtml(code)}</span>`).join('')
                        : '<span class="converter-muted"></span>';
                    const rowValue = escapeHtml(cell.row ?? '');
                    const lineValue = escapeHtml(cell.line ?? '');
                    if (hasYear) {
                        const yearValue = escapeHtml(cell.year ?? '');
                        return `<tr><td>${yearValue}</td><td>${rowValue}</td><td>${lineValue}</td><td>${codesHtml}</td></tr>`;
                    }
                    return `<tr><td>${rowValue}</td><td>${lineValue}</td><td>${codesHtml}</td></tr>`;
                }).join('');

                const moreText = cells.length > max
                    ? `<div class="converter-muted">and ${cells.length - max} more</div>`
                    : '';

                cellsEl.innerHTML = `<table class="converter-table"><thead><tr>${headerHtml}</tr></thead><tbody>${rowsHtml}</tbody></table>${moreText}`;
            };

            const setSummary = ({ cells = 0, codes = 0, yearLabel = '', normalize = true, inherit = true, remove = false }) => {
                const summaryParts = [
                    `<div>Cells: <strong>${cells}</strong></div>`,
                    `<div>Total codes parsed: <strong>${codes}</strong></div>`,
                    `<div>Year(s): <strong>${escapeHtml(yearLabel)}</strong></div>`
                ];

                const optionPills = [];
                if (!normalize) {
                    optionPills.push('<span class="converter-pill">Normalize codes off</span>');
                }
                if (!inherit) {
                    optionPills.push('<span class="converter-pill">No line inheritance</span>');
                }
                if (remove) {
                    optionPills.push('<span class="converter-pill">removeMissingInThisYear</span>');
                }

                if (optionPills.length > 0) {
                    summaryParts.push(`<div class="converter-summary-options">${optionPills.join('')}</div>`);
                }

                summaryEl.innerHTML = summaryParts.join('');
            };

            const appendSummaryWarnings = warnings => {
                if (!summaryEl || !Array.isArray(warnings) || warnings.length === 0) {
                    return;
                }
                const pills = warnings
                    .filter(Boolean)
                    .map(warning => `<span class="converter-pill">${escapeHtml(warning)}</span>`)
                    .join('');
                if (pills) {
                    summaryEl.innerHTML += `<div class="converter-summary-options">${pills}</div>`;
                }
            };

            const updateModeButtons = () => {
                const hasSubjects = Boolean(cachedXlsxPatch);
                const hasTeachers = Boolean(cachedTeacherResult);
                if (modeToggle) {
                    modeToggle.classList.toggle('is-hidden', !(hasSubjects && hasTeachers));
                }
                if (modeSubjectsBtn) {
                    modeSubjectsBtn.disabled = !hasSubjects;
                    modeSubjectsBtn.classList.toggle('is-active', currentMode === 'subjects' && hasSubjects);
                    modeSubjectsBtn.setAttribute('aria-pressed', currentMode === 'subjects' && hasSubjects ? 'true' : 'false');
                }
                if (modeTeachersBtn) {
                    modeTeachersBtn.disabled = !hasTeachers;
                    modeTeachersBtn.classList.toggle('is-active', currentMode === 'teachers' && hasTeachers);
                    modeTeachersBtn.setAttribute('aria-pressed', currentMode === 'teachers' && hasTeachers ? 'true' : 'false');
                }
            };

            const switchToSubjects = ({ detectedLabelOverride } = {}) => {
                if (!cachedXlsxPatch) {
                    return;
                }
                currentMode = 'subjects';
                applyPatchToUi(cachedXlsxPatch, {
                    detectedLabel: detectedLabelOverride || cachedPatchLabel || 'Timetable data ready',
                    syncControls: true,
                    updateText: true
                });
                updateModeButtons();
            };

            const switchToTeachers = ({ detectedLabelOverride } = {}) => {

                if (!cachedTeacherResult) {

                    return;

                }

                currentMode = 'teachers';

                applyTeacherDataToUi(cachedTeacherResult, {

                    detectedLabel: detectedLabelOverride || cachedTeacherLabel || 'Teacher data ready',

                    updateText: true

                });

                updateModeButtons();

            };



            const setFileInfo = text => {

                if (fileInfo) {

                    fileInfo.textContent = text;

                }

                if (fileButton) {

                    const isDefault = text === defaultFileInfoText;

                    fileButton.textContent = isDefault ? fileButtonDefaultLabel : fileButtonActiveLabel;

                }

            };



            const resetDisplay = () => {

                currentOutput = { kind: 'none' };

                cachedXlsxPatch = null;

                cachedPatchLabel = '';

                cachedTeacherResult = null;

                cachedTeacherLabel = '';

                currentMode = 'subjects';

                setDetected('');

                summaryEl.textContent = '';

                cellsEl.innerHTML = '<div class="converter-muted">No cells parsed yet.</div>';

                jsonOutput.value = '';

                downloadBtn.disabled = true;

                copyBtn.disabled = true;

                applyBtn.disabled = true;

                setStatus(defaultStatusMessage);

                setFileInfo(defaultFileInfoText);

                updateModeButtons();

            };



            if (modeSubjectsBtn) {

                modeSubjectsBtn.addEventListener('click', () => {

                    if (modeSubjectsBtn.disabled) {

                        return;

                    }

                    switchToSubjects({});

                });

            }



            if (modeTeachersBtn) {

                modeTeachersBtn.addEventListener('click', () => {

                    if (modeTeachersBtn.disabled) {

                        return;

                    }

                    switchToTeachers({});

                });

            }



            updateModeButtons();



            const applyPatchToUi = (patch, { detectedLabel, syncControls = false, updateText = true } = {}) => {
                if (!patch) {
                    return;
                }

                const summary = summarizeLineCellsPatch(patch);
                let options = (patch && typeof patch === 'object' && patch.options && typeof patch.options === 'object')
                    ? patch.options
                    : {};
                if (patch.patchType === 'lineCellsMulti') {
                    const firstWithOptions = Array.isArray(patch.patches)
                        ? patch.patches.find(p => p && p.options && typeof p.options === 'object')
                        : null;
                    if (!options || Object.keys(options).length === 0) {
                        options = firstWithOptions && firstWithOptions.options ? firstWithOptions.options : options;
                    }
                }

                const normalize = options && options.normalizeCodes !== false;
                const inherit = options && options.inheritLineForSplits !== false;
                const remove = options && options.removeMissingInThisYear === true;

                if (syncControls) {
                    if (normalizeCheckbox) {
                        normalizeCheckbox.checked = normalize;
                    }
                    if (inheritCheckbox) {
                        inheritCheckbox.checked = inherit;
                    }
                    if (removeCheckbox) {
                        removeCheckbox.checked = remove;
                    }
                    if (forceYearInput) {
                        forceYearInput.value = patch.patchType === 'lineCells' ? (patch.year ?? '') : '';
                    }
                }

                const yearSummary = summary.years.length > 0 ? summary.years.join(', ') : '';
                const formattedYearLabel = formatLineCellsYears(summary.years);

                setSummary({ cells: summary.cellCount, codes: summary.codeCount, yearLabel: yearSummary, normalize, inherit, remove });
                renderCells(summary.cells);

                if (updateText) {
                    jsonOutput.value = JSON.stringify(patch, null, 2);
                }

                currentOutput = { kind: 'lineCells', patch };
                downloadBtn.disabled = false;
                copyBtn.disabled = false;
                applyBtn.disabled = false;
                setStatus(`Ready to add ${summary.cellCount} cell${summary.cellCount === 1 ? '' : 's'} for ${formattedYearLabel}.`, 'ready');

                if (detectedLabel) {
                    setDetected(detectedLabel);
                }
            };

            const renderTeacherPreview = result => {
                const previewRows = Array.isArray(result?.previewRows) ? result.previewRows : [];
                if (previewRows.length === 0) {
                    cellsEl.innerHTML = '<div class="converter-muted">No teachers detected yet.</div>';
                    return;
                }

                const max = 30;
                const limited = previewRows.slice(0, max);
                const headers = ['Teacher', 'FTE', 'Period allowance', 'Assembly (Full)', 'Assembly (Short)', 'Additional minutes'];
                const headerHtml = headers.map(label => `<th>${escapeHtml(label)}</th>`).join('');

                const formatCell = value => {
                    if (value === null || value === undefined || value === '') {
                        return '<span class="converter-muted"></span>';
                    }
                    return escapeHtml(String(value));
                };

                const rowsHtml = limited.map(row => {
                    const teacherName = escapeHtml(String(row.teacher ?? ''));
                    return [
                        teacherName,
                        formatCell(row.fte),
                        formatCell(row.periodAllowance),
                        formatCell(row.assemblyFullCount),
                        formatCell(row.assemblyShortCount),
                        formatCell(row.additionalMinutes)
                    ].map((cell, index) => `<td>${cell}</td>`).join('');
                }).map(rowHtml => `<tr>${rowHtml}</tr>`).join('');

                const moreText = previewRows.length > max
                    ? `<div class="converter-muted">and ${previewRows.length - max} more</div>`
                    : '';

                cellsEl.innerHTML = `<table class="converter-table"><thead><tr>${headerHtml}</tr></thead><tbody>${rowsHtml}</tbody></table>${moreText}`;
            };

            const buildTeacherPayload = result => {
                if (!result || !Array.isArray(result.teachers)) {
                    return { teachers: [] };
                }

                const payload = {
                    teachers: result.teachers.slice()
                };

                if (result.teacherLoadSettings && typeof result.teacherLoadSettings === 'object') {
                    const loadSettings = Object.fromEntries(
                        Object.entries(result.teacherLoadSettings).map(([name, settings]) => [name, { ...settings }])
                    );
                    if (Object.keys(loadSettings).length > 0) {
                        payload.teacherLoadSettings = loadSettings;
                    }
                }

                return payload;
            };

            const applyTeacherDataToUi = (result, { detectedLabel, updateText = true } = {}) => {
                if (!result || !Array.isArray(result.teachers)) {
                    return;
                }

                const payload = buildTeacherPayload(result);

                if (updateText) {
                    jsonOutput.value = JSON.stringify(payload, null, 2);
                }

                const stats = result.stats || {};
                const teacherCount = stats.teacherCount ?? result.teachers.length;
                const summaryParts = [`<div>Teachers: <strong>${teacherCount}</strong></div>`];

                const loadSettingsPayload = payload.teacherLoadSettings || {};
                const loadCount = stats.loadCount ?? Object.keys(loadSettingsPayload).length;
                if (loadCount > 0) {
                    const detailParts = [];
                    if (stats.fteOverrides > 0) {
                        detailParts.push(`${stats.fteOverrides} FTE`);
                    }
                    if (stats.periodAllowanceOverrides > 0) {
                        detailParts.push(`${stats.periodAllowanceOverrides} allowance${stats.periodAllowanceOverrides === 1 ? '' : 's'}`);
                    }
                    if (stats.assemblyFullOverrides > 0) {
                        detailParts.push(`${stats.assemblyFullOverrides} full assembl${stats.assemblyFullOverrides === 1 ? 'y' : 'ies'}`);
                    }
                    if (stats.assemblyShortOverrides > 0) {
                        detailParts.push(`${stats.assemblyShortOverrides} short/TLC assembl${stats.assemblyShortOverrides === 1 ? 'y' : 'ies'}`);
                    }
                    if (stats.additionalMinutesOverrides > 0) {
                        detailParts.push(`${stats.additionalMinutesOverrides} minute${stats.additionalMinutesOverrides === 1 ? '' : 's'}`);
                    }
                    const detailText = detailParts.length > 0
                        ? ` <span class="converter-muted">(${escapeHtml(detailParts.join(', '))})</span>`
                        : '';
                    summaryParts.push(`<div>Custom load settings: <strong>${loadCount}</strong>${detailText}</div>`);
                }

                const warnings = [];
                if (stats.duplicates > 0) {
                    warnings.push(`Duplicates skipped: ${stats.duplicates}`);
                }
                if (stats.blankRows > 0) {
                    warnings.push(`Blank rows skipped: ${stats.blankRows}`);
                }
                if (warnings.length > 0) {
                    summaryParts.push(`<div class="converter-summary-options">${warnings
                        .map(warning => `<span class="converter-pill">${escapeHtml(warning)}</span>`)
                        .join('')}</div>`);
                }

                summaryEl.innerHTML = summaryParts.join('');
                renderTeacherPreview(result);

                currentOutput = { kind: 'teacherSupplemental', data: payload, stats };
                downloadBtn.disabled = false;
                copyBtn.disabled = false;
                applyBtn.disabled = false;
                setStatus(`Ready to add ${result.teachers.length} teacher${result.teachers.length === 1 ? '' : 's'}.`, 'ready');

                if (detectedLabel) {
                    setDetected(detectedLabel);
                }
            };

            const ensureOptionsShape = patch => {
                if (!patch || typeof patch !== 'object') {
                    return patch;
                }
                if (patch.patchType === 'lineCellsMulti') {
                    patch.options = Object.assign({ touchAllocations: false }, patch.options);
                    if (Array.isArray(patch.patches)) {
                        patch.patches = patch.patches.map(child => ensureOptionsShape(child));
                    }
                    return patch;
                }
                patch.options = Object.assign({ touchAllocations: false }, patch.options);
                return patch;
            };

            const setOptionOnPatch = (patch, key, value) => {
                if (!patch || typeof patch !== 'object') {
                    return;
                }
                if (!patch.options || typeof patch.options !== 'object') {
                    patch.options = {};
                }
                patch.options[key] = value;
                if (patch.patchType === 'lineCellsMulti' && Array.isArray(patch.patches)) {
                    patch.patches.forEach(child => setOptionOnPatch(child, key, value));
                }
            };

            const clearOptionOnPatch = (patch, key) => {
                if (!patch || typeof patch !== 'object') {
                    return;
                }
                if (patch.options && typeof patch.options === 'object') {
                    delete patch.options[key];
                }
                if (patch.patchType === 'lineCellsMulti' && Array.isArray(patch.patches)) {
                    patch.patches.forEach(child => clearOptionOnPatch(child, key));
                }
            };

            resetDisplay();

            if (fileButton) {
                fileButton.addEventListener('click', () => {
                    if (fileInput) {
                        fileInput.click();
                    }
                });
            }

            fileInput.addEventListener('change', async event => {
                const file = event.target.files && event.target.files[0];
                if (!file) {
                    return;
                }

                try {
                    const lowerName = file.name.toLowerCase();

                    setFileInfo(`Loaded: ${file.name}`);
                    cachedXlsxPatch = null;
                    cachedPatchLabel = '';
                    cachedTeacherResult = null;
                    cachedTeacherLabel = '';
                    currentMode = 'subjects';
                    updateModeButtons();

                    if (isXlsxFilename(lowerName)) {
                        const arrayBuffer = await file.arrayBuffer();
                        const workbookResult = convertWorkbookArrayBuffer(arrayBuffer);
                        const shouldNormalize = normalizeCheckbox ? normalizeCheckbox.checked : true;
                        const inherit = inheritCheckbox ? inheritCheckbox.checked : true;
                        let patch = csvToLineCellsPatch(workbookResult.allocationCsv, { normalizeCodes: shouldNormalize });
                        const forcedYear = parseInt(forceYearInput && forceYearInput.value, 10);
                        if (Number.isInteger(forcedYear) && forcedYear >= 7 && forcedYear <= 12 && patch.patchType === 'lineCells') {
                            patch.year = forcedYear;
                        }
                        patch = ensureOptionsShape(patch);
                        setOptionOnPatch(patch, 'normalizeCodes', shouldNormalize);
                        setOptionOnPatch(patch, 'inheritLineForSplits', inherit);
                        if (removeCheckbox && removeCheckbox.checked) {
                            setOptionOnPatch(patch, 'removeMissingInThisYear', true);
                        } else {
                            clearOptionOnPatch(patch, 'removeMissingInThisYear');
                        }
                        if (forceYearInput) {
                            forceYearInput.value = '';
                        }
                        cachedXlsxPatch = patch;
                        cachedPatchLabel = workbookResult.sheetName ? `XLSX timetable (${workbookResult.sheetName})` : 'XLSX timetable';
                        currentMode = 'subjects';
                        applyPatchToUi(patch, { detectedLabel: 'XLSX timetable detected', syncControls: true });
                        appendSummaryWarnings(workbookResult.allocationWarnings || []);

                        let teacherMessage = '';
                        if (workbookResult.teacherCsv) {
                            try {
                                const teacherRows = parseCsv(workbookResult.teacherCsv);
                                if (teacherRows.length > 1) {
                                    const teacherResult = teacherRowsToSupplemental(teacherRows);
                                    cachedTeacherResult = teacherResult;
                                    cachedTeacherLabel = 'Teacher data from XLSX';
                                    const count = teacherResult.teachers.length;
                                    const noun = count === 1 ? 'teacher' : 'teachers';
                                    teacherMessage = ` Teacher data detected (${count} ${noun}). Use the toggle to preview.`;
                                }
                            } catch (error) {
                                console.warn('Could not parse teacher table from XLSX.', error);
                            }
                        }

                        updateModeButtons();

                        try {
                            const summary = summarizeLineCellsPatch(patch);
                            const yearLabel = formatLineCellsYears(summary.years);
                            setStatus(`Ready to add ${summary.cellCount} cell${summary.cellCount === 1 ? '' : 's'} for ${yearLabel}.${teacherMessage}`, 'ready');
                        } catch (error) {
                            setStatus(`Timetable data ready.${teacherMessage}`, 'ready');
                        }
                        return;
                    }

                    if (lowerName.endsWith('.csv')) {
                        const text = await file.text();
                        const rows = parseCsv(text);
                        if (rows.length > 0) {
                            const headers = rows[0].map(cell => (cell === null || cell === undefined ? '' : String(cell).trim()));
                            if (looksLikeTeacherHeaders(headers)) {
                                const teacherResult = teacherRowsToSupplemental(rows);
                                applyTeacherDataToUi(teacherResult, { detectedLabel: 'Teacher CSV detected' });
                                if (forceYearInput) {
                                    forceYearInput.value = '';
                                }
                                if (normalizeCheckbox) {
                                    normalizeCheckbox.checked = true;
                                }
                                if (inheritCheckbox) {
                                    inheritCheckbox.checked = true;
                                }
                                if (removeCheckbox) {
                                    removeCheckbox.checked = false;
                                }
                                return;
                            }
                        }

                        const shouldNormalize = normalizeCheckbox ? normalizeCheckbox.checked : true;
                        let patch = csvToLineCellsPatch(text, { normalizeCodes: shouldNormalize });
                        const forcedYear = parseInt(forceYearInput && forceYearInput.value, 10);
                        if (Number.isInteger(forcedYear) && forcedYear >= 7 && forcedYear <= 12 && patch.patchType === 'lineCells') {
                            patch.year = forcedYear;
                        }
                        patch = ensureOptionsShape(patch);
                        setOptionOnPatch(patch, 'normalizeCodes', shouldNormalize);
                        const inherit = inheritCheckbox ? inheritCheckbox.checked : true;
                        setOptionOnPatch(patch, 'inheritLineForSplits', inherit);
                        if (removeCheckbox && removeCheckbox.checked) {
                            setOptionOnPatch(patch, 'removeMissingInThisYear', true);
                        } else {
                            clearOptionOnPatch(patch, 'removeMissingInThisYear');
                        }
                        if (patch.patchType === 'lineCellsMulti' && forceYearInput) {
                            forceYearInput.value = '';
                        }
                        applyPatchToUi(patch, { detectedLabel: 'CSV detected' });
                    } else if (lowerName.endsWith('.json')) {
                        const text = await file.text();
                        const parsed = JSON.parse(text);
                        if (isTeacherSupplementalJson(parsed)) {
                            const teacherResult = teacherJsonToSupplemental(parsed);
                            applyTeacherDataToUi(teacherResult, { detectedLabel: 'Teacher JSON detected' });
                        } else {
                            const patch = ensureOptionsShape(assertLineCellsPatch(parsed));
                            applyPatchToUi(patch, { detectedLabel: 'JSON detected', syncControls: true });
                        }
                    } else {
                        throw new Error('Please choose a .csv, .json, or .xlsx file');
                    }
                } catch (error) {
                    resetDisplay();
                    alert('Error: ' + (error && error.message ? error.message : error));
                    setStatus('Could not read that file. Please try again.', 'error');
                    setFileInfo(defaultFileInfoText);
                } finally {
                    fileInput.value = '';
                }
            });

            downloadBtn.addEventListener('click', () => {
                if (currentOutput.kind === 'lineCells' && currentOutput.patch) {
                    downloadFile('line-cells-patch.json', 'application/json', JSON.stringify(currentOutput.patch, null, 2));
                    setStatus('Downloaded a tidy JSON copy for reference.', 'success');
                } else if (currentOutput.kind === 'teacherSupplemental' && currentOutput.data) {
                    const jsonText = jsonOutput.value && jsonOutput.value.trim() !== ''
                        ? jsonOutput.value
                        : JSON.stringify(currentOutput.data, null, 2);
                    downloadFile('teacher-import.json', 'application/json', jsonText);
                    setStatus('Downloaded teacher list JSON for reference.', 'success');
                }
            });

            validateBtn.addEventListener('click', () => {
                try {
                    const parsed = JSON.parse(jsonOutput.value || '{}');
                    if (isTeacherSupplementalJson(parsed)) {
                        const teacherResult = teacherJsonToSupplemental(parsed);
                        applyTeacherDataToUi(teacherResult, { detectedLabel: 'Teacher JSON validated', updateText: false });
                        alert(`Valid teacher list JSON \nTeachers detected: ${teacherResult.teachers.length}.`);
                        setStatus('Teacher list JSON looks good. Press Add to Matrix to merge it.', 'ready');
                    } else {
                        const patch = ensureOptionsShape(assertLineCellsPatch(parsed));
                        applyPatchToUi(patch, { detectedLabel: 'JSON validated', syncControls: true });
                        const summary = summarizeLineCellsPatch(patch);
                        const yearLabel = formatLineCellsYears(summary.years);
                        alert(`Valid JSON patch \n${yearLabel} with ${summary.cellCount} cells.`);
                        setStatus('JSON looks good. Press Add to Matrix to merge it.', 'ready');
                    }
                } catch (error) {
                    alert('Invalid JSON \n' + error.message);
                    setStatus('Invalid JSON: ' + error.message, 'error');
                }
            });

            copyBtn.addEventListener('click', async () => {
                try {
                    await navigator.clipboard.writeText(jsonOutput.value || '');
                    alert('Copied JSON to clipboard');
                    setStatus('JSON copied to your clipboard.', 'success');
                } catch (error) {
                    alert('Could not copy to clipboard');
                    setStatus('Could not copy JSON to clipboard.', 'error');
                }
            });

            clearBtn.addEventListener('click', () => {
                fileInput.value = '';
                if (forceYearInput) {
                    forceYearInput.value = '';
                }
                resetDisplay();
            });

            downloadTemplateBtn.addEventListener('click', async event => {
                const hasDirectDownload = downloadTemplateBtn.tagName === 'A' && downloadTemplateBtn.hasAttribute('href');
                if (hasDirectDownload) {
                    setStatus('Template downloaded. Fill it in, then upload it here.', 'success');
                    return;
                }

                event.preventDefault();

                try {
                    const response = await fetch(allocationTemplateFilename, { cache: 'no-cache' });
                    if (!response.ok) {
                        throw new Error(`Template request failed with status ${response.status}`);
                    }
                    const blob = await response.blob();
                    downloadFile(allocationTemplateFilename, blob.type || 'text/csv', blob);
                    setStatus('Template downloaded. Fill it in, then upload it here.', 'success');
                } catch (error) {
                    console.warn('Could not download template CSV from file system. Falling back to generated copy.', error);
                    downloadFile(allocationTemplateFilename, 'text/csv', allocationTemplateCsv);
                    setStatus('Template downloaded. Fill it in, then upload it here.', 'success');
                }
            });

            if (downloadTeacherTemplateBtn) {
                downloadTeacherTemplateBtn.addEventListener('click', () => {
                    setStatus('Template downloaded. Fill it in, then upload it here.', 'success');
                });
            }

            applyBtn.addEventListener('click', async () => {
                if (!jsonOutput.value || jsonOutput.value.trim() === '') {
                    alert('Load a CSV, JSON, or XLSX file before adding it to the matrix.');
                    setStatus('Upload a CSV, JSON, or XLSX file before adding it to the matrix.', 'error');
                    return;
                }

                try {
                    const parsed = JSON.parse(jsonOutput.value);
                    if (isTeacherSupplementalJson(parsed)) {
                        const teacherResult = teacherJsonToSupplemental(parsed);
                        applyTeacherDataToUi(teacherResult, { detectedLabel: detectedEl.textContent || 'Teacher JSON ready' });

                        const payload = buildTeacherPayload(teacherResult);
                        const loadCount = payload.teacherLoadSettings ? Object.keys(payload.teacherLoadSettings).length : 0;
                        const confirmLines = [
                            'Add these teachers to the matrix?',
                            `Teachers detected: ${teacherResult.teachers.length}`,
                            loadCount > 0 ? `Custom load settings: ${loadCount}` : null,
                            '',
                            'Choose OK to merge these updates.'
                        ].filter(Boolean);

                        const confirmed = await showAppConfirm(confirmLines.join('\n'), {
                            confirmLabel: 'Add to matrix',
                            cancelLabel: 'Cancel'
                        });

                        if (!confirmed) {
                            setStatus('Teacher list ready. Press Add to Matrix when you are ready to import.', 'ready');
                            return;
                        }

                        mergeSupplementalData(payload);
                        resetDisplay();
                        setStatus('Teacher data merged into the matrix.', 'success');
                        return;
                    }

                    const patch = ensureOptionsShape(assertLineCellsPatch(parsed));
                    applyPatchToUi(patch, { detectedLabel: detectedEl.textContent || 'JSON ready', syncControls: true });

                    const summary = summarizeLineCellsPatch(patch);
                    const yearLabel = formatLineCellsYears(summary.years);

                    const appState = {
                        subjects,
                        subjectYearMapping,
                        subjectLineMapping,
                        subjectSplits,
                        allocations,
                        lines
                    };

                    const cloneState = () => {
                        let clone;
                        if (typeof structuredClone === 'function') {
                            clone = structuredClone(appState);
                        } else {
                            clone = JSON.parse(JSON.stringify(appState));
                        }
                        clone.lines = Array.isArray(appState.lines) ? [...appState.lines] : [...lines];
                        return clone;
                    };

                    applyLineCellsPatchBundle(cloneState(), patch);
                    const subjectSummaryLines = formatSubjectUploadSummaryLines(summarizeSubjectsByYear(patch));
                    const confirmMessage = [
                        'Add this data to the matrix?',
                        ...subjectSummaryLines,
                        '',
                        'Choose OK to merge these updates.'
                    ].join('\n');

                    const confirmed = await showAppConfirm(confirmMessage, {
                        confirmLabel: 'Add to matrix',
                        cancelLabel: 'Cancel'
                    });

                    if (!confirmed) {
                        return;
                    }

                    const result = applyLineCellsPatchBundle(appState, patch);
                    if (result.linesExtended) {
                        initializeTimetable();
                    }
                    if (result.changes.length > 0 || result.allocationsTouched > 0) {
                        createSubjectPool();
                        renderAllAllocations();
                        updateStats();
                        clearActionHistory();
                    } else {
                        updateStats();
                    }

                    focusSubjectPool();

                    showDownloadNotification(`Added ${summary.cellCount} cells for ${yearLabel}.`, { icon: '', duration: 5000 });
                    resetDisplay();
                    setStatus('Patch applied successfully. Upload another file when ready.', 'success');
                } catch (error) {
                    alert('Could not apply patch: ' + error.message);
                    setStatus('Could not apply patch: ' + error.message, 'error');
                }
            });

            renderCells([]);
        }

        // Load saved data on page load
        function loadSavedData() {
            const savedData = localStorage.getItem('facultyAllocations');
            if (savedData) {
                try {
                    const data = JSON.parse(savedData);
                    loadAllocations(data);
                } catch (error) {
                    console.error('Error loading saved data:', error);
                }
            }
        }

        function setupPrintButton() {
            const button = document.getElementById('printMatrixBtn');
            if (!button) {
                return;
            }

            button.addEventListener('click', function() {
                try {
                    window.print();
                } catch (error) {
                    console.error('Error opening print dialog:', error);
                    alert('Unable to open the print dialog: ' + error.message);
                }
            });
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            try {
                initializeTimetable();
                loadSavedData();
                setupModalEventListeners();
                setupClashModalEventListeners();
                setupRoomModal();
                initializeLineCellsConverter();
                setupPrintButton();
            } catch (error) {
                console.error('Error during initialization:', error);
                alert('Error initializing application: ' + error.message);
            }
        });

        // Global error handler
        window.addEventListener('error', function(e) {
            console.error('JavaScript error:', e.error);
            alert('JavaScript error: ' + e.message);
        });


        function setupModalEventListeners() {
            const modal = document.getElementById('autocompleteModal');
            const input = document.getElementById('autocompleteInput');
            const confirmBtn = document.getElementById('confirmBtn');
            const cancelBtn = document.getElementById('cancelBtn');
            const closeBtn = document.querySelector('.close');
            const modalContent = document.querySelector('.modal-content');

            if (modalContent) {
                modalContent.setAttribute('tabindex', '-1');
            }

            // Close modal events
            closeBtn.addEventListener('click', closeModal);
            cancelBtn.addEventListener('click', closeModal);
            window.addEventListener('click', function(event) {
                if (event.target === modal) {
                    closeModal();
                }
            });

            // Confirm button
            confirmBtn.addEventListener('click', confirmSelection);

            const handleKeyNavigation = (event, options = {}) => {
                const items = document.querySelectorAll('.autocomplete-item');

                if (event.key === 'ArrowDown') {
                    event.preventDefault();
                    selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                    updateSelection();
                } else if (event.key === 'ArrowUp') {
                    event.preventDefault();
                    selectedIndex = Math.max(selectedIndex - 1, -1);
                    updateSelection();
                } else if (event.key === 'Enter') {
                    event.preventDefault();
                    confirmSelection();
                } else if (event.key === 'Escape') {
                    if (options.allowEscape !== false) {
                        event.preventDefault();
                        closeModal();
                    }
                }
            };

            // Input events
            input.addEventListener('input', function() {
                updateFilteredList(this.value);
            });

            // Keyboard navigation when typing
            input.addEventListener('keydown', function(e) {
                handleKeyNavigation(e);
            });

            if (modalContent) {
                modalContent.addEventListener('keydown', function(e) {
                    if (currentAutocompleteOptions.hideSearchInput) {
                        handleKeyNavigation(e);
                    } else if (e.key === 'Escape') {
                        handleKeyNavigation(e);
                    }
                });
            }
        }
    </script>
</body>
</html>
