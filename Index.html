<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Faculty Staff Allocation Interface</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
        }

        .controls {
            padding: 20px;
            background: #ecf0f1;
            border-bottom: 1px solid #bdc3c7;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover {
            background: #229954;
        }

        .btn-warning {
            background: #f39c12;
            color: white;
        }

        .btn-warning:hover {
            background: #e67e22;
        }

        .timetable-container {
            padding: 20px;
            overflow-x: auto;
        }

        .timetable {
            min-width: 1200px;
            border-collapse: collapse;
            width: 100%;
        }

        .timetable th {
            background: #34495e;
            color: white;
            padding: 15px 10px;
            text-align: center;
            font-weight: 600;
            border: 1px solid #2c3e50;
        }

        .timetable td {
            padding: 8px;
            border: 1px solid #bdc3c7;
            vertical-align: top;
            min-height: 60px;
            position: relative;
        }

        .teacher-column {
            background: #ecf0f1;
            font-weight: 600;
            text-align: center;
            width: 150px;
        }

        .period-row {
            background: #f8f9fa;
            font-weight: 600;
            text-align: center;
            width: 100px;
        }

        .tlc-period-label {
            background: #f0f6ff;
            font-weight: 600;
            text-align: center;
        }

        .tlc-period-cell {
            background: #eef6ff;
            color: #1f4e79;
            font-weight: 600;
            text-align: center;
        }

        .subject-slot {
            background: #e8f4f8;
            border: 2px dashed #3498db;
            border-radius: 4px;
            padding: 8px;
            margin: 2px 0;
            cursor: move;
            transition: all 0.3s ease;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 500;
        }

        .subject-slot:hover {
            background: #d5e8f0;
            border-color: #2980b9;
        }

        .subject-slot.split-subject:hover,
        .subject-slot.split-segment:hover {
            background: #ffe9cc;
            border-color: #f39c12;
        }

        .subject-slot.split-subject,
        .subject-slot.split-segment {
            background: #fff7e6;
            border-color: #f39c12;
            color: #8a6d3b;
        }

        .subject-slot.split-subject {
            border-style: dashed;
            flex-direction: column;
            align-items: flex-start;
            justify-content: flex-start;
            gap: 4px;
        }

        .subject-slot.split-segment {
            border-style: solid;
            flex-direction: column;
            align-items: flex-start;
            justify-content: flex-start;
            gap: 4px;
        }

        .subject-slot.split-subject .split-subject-base,
        .subject-slot.split-segment .split-subject-base {
            font-weight: 600;
            font-size: 12px;
        }

        .subject-slot.split-subject .split-subject-details,
        .subject-slot.split-segment .split-subject-details {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            font-weight: 500;
        }

        .split-period-badge {
            background: #f39c12;
            color: #fff;
            border-radius: 12px;
            padding: 2px 8px;
            font-size: 11px;
            font-weight: 600;
        }

        .split-part-label {
            color: #b9770e;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-size: 10px;
        }

        .split-allocation-cell {
            background: #fffaf0;
        }

        .split-allocation-header {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #b9770e;
            margin-bottom: 4px;
        }

        .subject-slot.allocated {
            background: #ffebee;
            border: 2px solid #e74c3c;
            color: #c0392b;
        }

        .subject-slot.allocated:hover {
            background: #ffcdd2;
        }

        .drop-zone.clash-cell {
            background: #e6f0ff;
            border-color: #2980b9;
        }

        .drop-zone.semester-pair-cell {
            background: #d4edda;
            border-color: #27ae60;
        }

        .subject-slot.clash {
            background: #e6f0ff;
            border: 2px solid #2980b9;
            color: #1f4e79;
        }

        .subject-slot.semester-pair {
            background: #d4edda;
            border: 2px solid #27ae60;
            color: #1e8449;
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-items: stretch;
        }

        .subject-slot.semester-pair .semester-pair-item {
            background: rgba(39, 174, 96, 0.1);
            border-radius: 4px;
            padding: 2px 4px;
            font-size: 11px;
            cursor: move;
        }

        .subject-slot.semester-pair .semester-pair-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #1e8449;
            text-align: center;
            border-top: 1px dashed rgba(39, 174, 96, 0.4);
            padding-top: 4px;
            margin-top: 4px;
        }

        .subject-pool-grid {
            display: grid;
            gap: 15px;
            margin-top: 10px;
            align-items: flex-start;
        }

        .subject-pool-column {
            background: #ffffff;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 10px;
            display: flex;
            flex-direction: column;
        }

        .subject-pool-column h4 {
            font-size: 0.9rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 10px;
            text-align: center;
        }

        .subject-pool-column-body {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .subject-pool-column-body .subject-slot {
            margin: 0;
        }

        .subject-pool-column--unassigned {
            grid-column: 1 / -1;
            margin-top: 10px;
        }

        .teacher-period-summary {
            margin-top: 20px;
            padding: 24px;
            background: linear-gradient(135deg, #f4f8ff 0%, #eef2ff 100%);
            border-radius: 16px;
            border: 1px solid #d7e3f5;
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.12);
        }

        .teacher-period-summary h3 {
            font-size: 1.2rem;
            color: #1f3d63;
            margin-bottom: 8px;
        }

        .teacher-period-subtitle {
            font-size: 0.85rem;
            color: #58708c;
            margin-bottom: 14px;
            line-height: 1.45;
        }

        .teacher-period-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 18px;
            font-size: 0.75rem;
            color: #58708c;
        }

        .teacher-period-legend span {
            background: rgba(255, 255, 255, 0.65);
            border-radius: 999px;
            padding: 6px 12px;
            border: 1px solid rgba(52, 152, 219, 0.15);
            color: #425d78;
            box-shadow: 0 1px 2px rgba(44, 62, 80, 0.08);
        }

        .teacher-card-toggle-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: flex-end;
            margin: 12px 0 6px;
        }

        .btn-compact {
            padding: 6px 12px;
            font-size: 12px;
        }

        .teacher-period-grid {
            display: grid;
            gap: 16px;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        }

        .teacher-period-card {
            position: relative;
            background: #ffffff;
            border: 1px solid #dbe2e8;
            border-radius: 12px;
            box-shadow: 0 2px 6px rgba(44, 62, 80, 0.08);
            transition: box-shadow 0.3s ease, border-color 0.3s ease, transform 0.3s ease;
            overflow: hidden;
            border-left: 6px solid transparent;
        }

        .teacher-period-card.balance-positive {
            border-left-color: #27ae60;
        }

        .teacher-period-card.balance-negative {
            border-left-color: #e74c3c;
        }

        .teacher-period-card[open] {
            box-shadow: 0 8px 18px rgba(52, 152, 219, 0.18);
            transform: translateY(-1px);
            border-color: rgba(52, 152, 219, 0.35);
        }

        .teacher-card-summary {
            list-style: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 14px 16px;
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.12), rgba(52, 152, 219, 0.04));
            cursor: pointer;
            user-select: none;
            font-size: 0.95rem;
            font-weight: 600;
            color: #2c3e50;
        }

        .teacher-period-card.balance-negative > .teacher-card-summary {
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.12), rgba(231, 76, 60, 0.04));
        }

        .teacher-card-summary::-webkit-details-marker {
            display: none;
        }

        .teacher-card-summary:focus {
            outline: none;
        }

        .teacher-card-summary::after {
            content: '\25BC';
            font-size: 0.75rem;
            color: inherit;
            transition: transform 0.3s ease;
        }

        .teacher-period-card:not([open]) > .teacher-card-summary::after {
            transform: rotate(-90deg);
        }

        .teacher-card-summary-main {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .teacher-card-summary-chips {
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-end;
            gap: 6px;
        }

        .teacher-card-chip {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.75);
            border: 1px solid rgba(52, 152, 219, 0.2);
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #2c3e50;
        }

        .teacher-card-chip.fte-chip {
            background: rgba(155, 89, 182, 0.18);
            border-color: rgba(155, 89, 182, 0.3);
            color: #7d3c98;
        }

        .teacher-card-chip.load-chip {
            background: rgba(52, 152, 219, 0.18);
            border-color: rgba(52, 152, 219, 0.3);
            color: #1f618d;
        }

        .teacher-card-chip.balance-chip.positive {
            background: rgba(39, 174, 96, 0.18);
            border-color: rgba(39, 174, 96, 0.3);
            color: #1e8449;
        }

        .teacher-card-chip.balance-chip.negative {
            background: rgba(231, 76, 60, 0.18);
            border-color: rgba(231, 76, 60, 0.3);
            color: #c0392b;
        }

        .teacher-card-body {
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            background: #ffffff;
            border-top: 1px solid #e3ebf3;
        }

        .teacher-card-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 12px;
        }

        .teacher-period-name {
            font-size: 1rem;
            font-weight: 600;
            color: #2c3e50;
        }

        .teacher-fte-control {
            display: flex;
            flex-direction: column;
            font-size: 0.75rem;
            color: #7f8c8d;
            text-align: right;
            margin-left: auto;
        }

        .teacher-fte-control label {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 4px;
        }

        .teacher-fte-control select {
            padding: 6px 10px;
            border: 1px solid #ccd9e4;
            border-radius: 6px;
            font-size: 0.85rem;
            background: #ffffff;
            color: #2c3e50;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }

        .teacher-fte-control select:focus {
            border-color: #3498db;
            outline: none;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.18);
        }

        .teacher-card-section-title {
            font-size: 0.72rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: #5d6d7e;
        }

        .teacher-load-inputs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 12px;
        }

        .teacher-load-input {
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 0.75rem;
            color: #34495e;
            background: #f8fbff;
            border: 1px solid #d8e3f1;
            border-radius: 10px;
            padding: 10px;
            box-shadow: inset 0 1px 2px rgba(44, 62, 80, 0.05);
        }

        .teacher-load-input label {
            font-weight: 700;
            color: #2c3e50;
        }

        .teacher-load-input input {
            padding: 6px 8px;
            border: 1px solid #cbd7e3;
            border-radius: 6px;
            font-size: 0.8rem;
            color: #2c3e50;
            background: #ffffff;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }

        .teacher-load-input input:focus {
            border-color: #3498db;
            outline: none;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.18);
        }

        .teacher-load-input-note {
            font-size: 0.7rem;
            color: #7f8c8d;
        }

        .teacher-load-summary {
            background: linear-gradient(135deg, #f8fbff, #eef4ff);
            border: 1px dashed #c9dbf3;
            border-radius: 12px;
            padding: 14px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-size: 0.75rem;
            color: #34495e;
        }

        .teacher-load-row {
            display: flex;
            justify-content: space-between;
            gap: 8px;
        }

        .teacher-load-row span:first-child {
            color: #5d6d7e;
            text-transform: uppercase;
            letter-spacing: 0.04em;
        }

        .teacher-load-row span:last-child {
            font-weight: 700;
            text-align: right;
            color: #2c3e50;
        }

        .teacher-load-balance span:last-child {
            font-weight: 800;
        }

        .teacher-load-balance.positive span:last-child {
            color: #27ae60;
        }

        .teacher-load-balance.negative span:last-child {
            color: #c0392b;
        }

        .teacher-load-note {
            font-size: 0.7rem;
            color: #5f6a6a;
        }

        .teacher-period-empty {
            grid-column: 1 / -1;
            text-align: center;
            color: #7f8c8d;
            font-style: italic;
            padding: 10px 0;
        }

        .subject-slot.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }

        .drop-zone {
            background: #f0f8ff;
            border: 2px dashed #3498db;
            border-radius: 4px;
            min-height: 60px;
            transition: all 0.3s ease;
        }

        .drop-zone.drag-over {
            background: #e3f2fd;
            border-color: #2196f3;
            transform: scale(1.02);
        }

        .stats {
            padding: 20px;
            background: #f8f9fa;
            border-top: 1px solid #dee2e6;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            color: #2c3e50;
        }

        .stat-label {
            color: #7f8c8d;
            font-size: 0.9rem;
            margin-top: 5px;
        }

        .legend {
            display: flex;
            gap: 20px;
            align-items: center;
            margin-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .legend-color.available {
            background: #e8f4f8;
            border: 2px dashed #3498db;
        }

        .legend-color.allocated {
            background: #ffebee;
            border: 2px solid #e74c3c;
        }

        .legend-color.semester-pair {
            background: #d4edda;
            border: 2px solid #27ae60;
        }

        .legend-color.clash {
            background: #e6f0ff;
            border: 2px solid #2980b9;
        }

        .legend-color.split {
            background: #fff7e6;
            border: 2px solid #f39c12;
        }

        /* Autocomplete styles */
        .autocomplete-container {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .autocomplete-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            box-sizing: border-box;
        }

        .autocomplete-input:focus {
            border-color: #3498db;
            outline: none;
        }

        .autocomplete-list {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .autocomplete-item {
            padding: 10px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }

        .autocomplete-item:hover,
        .autocomplete-item.selected {
            background-color: #f0f8ff;
            color: #2c3e50;
        }

        .autocomplete-item:last-child {
            border-bottom: none;
        }

        .autocomplete-item.empty-message {
            color: #7f8c8d;
            cursor: default;
            font-style: italic;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: white;
            margin: 10% auto;
            padding: 20px;
            border-radius: 8px;
            width: 400px;
            max-width: 90%;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #2c3e50;
        }

        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: #000;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .timetable-container {
                padding: 10px;
            }

            .timetable {
                font-size: 12px;
            }

            .teacher-period-grid {
                grid-template-columns: 1fr;
            }

            .teacher-card-summary {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }

            .teacher-card-summary::after {
                align-self: flex-start;
            }

            .teacher-card-summary-chips {
                justify-content: flex-start;
            }

            .teacher-card-controls {
                flex-direction: column;
                align-items: stretch;
            }

            .teacher-fte-control {
                margin-left: 0;
                text-align: left;
            }

            .modal-content {
                margin: 5% auto;
                width: 95%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Faculty Staff Allocation Interface</h1>
            <p>Import your spreadsheet data and allocate subject codes to teachers by line</p>
        </div>

        <div class="controls">
            <button class="btn btn-primary" onclick="importSpreadsheet()">Import Spreadsheet</button>
            <button class="btn btn-primary" onclick="allocateNewSubject()">Allocate New Subject</button>
            <button class="btn btn-primary" onclick="splitSubject()">Split Subject</button>
            <button class="btn btn-primary" onclick="moveExistingAllocation()">Move Existing Allocation</button>
            <button class="btn btn-secondary" onclick="undoLastAction()" id="undoBtn" disabled>Undo</button>
            <button class="btn btn-secondary" onclick="redoLastAction()" id="redoBtn" disabled>Redo</button>
            <button class="btn btn-success" onclick="saveAllocations()">Save Allocations</button>
            <button class="btn btn-warning" onclick="resetAllocations()">Reset Allocations</button>
            <button class="btn btn-primary" onclick="exportData()">Export Data</button>
            <button class="btn btn-primary" onclick="openManagementHub()">Management Hub</button>
            <button class="btn btn-primary" onclick="importSupplementalData()">Import Additional Info</button>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color available"></div>
                    <span>Available Subject</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color allocated"></div>
                    <span>Allocated Subject</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color split"></div>
                    <span>Split Allocation Portion</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color semester-pair"></div>
                    <span>Year 8 S1/S2 Pair</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color clash"></div>
                    <span>Allocation Clash</span>
                </div>
            </div>
        </div>

        <div class="timetable-container">
            <table class="timetable" id="timetable">
                <thead id="timetableHead">
                    <tr>
                        <th>Line</th>
                        <!-- Teachers will be dynamically added here -->
                    </tr>
                </thead>
                <tbody id="timetableBody">
                    <!-- Periods will be generated by JavaScript -->
                </tbody>
            </table>
        </div>

        <div class="stats">
            <div class="stat-card">
                <div class="stat-number" id="totalSubjects">0</div>
                <div class="stat-label">Total Subjects</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="allocatedSubjects">0</div>
                <div class="stat-label">Allocated Subjects</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="remainingSubjects">0</div>
                <div class="stat-label">Available Subjects</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="allocationPercentage">0%</div>
                <div class="stat-label">Allocation Progress</div>
            </div>
        </div>
    </div>

    <!-- Autocomplete Modal -->
    <div id="autocompleteModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title" id="modalTitle">Select Item</span>
                <span class="close">&times;</span>
            </div>
            <div class="autocomplete-container">
                <input type="text" id="autocompleteInput" class="autocomplete-input" placeholder="Type to filter options...">
                <div id="autocompleteList" class="autocomplete-list" style="display: none;"></div>
            </div>
            <div class="modal-buttons">
                <button class="btn btn-primary" id="confirmBtn">Confirm</button>
                <button class="btn btn-warning" id="cancelBtn">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Dynamic data loaded from spreadsheet
        let subjects = [];
        let teachers = [];
        let years = ['Year 12', 'Year 11', 'Year 10', 'Year 9', 'Year 8'];
        let lines = ['Line 1', 'Line 2', 'Line 3', 'Line 4', 'Line 5', 'Line 6'];
        let teacherAllocations = {}; // Stores which teachers can teach which lines
        let subjectLineMapping = {}; // Maps subject codes to their correct line index
        let actionHistory = []; // Stores undo history
        let redoStack = []; // Stores redo history
        let csvData = [];

        let allocations = {};
        let draggedElement = null;
        let subjectSplits = {};
        let splitSubjectLookup = {};

        const FTE_OPTIONS = ['1.0', '0.8', '0.6', '0.4', '0.2'];
        const FTE_LOAD_MAPPING = {
            '1.0': 37.95,
            '0.8': 30.35,
            '0.6': 22.77,
            '0.4': 15.17,
            '0.2': 11.8
        };
        const DEFAULT_FTE_VALUE = '1.0';
        const PERIOD_MINUTES = 59;
        const TLC_MINUTES = 19;
        const ASSEMBLY_FULL_PERIOD_EQUIVALENT = 0.62;
        const ASSEMBLY_FULL_MINUTES = PERIOD_MINUTES * ASSEMBLY_FULL_PERIOD_EQUIVALENT;
        const ASSEMBLY_SHORT_MINUTES = TLC_MINUTES;
        const ASSEMBLY_SHORT_PERIOD_EQUIVALENT = ASSEMBLY_SHORT_MINUTES / PERIOD_MINUTES;

        let teacherLoadSettings = {};

        const YEAR_PERIOD_ALLOCATION = {
            12: 7,
            11: 7,
            10: 5,
            9: 6
        };

        const YEAR8_ELECTIVE_PERIODS = 3;
        const YEAR8_TECH_MANDATORY_PERIODS = 5;
        const YEAR7_TECH_MANDATORY_PERIODS = 5;

        function resetSplitData() {
            subjectSplits = {};
            splitSubjectLookup = {};
        }

        function rebuildSplitLookup() {
            splitSubjectLookup = {};

            Object.entries(subjectSplits).forEach(([baseSubject, splits]) => {
                if (!Array.isArray(splits)) {
                    return;
                }

                splits.forEach(split => {
                    if (!split || typeof split.code !== 'string') {
                        return;
                    }

                    const totalSplits = Number.isFinite(split.totalSplits) ? split.totalSplits : splits.length;

                    splitSubjectLookup[split.code] = {
                        baseSubject: baseSubject,
                        periods: Number.isFinite(split.periods) ? split.periods : parseInt(split.periods, 10) || 0,
                        index: Number.isFinite(split.index) ? split.index : parseInt(split.index, 10) || 0,
                        totalSplits: totalSplits
                    };
                });
            });
        }

        function getSplitSubjectsForBase(baseSubject) {
            if (!baseSubject || !subjectSplits[baseSubject]) {
                return [];
            }
            return subjectSplits[baseSubject]
                .filter(split => split && typeof split.code === 'string')
                .map(split => split.code);
        }

        function isSplitSubject(subjectCode) {
            return Boolean(splitSubjectLookup[subjectCode]);
        }

        function getSplitMetadata(subjectCode) {
            return splitSubjectLookup[subjectCode] || null;
        }

        function applySubjectDisplay(element, subjectCode, options = {}) {
            if (!element) {
                return;
            }

            element.classList.remove('split-subject', 'split-segment');
            element.innerHTML = '';
            element.dataset.baseSubject = '';
            element.dataset.splitIndex = '';
            element.dataset.splitTotal = '';
            element.dataset.periods = '';

            const splitInfo = getSplitMetadata(subjectCode);

            if (!splitInfo) {
                element.textContent = subjectCode;
                element.title = subjectCode || '';
                return;
            }

            const { baseSubject, periods, index, totalSplits } = splitInfo;
            const hideBaseLabel = options.hideBaseLabel === true;

            element.classList.add(options.forceSegmentStyle ? 'split-segment' : 'split-subject');

            element.dataset.baseSubject = baseSubject;
            element.dataset.splitIndex = index;
            element.dataset.splitTotal = totalSplits;
            element.dataset.periods = periods;

            if (!hideBaseLabel) {
                const baseLabel = document.createElement('div');
                baseLabel.className = 'split-subject-base';
                baseLabel.textContent = baseSubject;
                element.appendChild(baseLabel);
            }

            const details = document.createElement('div');
            details.className = 'split-subject-details';

            const periodBadge = document.createElement('span');
            periodBadge.className = 'split-period-badge';
            periodBadge.textContent = `${periods}p`;
            details.appendChild(periodBadge);

            const partLabel = document.createElement('span');
            partLabel.className = 'split-part-label';
            partLabel.textContent = `Split ${index + 1}/${totalSplits}`;
            details.appendChild(partLabel);

            element.appendChild(details);

            element.title = `${baseSubject} – ${periods} period${periods === 1 ? '' : 's'} (Split ${index + 1}/${totalSplits})`;
        }

        function getAllocationKey(lineIndex, teacherIndex) {
            return `${lineIndex}-${teacherIndex}`;
        }

        function getAllocationSubjects(key) {
            const value = allocations[key];
            if (!value) {
                return [];
            }
            return Array.isArray(value) ? [...value] : [value];
        }

        function setAllocationSubjects(key, subjects) {
            if (!subjects || subjects.length === 0) {
                delete allocations[key];
            } else {
                allocations[key] = [...subjects];
            }
        }

        function flattenAllocatedSubjects() {
            const list = [];
            Object.values(allocations).forEach(value => {
                if (Array.isArray(value)) {
                    list.push(...value);
                } else if (value) {
                    list.push(value);
                }
            });
            return list;
        }

        function findSubjectLocation(subjectCode) {
            for (const [key, value] of Object.entries(allocations)) {
                const subjects = Array.isArray(value) ? value : [value];
                const index = subjects.indexOf(subjectCode);
                if (index !== -1) {
                    const [lineIndex, teacherIndex] = key.split('-').map(Number);
                    return {
                        key,
                        lineIndex,
                        teacherIndex,
                        index
                    };
                }
            }
            return null;
        }

        function clearActionHistory() {
            actionHistory = [];
            redoStack = [];

            const undoBtn = document.getElementById('undoBtn');
            if (undoBtn) {
                undoBtn.disabled = true;
            }

            const redoBtn = document.getElementById('redoBtn');
            if (redoBtn) {
                redoBtn.disabled = true;
            }
        }

        function resolveLineReference(reference) {
            if (reference === null || reference === undefined) {
                return null;
            }

            if (Number.isInteger(reference)) {
                return reference >= 0 && reference < lines.length ? reference : null;
            }

            if (typeof reference === 'string') {
                const trimmed = reference.trim();
                if (trimmed.length === 0) {
                    return null;
                }

                const labelIndex = lines.indexOf(trimmed);
                if (labelIndex !== -1) {
                    return labelIndex;
                }

                const numeric = parseInt(trimmed, 10);
                if (!Number.isNaN(numeric) && numeric >= 0 && numeric < lines.length) {
                    return numeric;
                }
            }

            const numericValue = Number(reference);
            if (Number.isInteger(numericValue) && numericValue >= 0 && numericValue < lines.length) {
                return numericValue;
            }

            return null;
        }

        function addTeacher(teacherName, options = {}) {
            const { skipRefresh = false, silent = false } = options;

            if (!teacherName || typeof teacherName !== 'string') {
                if (!silent) {
                    alert('Teacher name cannot be empty.');
                }
                return false;
            }

            const trimmedName = teacherName.trim();
            if (trimmedName.length === 0) {
                if (!silent) {
                    alert('Teacher name cannot be empty.');
                }
                return false;
            }

            if (teachers.includes(trimmedName)) {
                if (!silent) {
                    alert('This teacher already exists.');
                }
                return false;
            }

            teachers.push(trimmedName);
            getTeacherLoadSettings(trimmedName);

            if (!skipRefresh) {
                initializeTimetable();
                createSubjectPool();
                updateStats();
            }

            return true;
        }

        function removeTeacher(teacherName, options = {}) {
            const { skipRefresh = false, silent = false } = options;
            const index = teachers.indexOf(teacherName);

            if (index === -1) {
                if (!silent) {
                    alert('Teacher not found.');
                }
                return null;
            }

            const removedSubjects = [];
            const updatedAllocations = {};

            Object.entries(allocations).forEach(([key, value]) => {
                const [lineIndex, teacherIndex] = key.split('-').map(Number);

                if (teacherIndex === index) {
                    const subjectList = Array.isArray(value) ? value : [value];
                    subjectList.forEach(subject => {
                        if (subject) {
                            removedSubjects.push(subject);
                        }
                    });
                    return;
                }

                const newTeacherIndex = teacherIndex > index ? teacherIndex - 1 : teacherIndex;
                const subjectList = Array.isArray(value) ? [...value] : [value];

                if (subjectList.length > 0) {
                    updatedAllocations[`${lineIndex}-${newTeacherIndex}`] = subjectList;
                }
            });

            teachers.splice(index, 1);
            delete teacherLoadSettings[teacherName];
            if (teacherAllocations && typeof teacherAllocations === 'object') {
                delete teacherAllocations[teacherName];
            }

            allocations = {};
            Object.entries(updatedAllocations).forEach(([key, value]) => {
                setAllocationSubjects(key, Array.isArray(value) ? value : [value]);
            });

            clearActionHistory();

            if (!skipRefresh) {
                initializeTimetable();
                createSubjectPool();
                updateStats();
            }

            return {
                removedSubjects: removedSubjects,
                removedCount: removedSubjects.length
            };
        }

        function addLine(lineLabel, options = {}) {
            const { skipRefresh = false, silent = false } = options;

            if (!lineLabel || typeof lineLabel !== 'string') {
                if (!silent) {
                    alert('Line name cannot be empty.');
                }
                return false;
            }

            const trimmedLabel = lineLabel.trim();
            if (trimmedLabel.length === 0) {
                if (!silent) {
                    alert('Line name cannot be empty.');
                }
                return false;
            }

            if (lines.includes(trimmedLabel)) {
                if (!silent) {
                    alert('This line already exists.');
                }
                return false;
            }

            lines.push(trimmedLabel);

            if (!skipRefresh) {
                initializeTimetable();
                createSubjectPool();
                updateStats();
            }

            return true;
        }

        function removeLine(lineLabel, options = {}) {
            const { skipRefresh = false, silent = false } = options;
            const index = lines.indexOf(lineLabel);

            if (index === -1) {
                if (!silent) {
                    alert('Line not found.');
                }
                return null;
            }

            const removedSubjects = [];
            const updatedAllocations = {};

            Object.entries(allocations).forEach(([key, value]) => {
                const [lineIndex, teacherIndex] = key.split('-').map(Number);

                if (lineIndex === index) {
                    const subjectList = Array.isArray(value) ? value : [value];
                    subjectList.forEach(subject => {
                        if (subject) {
                            removedSubjects.push(subject);
                        }
                    });
                    return;
                }

                const newLineIndex = lineIndex > index ? lineIndex - 1 : lineIndex;
                const subjectList = Array.isArray(value) ? [...value] : [value];

                if (subjectList.length > 0) {
                    updatedAllocations[`${newLineIndex}-${teacherIndex}`] = subjectList;
                }
            });

            lines.splice(index, 1);

            Object.keys(subjectLineMapping).forEach(subject => {
                const mappedLine = subjectLineMapping[subject];
                if (mappedLine === index) {
                    delete subjectLineMapping[subject];
                } else if (Number.isInteger(mappedLine) && mappedLine > index) {
                    subjectLineMapping[subject] = mappedLine - 1;
                }
            });

            allocations = {};
            Object.entries(updatedAllocations).forEach(([key, value]) => {
                setAllocationSubjects(key, Array.isArray(value) ? value : [value]);
            });

            clearActionHistory();

            if (!skipRefresh) {
                initializeTimetable();
                createSubjectPool();
                updateStats();
            }

            return {
                removedSubjects: removedSubjects,
                removedCount: removedSubjects.length
            };
        }

        function addSubjectCode(subjectCode, options = {}) {
            const { lineIndex = null, skipRefresh = false, silent = false } = options;

            if (subjectCode === null || subjectCode === undefined) {
                if (!silent) {
                    alert('Subject code cannot be empty.');
                }
                return false;
            }

            const normalizedCode = normalizeSubjectCode(subjectCode);
            if (!normalizedCode) {
                if (!silent) {
                    alert('Subject code cannot be empty.');
                }
                return false;
            }

            if (subjects.includes(normalizedCode)) {
                if (!silent) {
                    alert('This subject already exists.');
                }
                return false;
            }

            subjects.push(normalizedCode);

            if (Number.isInteger(lineIndex) && lineIndex >= 0 && lineIndex < lines.length) {
                subjectLineMapping[normalizedCode] = lineIndex;
            } else {
                delete subjectLineMapping[normalizedCode];
            }

            if (!skipRefresh) {
                createSubjectPool();
                updateStats();
            }

            return true;
        }

        function removeSubjectCode(subjectCode, options = {}) {
            const { skipRefresh = false, silent = false } = options;

            if (!subjectCode) {
                if (!silent) {
                    alert('Subject code cannot be empty.');
                }
                return null;
            }

            const normalizedCode = normalizeSubjectCode(subjectCode);
            const isBaseSubject = Boolean(subjectSplits[normalizedCode]);
            const splitMetadata = getSplitMetadata(normalizedCode);
            const exists = subjects.includes(normalizedCode) || isBaseSubject || Boolean(splitMetadata);

            if (!exists) {
                if (!silent) {
                    alert('Subject not found.');
                }
                return null;
            }

            const removedCodes = new Set();
            let removedFromAllocations = 0;

            function removeAllocationsForSubject(code) {
                if (!code) {
                    return;
                }

                let location = findSubjectLocation(code);
                while (location) {
                    const key = getAllocationKey(location.lineIndex, location.teacherIndex);
                    const subjectsInCell = getAllocationSubjects(key).filter(subject => subject !== code);
                    setAllocationSubjects(key, subjectsInCell);
                    removedFromAllocations++;
                    location = findSubjectLocation(code);
                }
            }

            function removeCodeFromLists(code) {
                if (!code) {
                    return;
                }

                subjects = subjects.filter(subject => subject !== code);
                delete subjectLineMapping[code];
                removeSubjectFromPool(code);
                removedCodes.add(code);
            }

            if (isBaseSubject) {
                const splits = Array.isArray(subjectSplits[normalizedCode]) ? subjectSplits[normalizedCode] : [];
                splits.forEach(split => {
                    if (split && typeof split.code === 'string') {
                        removeAllocationsForSubject(split.code);
                        removeCodeFromLists(split.code);
                    }
                });

                removeAllocationsForSubject(normalizedCode);
                removeCodeFromLists(normalizedCode);

                delete subjectSplits[normalizedCode];
                rebuildSplitLookup();
            } else if (splitMetadata) {
                const baseSubject = splitMetadata.baseSubject;
                removeAllocationsForSubject(normalizedCode);
                removeCodeFromLists(normalizedCode);

                if (baseSubject && Array.isArray(subjectSplits[baseSubject])) {
                    const remainingSplits = subjectSplits[baseSubject]
                        .filter(split => split && split.code !== normalizedCode);

                    if (remainingSplits.length === 0) {
                        delete subjectSplits[baseSubject];
                        rebuildSplitLookup();
                        if (!subjects.includes(baseSubject)) {
                            subjects.push(baseSubject);
                        }
                    } else {
                        subjectSplits[baseSubject] = remainingSplits.map((split, index) => ({
                            ...split,
                            index: index,
                            totalSplits: remainingSplits.length
                        }));
                        rebuildSplitLookup();
                    }
                } else {
                    rebuildSplitLookup();
                }
            } else {
                removeAllocationsForSubject(normalizedCode);
                removeCodeFromLists(normalizedCode);
            }

            clearActionHistory();

            if (!skipRefresh) {
                renderAllAllocations();
                createSubjectPool();
                updateStats();
            }

            return {
                removedSubjects: Array.from(removedCodes),
                removedCount: removedCodes.size,
                removedFromAllocations: removedFromAllocations
            };
        }

        function manageTeachers(actionOverride = null) {
            const actions = ['Add Teacher', 'Remove Teacher'];

            function handleTeacherAction(selectedAction) {
                if (selectedAction === 'Add Teacher') {
                    setTimeout(() => {
                        const name = prompt('Enter the name of the new teacher:');
                        if (name === null) {
                            return;
                        }

                        if (addTeacher(name)) {
                            alert(`Added ${name.trim()}.`);
                        }
                    }, 200);
                } else if (selectedAction === 'Remove Teacher') {
                    if (!Array.isArray(teachers) || teachers.length === 0) {
                        alert('There are no teachers to remove.');
                        return;
                    }

                    setTimeout(() => {
                        showAutocomplete('Select teacher to remove', teachers, function(selectedTeacher) {
                            if (!confirm(`Remove ${selectedTeacher} and return their allocations to the pool?`)) {
                                return;
                            }

                            const result = removeTeacher(selectedTeacher);
                            if (result) {
                                const removalMessage = result.removedCount > 0
                                    ? `${result.removedCount} subject${result.removedCount === 1 ? '' : 's'} returned to the pool.`
                                    : 'No subjects were allocated to this teacher.';
                                alert(`Removed ${selectedTeacher}. ${removalMessage}`);
                            }
                        });
                    }, 200);
                }
            }

            if (actionOverride && actions.includes(actionOverride)) {
                handleTeacherAction(actionOverride);
                return;
            }

            showAutocomplete('Select teacher management action', actions, handleTeacherAction);
        }

        function manageSubjects(actionOverride = null) {
            const actions = ['Add Subject', 'Remove Subject'];

            function handleSubjectAction(selectedAction) {
                if (selectedAction === 'Add Subject') {
                    setTimeout(() => {
                        const codeInput = prompt('Enter the new subject code:');
                        if (codeInput === null) {
                            return;
                        }

                        const normalized = normalizeSubjectCode(codeInput);
                        if (!normalized) {
                            alert('Subject code cannot be empty.');
                            return;
                        }

                        const lineOptions = Array.isArray(lines) && lines.length > 0 ? [...lines] : [];
                        lineOptions.push('Unassigned');

                        setTimeout(() => {
                            showAutocomplete(`Select default line for ${normalized}`, lineOptions, function(selectedLine) {
                                let lineIndex = null;
                                if (selectedLine && selectedLine !== 'Unassigned') {
                                    const index = lines.indexOf(selectedLine);
                                    if (index === -1) {
                                        alert('Invalid line selection.');
                                        return;
                                    }
                                    lineIndex = index;
                                }

                                if (addSubjectCode(normalized, { lineIndex: lineIndex })) {
                                    if (lineIndex !== null && lines[lineIndex]) {
                                        alert(`Added subject ${normalized} to ${lines[lineIndex]}.`);
                                    } else {
                                        alert(`Added subject ${normalized} (unassigned).`);
                                    }
                                }
                            });
                        }, 200);
                    }, 200);
                } else if (selectedAction === 'Remove Subject') {
                    const removalOptions = new Set(subjects);
                    Object.keys(subjectSplits).forEach(baseSubject => removalOptions.add(baseSubject));

                    if (removalOptions.size === 0) {
                        alert('There are no subjects to remove.');
                        return;
                    }

                    const options = Array.from(removalOptions);

                    setTimeout(() => {
                        showAutocomplete('Select subject to remove', options, function(selectedSubject) {
                            if (!confirm(`Remove ${selectedSubject} from the subject pool? Allocations will be cleared.`)) {
                                return;
                            }

                            const result = removeSubjectCode(selectedSubject);
                            if (result) {
                                const removalSummary = result.removedFromAllocations > 0
                                    ? `${result.removedFromAllocations} allocation${result.removedFromAllocations === 1 ? '' : 's'} cleared.`
                                    : 'No allocations needed to be cleared.';
                                alert(`Removed ${selectedSubject}. ${removalSummary}`);
                            }
                        });
                    }, 200);
                }
            }

            if (actionOverride && actions.includes(actionOverride)) {
                handleSubjectAction(actionOverride);
                return;
            }

            showAutocomplete('Select subject management action', actions, handleSubjectAction);
        }

        function manageLines(actionOverride = null) {
            const actions = ['Add Line', 'Remove Line'];

            function handleLineAction(selectedAction) {
                if (selectedAction === 'Add Line') {
                    setTimeout(() => {
                        const label = prompt('Enter a name for the new line:');
                        if (label === null) {
                            return;
                        }

                        if (addLine(label)) {
                            alert(`Added ${label.trim()}.`);
                        }
                    }, 200);
                } else if (selectedAction === 'Remove Line') {
                    if (!Array.isArray(lines) || lines.length === 0) {
                        alert('There are no lines to remove.');
                        return;
                    }

                    if (lines.length === 1) {
                        alert('At least one line must remain.');
                        return;
                    }

                    const options = [...lines];

                    setTimeout(() => {
                        showAutocomplete('Select line to remove', options, function(selectedLine) {
                            if (!confirm(`Remove ${selectedLine}? Subjects allocated on this line will return to the pool.`)) {
                                return;
                            }

                            const result = removeLine(selectedLine);
                            if (result) {
                                const summary = result.removedCount > 0
                                    ? `${result.removedCount} subject${result.removedCount === 1 ? '' : 's'} returned to the pool.`
                                    : 'No allocations were tied to this line.';
                                alert(`Removed ${selectedLine}. ${summary}`);
                            }
                        });
                    }, 200);
                }
            }

            if (actionOverride && actions.includes(actionOverride)) {
                handleLineAction(actionOverride);
                return;
            }

            showAutocomplete('Select line management action', actions, handleLineAction);
        }

        function openManagementHub() {
            const managementActions = [
                { label: 'Add Teacher', handler: () => manageTeachers('Add Teacher') },
                { label: 'Remove Teacher', handler: () => manageTeachers('Remove Teacher') },
                { label: 'Add Subject', handler: () => manageSubjects('Add Subject') },
                { label: 'Remove Subject', handler: () => manageSubjects('Remove Subject') },
                { label: 'Add Line', handler: () => manageLines('Add Line') },
                { label: 'Remove Line', handler: () => manageLines('Remove Line') }
            ];

            const labels = managementActions.map(action => action.label);

            showAutocomplete('Select management action', labels, function(selectedLabel) {
                const chosenAction = managementActions.find(action => action.label === selectedLabel);
                if (chosenAction && typeof chosenAction.handler === 'function') {
                    chosenAction.handler();
                }
            });
        }

        function importSupplementalData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';

            input.onchange = function(event) {
                const file = event.target.files && event.target.files[0];
                if (!file) {
                    return;
                }

                const reader = new FileReader();
                reader.onload = function(loadEvent) {
                    try {
                        const data = JSON.parse(loadEvent.target.result);
                        mergeSupplementalData(data);
                    } catch (error) {
                        alert('Error importing supplemental data: ' + error.message);
                        console.error('Supplemental import error:', error);
                    }
                };
                reader.readAsText(file);
            };

            input.click();
        }

        function mergeSupplementalData(data) {
            if (!data || typeof data !== 'object') {
                alert('Unsupported supplemental data format.');
                return;
            }

            let teachersAdded = 0;
            let linesAdded = 0;
            let subjectsAdded = 0;
            let mappingUpdated = 0;
            let splitsUpdated = 0;
            let loadUpdated = 0;
            const updatedMappingSubjects = new Set();

            if (Array.isArray(data.lines)) {
                data.lines.forEach(lineLabel => {
                    if (addLine(lineLabel, { skipRefresh: true, silent: true })) {
                        linesAdded++;
                    }
                });
            }

            if (Array.isArray(data.teachers)) {
                data.teachers.forEach(teacherName => {
                    if (addTeacher(teacherName, { skipRefresh: true, silent: true })) {
                        teachersAdded++;
                    }
                });
            }

            const mappingSource = data.subjectLineMapping && typeof data.subjectLineMapping === 'object'
                ? data.subjectLineMapping
                : {};

            if (Array.isArray(data.subjects)) {
                data.subjects.forEach(subjectCode => {
                    const normalized = normalizeSubjectCode(subjectCode);
                    if (!normalized) {
                        return;
                    }

                    let mappedLine = null;
                    if (mappingSource[subjectCode] !== undefined) {
                        mappedLine = resolveLineReference(mappingSource[subjectCode]);
                    } else if (mappingSource[normalized] !== undefined) {
                        mappedLine = resolveLineReference(mappingSource[normalized]);
                    }

                    const added = addSubjectCode(normalized, {
                        lineIndex: mappedLine,
                        skipRefresh: true,
                        silent: true
                    });

                    if (added) {
                        subjectsAdded++;
                    } else if (Number.isInteger(mappedLine) && mappedLine >= 0) {
                        if (subjectLineMapping[normalized] !== mappedLine) {
                            subjectLineMapping[normalized] = mappedLine;
                            if (!updatedMappingSubjects.has(normalized)) {
                                mappingUpdated++;
                                updatedMappingSubjects.add(normalized);
                            }
                        }
                    }
                });
            }

            Object.entries(mappingSource).forEach(([subjectCode, reference]) => {
                const normalized = normalizeSubjectCode(subjectCode);
                if (!normalized) {
                    return;
                }

                const resolvedLine = resolveLineReference(reference);
                if (resolvedLine === null) {
                    return;
                }

                if (subjectLineMapping[normalized] !== resolvedLine) {
                    subjectLineMapping[normalized] = resolvedLine;
                    if (!updatedMappingSubjects.has(normalized)) {
                        mappingUpdated++;
                        updatedMappingSubjects.add(normalized);
                    }
                }
            });

            if (data.subjectSplits && typeof data.subjectSplits === 'object') {
                Object.entries(data.subjectSplits).forEach(([baseSubject, splits]) => {
                    if (!Array.isArray(splits)) {
                        return;
                    }

                    const normalizedBase = normalizeSubjectCode(baseSubject);
                    const sanitizedSplits = splits
                        .map((split, index) => {
                            if (!split || typeof split !== 'object') {
                                return null;
                            }
                            const code = typeof split.code === 'string' ? split.code.trim() : '';
                            if (!code) {
                                return null;
                            }
                            const periodsValue = Number(split.periods);
                            const periods = Number.isFinite(periodsValue) ? periodsValue : parseInt(split.periods, 10);
                            const numericPeriods = Number.isFinite(periods) ? periods : 0;

                            return {
                                code: code,
                                periods: numericPeriods,
                                index: Number.isInteger(split.index) ? split.index : index,
                                totalSplits: Number.isInteger(split.totalSplits) ? split.totalSplits : splits.length
                            };
                        })
                        .filter(split => split && split.code);

                    if (sanitizedSplits.length > 0) {
                        subjectSplits[normalizedBase] = sanitizedSplits.map((split, index) => ({
                            code: split.code,
                            periods: split.periods,
                            index: index,
                            totalSplits: sanitizedSplits.length
                        }));
                        splitsUpdated++;
                    } else {
                        delete subjectSplits[normalizedBase];
                    }
                });

                rebuildSplitLookup();

                if (Object.keys(subjectSplits).length > 0) {
                    const baseSubjects = new Set(Object.keys(subjectSplits));
                    const existingSubjects = new Set(subjects);

                    subjects = subjects.filter(subject => !baseSubjects.has(subject));

                    Object.entries(subjectSplits).forEach(([baseSubject, splits]) => {
                        const baseLine = subjectLineMapping[baseSubject];
                        splits.forEach(split => {
                            if (!existingSubjects.has(split.code)) {
                                subjects.push(split.code);
                                existingSubjects.add(split.code);
                            }

                            if (baseLine !== undefined && subjectLineMapping[split.code] === undefined) {
                                subjectLineMapping[split.code] = baseLine;
                            }
                        });
                    });
                }
            }

            if (data.teacherLoadSettings && typeof data.teacherLoadSettings === 'object') {
                Object.entries(data.teacherLoadSettings).forEach(([teacherName, settings]) => {
                    if (!teacherName || typeof settings !== 'object') {
                        return;
                    }

                    if (!teachers.includes(teacherName)) {
                        if (addTeacher(teacherName, { skipRefresh: true, silent: true })) {
                            teachersAdded++;
                        }
                    }

                    const existingSettings = getTeacherLoadSettings(teacherName);
                    teacherLoadSettings[teacherName] = {
                        ...existingSettings,
                        ...settings
                    };
                    getTeacherLoadSettings(teacherName);
                    loadUpdated++;
                });
            }

            const structureChanged = teachersAdded > 0 || linesAdded > 0;
            const subjectDataChanged = subjectsAdded > 0 || mappingUpdated > 0 || splitsUpdated > 0;

            if (structureChanged) {
                initializeTimetable();
            } else if (subjectDataChanged) {
                renderAllAllocations();
                updateStats();
            }

            createSubjectPool();
            updateStats();

            if (structureChanged || subjectDataChanged) {
                clearActionHistory();
            }

            const summaryParts = [];

            if (teachersAdded > 0) {
                summaryParts.push(`${teachersAdded} teacher${teachersAdded === 1 ? '' : 's'} added`);
            }

            if (linesAdded > 0) {
                summaryParts.push(`${linesAdded} line${linesAdded === 1 ? '' : 's'} added`);
            }

            if (subjectsAdded > 0) {
                summaryParts.push(`${subjectsAdded} subject${subjectsAdded === 1 ? '' : 's'} added`);
            }

            if (mappingUpdated > 0) {
                summaryParts.push(`line mapping updated for ${mappingUpdated} subject${mappingUpdated === 1 ? '' : 's'}`);
            }

            if (splitsUpdated > 0) {
                summaryParts.push(`${splitsUpdated} split definition${splitsUpdated === 1 ? '' : 's'} updated`);
            }

            if (loadUpdated > 0) {
                summaryParts.push(`load settings updated for ${loadUpdated} teacher${loadUpdated === 1 ? '' : 's'}`);
            }

            if (summaryParts.length === 0) {
                alert('No new supplemental data detected.');
            } else {
                alert('Supplemental data imported: ' + summaryParts.join(', ') + '.');
            }
        }

        function getYear8Semester(subjectCode) {
            if (!subjectCode) {
                return null;
            }
            const normalized = subjectCode.toUpperCase().replace(/\s+/g, ' ');
            const match = normalized.match(/^S\s*([12])\s*8/);
            return match ? match[1] : null;
        }

        function normalizeSubjectCodeForPeriods(subjectCode) {
            if (!subjectCode) {
                return '';
            }

            let normalized = subjectCode.toString().toUpperCase().replace(/\s+/g, ' ').trim();
            normalized = normalized.replace(/^S[12]\s*:?\s*/, '');
            normalized = normalized.replace(/^(?:YEAR|YR)\s*/, '');
            return normalized;
        }

        function getSubjectPeriodValue(subjectCode) {
            if (!subjectCode) {
                return 0;
            }

            const splitInfo = getSplitMetadata(subjectCode);
            if (splitInfo) {
                return Number.isFinite(splitInfo.periods) ? splitInfo.periods : parseInt(splitInfo.periods, 10) || 0;
            }

            const normalized = normalizeSubjectCodeForPeriods(subjectCode);
            if (!normalized) {
                return 0;
            }

            const match = normalized.match(/^(\d{1,2})/);
            if (!match) {
                return 0;
            }

            const year = parseInt(match[1], 10);
            if (!Number.isInteger(year)) {
                return 0;
            }

            if (YEAR_PERIOD_ALLOCATION[year]) {
                return YEAR_PERIOD_ALLOCATION[year];
            }

            const remainder = normalized.slice(match[1].length).trim();
            const compactRemainder = remainder.replace(/\s+/g, '');

            if (year === 8) {
                const techKeyword = /\bTECH\b/.test(remainder) || compactRemainder.includes('TECHMAND');
                const mandatoryKeyword = /(^|\s)MAND(?:ATORY)?\b/.test(remainder) || compactRemainder.includes('MANDATORY');
                const isTechMandatory = compactRemainder.startsWith('TM') || techKeyword || mandatoryKeyword;
                return isTechMandatory ? YEAR8_TECH_MANDATORY_PERIODS : YEAR8_ELECTIVE_PERIODS;
            }

            if (year === 7) {
                return YEAR7_TECH_MANDATORY_PERIODS;
            }

            return 0;
        }

        function calculateTeacherPeriodTotals() {
            const totals = new Array(teachers.length).fill(0);

            Object.entries(allocations).forEach(([key, value]) => {
                const parts = key.split('-');
                if (parts.length !== 2) {
                    return;
                }

                const teacherIndex = parseInt(parts[1], 10);
                if (Number.isNaN(teacherIndex) || teacherIndex < 0 || teacherIndex >= teachers.length) {
                    return;
                }

                const subjectList = Array.isArray(value) ? value : [value];
                const validSubjects = subjectList.filter(subject => typeof subject === 'string' && subject.trim() !== '');

                if (validSubjects.length === 0) {
                    return;
                }

                const periodValues = validSubjects.map(subject => getSubjectPeriodValue(subject));

                if (isYear8SemesterPair(validSubjects) && periodValues.every(value => value === YEAR8_ELECTIVE_PERIODS)) {
                    totals[teacherIndex] += YEAR8_ELECTIVE_PERIODS;
                    return;
                }

                periodValues.forEach(periodValue => {
                    totals[teacherIndex] += periodValue;
                });
            });

            return totals;
        }

        function createDefaultTeacherLoadSettings() {
            return {
                fte: DEFAULT_FTE_VALUE,
                periodAllowance: 0,
                assemblyFullCount: 0,
                assemblyShortCount: 0,
                additionalMinutes: 0
            };
        }

        function normalizeFteValue(value) {
            if (value === null || value === undefined) {
                return DEFAULT_FTE_VALUE;
            }

            const stringValue = String(value).trim();
            if (FTE_LOAD_MAPPING[stringValue] !== undefined) {
                return stringValue;
            }

            const numeric = Number(stringValue);
            if (Number.isFinite(numeric)) {
                const fixed = numeric.toFixed(1);
                if (FTE_LOAD_MAPPING[fixed] !== undefined) {
                    return fixed;
                }
            }

            return DEFAULT_FTE_VALUE;
        }

        function toNumberOrZero(value) {
            const numeric = Number(value);
            return Number.isFinite(numeric) ? numeric : 0;
        }

        function getFteHours(value) {
            const normalized = normalizeFteValue(value);
            return FTE_LOAD_MAPPING[normalized] !== undefined
                ? FTE_LOAD_MAPPING[normalized]
                : FTE_LOAD_MAPPING[DEFAULT_FTE_VALUE];
        }

        function getTeacherLoadSettings(teacherName) {
            if (!teacherName) {
                return createDefaultTeacherLoadSettings();
            }

            if (!teacherLoadSettings || typeof teacherLoadSettings !== 'object') {
                teacherLoadSettings = {};
            }

            const key = String(teacherName);
            const existing = teacherLoadSettings[key];

            if (!existing) {
                teacherLoadSettings[key] = createDefaultTeacherLoadSettings();
            } else {
                existing.fte = normalizeFteValue(existing.fte);
                existing.periodAllowance = Math.max(0, toNumberOrZero(existing.periodAllowance));
                existing.assemblyFullCount = Math.max(0, toNumberOrZero(existing.assemblyFullCount));
                existing.assemblyShortCount = Math.max(0, toNumberOrZero(existing.assemblyShortCount));
                existing.additionalMinutes = Math.max(0, toNumberOrZero(existing.additionalMinutes));
            }

            return teacherLoadSettings[key];
        }

        function calculateTeacherLoadMetrics(teacherName, teachingPeriods) {
            const settings = getTeacherLoadSettings(teacherName);
            const validTeachingPeriods = Number.isFinite(teachingPeriods) ? teachingPeriods : 0;

            const teachingMinutes = validTeachingPeriods * PERIOD_MINUTES;
            const periodAllowanceMinutes = settings.periodAllowance * PERIOD_MINUTES;
            const assemblyFullMinutes = settings.assemblyFullCount * ASSEMBLY_FULL_MINUTES;
            const assemblyShortMinutes = settings.assemblyShortCount * ASSEMBLY_SHORT_MINUTES;
            const additionalMinutes = settings.additionalMinutes;

            const allowanceMinutes = periodAllowanceMinutes + assemblyFullMinutes + assemblyShortMinutes + additionalMinutes;
            const allowancePeriods = allowanceMinutes / PERIOD_MINUTES;

            const fteHours = getFteHours(settings.fte);
            const baseMinutes = fteHours * 60;
            const basePeriods = baseMinutes / PERIOD_MINUTES;

            const loadUsedMinutes = teachingMinutes + allowanceMinutes;
            const loadUsedPeriods = loadUsedMinutes / PERIOD_MINUTES;

            const balanceMinutes = baseMinutes - loadUsedMinutes;
            const balancePeriods = balanceMinutes / PERIOD_MINUTES;

            return {
                settings,
                teachingPeriods: validTeachingPeriods,
                teachingMinutes,
                allowanceMinutes,
                allowancePeriods,
                loadUsedMinutes,
                loadUsedPeriods,
                baseMinutes,
                basePeriods,
                fteHours,
                balanceMinutes,
                balancePeriods,
                periodAllowanceMinutes,
                assemblyFullMinutes,
                assemblyShortMinutes
            };
        }

        function formatPeriods(value) {
            if (!Number.isFinite(value)) {
                return '0.00';
            }
            return value.toFixed(2);
        }

        function formatMinutes(value) {
            if (!Number.isFinite(value)) {
                return '0 min';
            }
            const decimals = Math.abs(value % 1) < 0.05 ? 0 : 1;
            return `${value.toFixed(decimals)} min`;
        }

        function formatHours(value) {
            if (!Number.isFinite(value)) {
                return '0 h';
            }
            return `${value.toFixed(2)} h`;
        }

        function formatBalanceText(minutes) {
            if (!Number.isFinite(minutes)) {
                return '0.00 periods (0 min) remaining';
            }

            const remaining = minutes >= 0;
            const absoluteMinutes = Math.abs(minutes);
            const absolutePeriods = absoluteMinutes / PERIOD_MINUTES;
            const periodLabel = Math.abs(absolutePeriods - 1) < 0.005 ? 'period' : 'periods';

            const minutesText = formatMinutes(absoluteMinutes);
            const periodsText = formatPeriods(absolutePeriods);

            return remaining
                ? `${periodsText} ${periodLabel} (${minutesText}) remaining`
                : `${periodsText} ${periodLabel} (${minutesText}) over`;
        }

        function formatAllowanceDetails(settings) {
            if (!settings) {
                return 'None';
            }

            const details = [];

            if (settings.periodAllowance > 0) {
                const value = parseFloat(settings.periodAllowance.toFixed(2));
                const label = Math.abs(value - 1) < 0.005 ? 'period allowance' : 'period allowances';
                details.push(`${value} ${label}`);
            }

            if (settings.assemblyFullCount > 0) {
                const value = parseFloat(settings.assemblyFullCount.toFixed(2));
                const label = Math.abs(value - 1) < 0.005 ? 'full assembly' : 'full assemblies';
                details.push(`${value} ${label}`);
            }

            if (settings.assemblyShortCount > 0) {
                const value = parseFloat(settings.assemblyShortCount.toFixed(2));
                const label = Math.abs(value - 1) < 0.005 ? 'short/TLC assembly' : 'short/TLC assemblies';
                details.push(`${value} ${label}`);
            }

            if (settings.additionalMinutes > 0) {
                const value = parseFloat(settings.additionalMinutes.toFixed(1));
                details.push(`${value} min other allowances`);
            }

            return details.length > 0 ? details.join(', ') : 'None';
        }

        function ensureTeacherPeriodTotalsContainer() {
            const container = document.querySelector('.timetable-container');
            if (!container) {
                return null;
            }

            let summary = document.getElementById('teacherPeriodTotals');
            if (!summary) {
                summary = document.createElement('div');
                summary.id = 'teacherPeriodTotals';
                summary.className = 'teacher-period-summary';

                const heading = document.createElement('h3');
                heading.textContent = 'Teacher period allocation totals (per fortnight)';
                summary.appendChild(heading);

                const subtitle = document.createElement('p');
                subtitle.className = 'teacher-period-subtitle';
                subtitle.id = 'teacherPeriodSubtitle';
                subtitle.textContent = 'Calculated from subject allocations.';
                summary.appendChild(subtitle);

                const legend = document.createElement('div');
                legend.className = 'teacher-period-legend';
                legend.innerHTML = [
                    '<span>Year 12 = 7</span>',
                    '<span>Year 11 = 7</span>',
                    '<span>Year 10 = 5</span>',
                    '<span>Year 9 = 6</span>',
                    '<span>Year 8 Elective = 3</span>',
                    '<span>Year 8 Tech Mandatory = 5</span>',
                    '<span>Year 7 Tech Mandatory = 5</span>',
                    `<span>Each period = ${PERIOD_MINUTES} minutes</span>`,
                    `<span>Full assembly = ${ASSEMBLY_FULL_PERIOD_EQUIVALENT.toFixed(2)} period (~${formatMinutes(ASSEMBLY_FULL_MINUTES)})</span>`,
                    `<span>Short/TLC assembly = ${ASSEMBLY_SHORT_PERIOD_EQUIVALENT.toFixed(2)} period (${formatMinutes(ASSEMBLY_SHORT_MINUTES)})</span>`
                ].join('');
                summary.appendChild(legend);

                const toggleControls = document.createElement('div');
                toggleControls.className = 'teacher-card-toggle-controls';

                const expandBtn = document.createElement('button');
                expandBtn.type = 'button';
                expandBtn.id = 'expandTeachersBtn';
                expandBtn.className = 'btn btn-secondary btn-compact';
                expandBtn.textContent = 'Expand all cards';
                expandBtn.disabled = true;
                expandBtn.addEventListener('click', function() {
                    toggleAllTeacherCards(true);
                });
                toggleControls.appendChild(expandBtn);

                const collapseBtn = document.createElement('button');
                collapseBtn.type = 'button';
                collapseBtn.id = 'collapseTeachersBtn';
                collapseBtn.className = 'btn btn-secondary btn-compact';
                collapseBtn.textContent = 'Collapse all cards';
                collapseBtn.disabled = true;
                collapseBtn.addEventListener('click', function() {
                    toggleAllTeacherCards(false);
                });
                toggleControls.appendChild(collapseBtn);

                summary.appendChild(toggleControls);

                const grid = document.createElement('div');
                grid.id = 'teacherPeriodTotalsGrid';
                grid.className = 'teacher-period-grid';
                summary.appendChild(grid);
            }

            const containerHasSummary = summary.parentElement === container;
            const subjectPool = document.getElementById('subjectPool');

            if (subjectPool && subjectPool.parentElement === container) {
                if (!containerHasSummary || subjectPool.previousElementSibling !== summary) {
                    container.insertBefore(summary, subjectPool);
                }
            } else if (!containerHasSummary) {
                container.appendChild(summary);
            }

            return summary;
        }

        function toggleAllTeacherCards(open) {
            document.querySelectorAll('.teacher-period-card').forEach(card => {
                card.open = open;
            });
        }

        function formatTlcDisplayValue(value) {
            const numeric = Number(value);
            if (!Number.isFinite(numeric) || numeric <= 0) {
                return '0';
            }

            const sanitized = Math.max(0, numeric);
            const rounded = Math.round(sanitized);

            if (Math.abs(sanitized - rounded) < 0.0001) {
                return String(rounded);
            }

            return sanitized.toFixed(2).replace(/\.?0+$/, '');
        }

        function renderTlcPeriodsRow() {
            const tbody = document.getElementById('timetableBody');
            if (!tbody) {
                return;
            }

            const hasTeachers = Array.isArray(teachers) && teachers.length > 0;
            let row = tbody.querySelector('tr[data-tlc-row="true"]');

            if (!hasTeachers) {
                if (row) {
                    row.remove();
                }
                return;
            }

            if (!row) {
                row = document.createElement('tr');
                row.dataset.tlcRow = 'true';
                tbody.appendChild(row);
            }

            row.innerHTML = '';

            const labelCell = document.createElement('td');
            labelCell.className = 'period-row tlc-period-label';
            labelCell.textContent = 'TLC periods';
            row.appendChild(labelCell);

            teachers.forEach(teacher => {
                const cell = document.createElement('td');
                cell.className = 'tlc-period-cell';
                const settings = getTeacherLoadSettings(teacher);
                const rawValue = settings ? toNumberOrZero(settings.assemblyShortCount) : 0;
                const sanitizedValue = Math.max(0, rawValue);
                const displayValue = formatTlcDisplayValue(sanitizedValue);
                cell.textContent = `TLC - ${displayValue}`;

                if (sanitizedValue > 0) {
                    const label = Math.abs(sanitizedValue - 1) < 0.005 ? 'short/TLC assembly' : 'short/TLC assemblies';
                    cell.title = `${displayValue} ${label}`;
                } else {
                    cell.title = 'No short/TLC assemblies';
                }

                row.appendChild(cell);
            });
        }

        function updateTeacherPeriodTotals() {
            const hasTeachers = Array.isArray(teachers) && teachers.length > 0;
            const existingSummary = document.getElementById('teacherPeriodTotals');
            const expandBtn = document.getElementById('expandTeachersBtn');
            const collapseBtn = document.getElementById('collapseTeachersBtn');

            if (!hasTeachers) {
                if (expandBtn) {
                    expandBtn.disabled = true;
                }
                if (collapseBtn) {
                    collapseBtn.disabled = true;
                }
                if (existingSummary) {
                    const grid = existingSummary.querySelector('#teacherPeriodTotalsGrid');
                    if (grid) {
                        grid.innerHTML = '';
                    }
                    const subtitle = existingSummary.querySelector('#teacherPeriodSubtitle');
                    if (subtitle) {
                        subtitle.textContent = 'Import spreadsheet data to configure teacher load allocations.';
                    }
                    existingSummary.style.display = 'none';
                }
                renderTlcPeriodsRow();
                return;
            }

            const summary = ensureTeacherPeriodTotalsContainer();
            if (!summary) {
                return;
            }

            summary.style.display = 'block';

            const grid = summary.querySelector('#teacherPeriodTotalsGrid');
            if (!grid) {
                return;
            }

            grid.innerHTML = '';

            const totals = calculateTeacherPeriodTotals();
            const subtitle = summary.querySelector('#teacherPeriodSubtitle');

            let totalTeachingMinutes = 0;
            let totalAllowanceMinutes = 0;
            let totalBaseMinutes = 0;

            function createSummaryRow(labelText, valueText, extraClasses = []) {
                const row = document.createElement('div');
                row.className = 'teacher-load-row';
                extraClasses.forEach(className => {
                    if (className) {
                        row.classList.add(className);
                    }
                });

                const label = document.createElement('span');
                label.textContent = labelText;
                const value = document.createElement('span');
                value.textContent = valueText;

                row.appendChild(label);
                row.appendChild(value);
                return row;
            }

            teachers.forEach((teacher, index) => {
                const metrics = calculateTeacherLoadMetrics(teacher, totals[index]);
                const settings = metrics.settings;

                totalTeachingMinutes += metrics.teachingMinutes;
                totalAllowanceMinutes += metrics.allowanceMinutes;
                totalBaseMinutes += metrics.baseMinutes;

                const card = document.createElement('details');
                card.className = 'teacher-period-card';
                const balancePositive = metrics.balanceMinutes >= 0;
                card.classList.add(balancePositive ? 'balance-positive' : 'balance-negative');
                if (!balancePositive) {
                    card.open = true;
                }

                const summaryToggle = document.createElement('summary');
                summaryToggle.className = 'teacher-card-summary';

                const summaryMain = document.createElement('div');
                summaryMain.className = 'teacher-card-summary-main teacher-period-name';
                summaryMain.textContent = teacher;
                summaryToggle.appendChild(summaryMain);

                const summaryChips = document.createElement('div');
                summaryChips.className = 'teacher-card-summary-chips';

                const fteChip = document.createElement('span');
                fteChip.className = 'teacher-card-chip fte-chip';
                fteChip.textContent = `FTE ${normalizeFteValue(settings.fte)}`;
                fteChip.title = `${formatHours(metrics.fteHours)} base load (${formatMinutes(metrics.baseMinutes)})`;
                summaryChips.appendChild(fteChip);

                const loadChip = document.createElement('span');
                loadChip.className = 'teacher-card-chip load-chip';
                loadChip.textContent = `${formatPeriods(metrics.loadUsedPeriods)} / ${formatPeriods(metrics.basePeriods)} periods`;
                loadChip.title = `Using ${formatMinutes(metrics.loadUsedMinutes)} of ${formatMinutes(metrics.baseMinutes)}`;
                summaryChips.appendChild(loadChip);

                const balanceChip = document.createElement('span');
                const balanceClass = balancePositive ? 'positive' : 'negative';
                balanceChip.className = `teacher-card-chip balance-chip ${balanceClass}`;
                const balancePeriodsAbs = Math.abs(metrics.balancePeriods);
                balanceChip.textContent = balancePositive
                    ? `${formatPeriods(balancePeriodsAbs)} remaining`
                    : `${formatPeriods(balancePeriodsAbs)} over`;
                balanceChip.title = formatBalanceText(metrics.balanceMinutes);
                summaryChips.appendChild(balanceChip);

                summaryToggle.appendChild(summaryChips);
                card.appendChild(summaryToggle);

                const body = document.createElement('div');
                body.className = 'teacher-card-body';

                const settingsTitle = document.createElement('div');
                settingsTitle.className = 'teacher-card-section-title';
                settingsTitle.textContent = 'FTE & load settings';
                body.appendChild(settingsTitle);

                const controlsRow = document.createElement('div');
                controlsRow.className = 'teacher-card-controls';

                const fteControl = document.createElement('div');
                fteControl.className = 'teacher-fte-control';

                const fteLabel = document.createElement('label');
                fteLabel.textContent = 'FTE';
                fteControl.appendChild(fteLabel);

                const fteSelect = document.createElement('select');
                const normalizedFte = normalizeFteValue(settings.fte);
                FTE_OPTIONS.forEach(optionValue => {
                    const option = document.createElement('option');
                    option.value = optionValue;
                    const hours = FTE_LOAD_MAPPING[optionValue];
                    option.textContent = hours !== undefined
                        ? `${optionValue} (${hours.toFixed(2)} h)`
                        : optionValue;
                    if (optionValue === normalizedFte) {
                        option.selected = true;
                    }
                    fteSelect.appendChild(option);
                });

                fteSelect.addEventListener('change', function() {
                    settings.fte = normalizeFteValue(this.value);
                    teacherLoadSettings[teacher] = settings;
                    updateTeacherPeriodTotals();
                });

                fteControl.appendChild(fteSelect);
                controlsRow.appendChild(fteControl);
                body.appendChild(controlsRow);

                const allowanceTitle = document.createElement('div');
                allowanceTitle.className = 'teacher-card-section-title';
                allowanceTitle.textContent = 'Allowance configuration';

                const inputsContainer = document.createElement('div');
                inputsContainer.className = 'teacher-load-inputs';

                function createAllowanceInput(labelText, currentValue, options) {
                    const opts = options || {};
                    const wrapper = document.createElement('div');
                    wrapper.className = 'teacher-load-input';

                    const label = document.createElement('label');
                    label.textContent = labelText;
                    wrapper.appendChild(label);

                    const input = document.createElement('input');
                    input.type = 'number';
                    input.step = opts.step !== undefined ? opts.step : '0.01';
                    if (opts.min !== undefined) {
                        input.min = opts.min;
                    }
                    input.value = Number.isFinite(currentValue) ? currentValue : 0;

                    input.addEventListener('change', function() {
                        const numeric = Number(this.value);
                        const sanitized = Number.isFinite(numeric) ? Math.max(0, numeric) : 0;
                        if (typeof opts.onChange === 'function') {
                            opts.onChange(sanitized);
                        }
                    });

                    wrapper.appendChild(input);

                    if (opts.note) {
                        const note = document.createElement('div');
                        note.className = 'teacher-load-input-note';
                        note.textContent = opts.note;
                        wrapper.appendChild(note);
                    }

                    return wrapper;
                }

                inputsContainer.appendChild(createAllowanceInput('Period allowance', settings.periodAllowance, {
                    step: '0.01',
                    min: '0',
                    note: '59 min each',
                    onChange(value) {
                        settings.periodAllowance = Math.round(value * 100) / 100;
                        updateTeacherPeriodTotals();
                    }
                }));

                inputsContainer.appendChild(createAllowanceInput('Full assemblies', settings.assemblyFullCount, {
                    step: '0.01',
                    min: '0',
                    note: `${ASSEMBLY_FULL_PERIOD_EQUIVALENT.toFixed(2)} period (~${formatMinutes(ASSEMBLY_FULL_MINUTES)}) each`,
                    onChange(value) {
                        settings.assemblyFullCount = Math.round(value * 100) / 100;
                        updateTeacherPeriodTotals();
                    }
                }));

                inputsContainer.appendChild(createAllowanceInput('Short/TLC assemblies', settings.assemblyShortCount, {
                    step: '0.01',
                    min: '0',
                    note: `${ASSEMBLY_SHORT_PERIOD_EQUIVALENT.toFixed(2)} period (${formatMinutes(ASSEMBLY_SHORT_MINUTES)}) each`,
                    onChange(value) {
                        settings.assemblyShortCount = Math.round(value * 100) / 100;
                        updateTeacherPeriodTotals();
                    }
                }));

                inputsContainer.appendChild(createAllowanceInput('Other allowance (minutes)', settings.additionalMinutes, {
                    step: '1',
                    min: '0',
                    note: 'Custom minute-based allowance',
                    onChange(value) {
                        settings.additionalMinutes = Math.round(value * 100) / 100;
                        updateTeacherPeriodTotals();
                    }
                }));

                body.appendChild(allowanceTitle);
                body.appendChild(inputsContainer);

                const summaryTitle = document.createElement('div');
                summaryTitle.className = 'teacher-card-section-title';
                summaryTitle.textContent = 'Load summary';

                const summaryContainer = document.createElement('div');
                summaryContainer.className = 'teacher-load-summary';

                summaryContainer.appendChild(createSummaryRow(
                    'Teaching allocation',
                    `${formatPeriods(metrics.teachingPeriods)} periods (${formatMinutes(metrics.teachingMinutes)})`
                ));

                summaryContainer.appendChild(createSummaryRow(
                    'Allowances applied',
                    `${formatPeriods(metrics.allowancePeriods)} periods (${formatMinutes(metrics.allowanceMinutes)})`
                ));

                summaryContainer.appendChild(createSummaryRow(
                    'Combined load',
                    `${formatPeriods(metrics.loadUsedPeriods)} periods (${formatMinutes(metrics.loadUsedMinutes)})`
                ));

                summaryContainer.appendChild(createSummaryRow(
                    'FTE allocation',
                    `${formatHours(metrics.fteHours)} (${formatMinutes(metrics.baseMinutes)} ≈ ${formatPeriods(metrics.basePeriods)} periods)`
                ));

                const balanceRow = createSummaryRow(
                    'Balance',
                    formatBalanceText(metrics.balanceMinutes),
                    ['teacher-load-balance', balancePositive ? 'positive' : 'negative']
                );
                summaryContainer.appendChild(balanceRow);

                summaryContainer.appendChild(createSummaryRow(
                    'Allowance detail',
                    formatAllowanceDetails(settings),
                    ['teacher-load-note']
                ));

                body.appendChild(summaryTitle);
                body.appendChild(summaryContainer);

                card.appendChild(body);
                grid.appendChild(card);
            });

            const hasCards = grid.children.length > 0;
            if (expandBtn) {
                expandBtn.disabled = !hasCards;
            }
            if (collapseBtn) {
                collapseBtn.disabled = !hasCards;
            }

            if (subtitle) {
                const teachingPeriods = totalTeachingMinutes / PERIOD_MINUTES;
                const allowancePeriods = totalAllowanceMinutes / PERIOD_MINUTES;
                const totalLoadMinutes = totalTeachingMinutes + totalAllowanceMinutes;
                const totalLoadPeriods = totalLoadMinutes / PERIOD_MINUTES;
                const totalBasePeriods = totalBaseMinutes / PERIOD_MINUTES;
                const totalBaseHours = totalBaseMinutes / 60;
                const balanceMinutes = totalBaseMinutes - totalLoadMinutes;

                subtitle.textContent = [
                    'Calculated from subject allocations and load allowances.',
                    `Teaching: ${formatPeriods(teachingPeriods)} periods (${formatMinutes(totalTeachingMinutes)}).`,
                    `Allowances: ${formatPeriods(allowancePeriods)} periods (${formatMinutes(totalAllowanceMinutes)}).`,
                    `Combined load: ${formatPeriods(totalLoadPeriods)} periods vs capacity ${formatPeriods(totalBasePeriods)} periods (${formatHours(totalBaseHours)}).`,
                    `Balance: ${formatBalanceText(balanceMinutes)}.`
                ].join(' ');
            }

            renderTlcPeriodsRow();
        }

        function isYear8SemesterPair(subjects) {
            if (!subjects || subjects.length !== 2) {
                return false;
            }
            const semesters = subjects.map(getYear8Semester);
            return semesters[0] && semesters[1] && semesters[0] !== semesters[1];
        }

        function determineCellStatus(subjects) {
            if (!subjects || subjects.length === 0) {
                return 'empty';
            }
            if (subjects.length === 1) {
                return isSplitSubject(subjects[0]) ? 'splitSingle' : 'single';
            }

            const splitMetadata = subjects.map(getSplitMetadata);
            const hasSplit = splitMetadata.some(info => info !== null);

            if (hasSplit) {
                const validSplitMetadata = splitMetadata.filter(info => info !== null);
                if (validSplitMetadata.length === subjects.length) {
                    const baseSubject = validSplitMetadata[0].baseSubject;
                    const allSameBase = validSplitMetadata.every(info => info.baseSubject === baseSubject);
                    if (allSameBase) {
                        return 'splitGroup';
                    }
                }
            }

            if (isYear8SemesterPair(subjects)) {
                return 'semesterPair';
            }
            return 'clash';
        }

        function removeSubjectFromPool(subjectCode) {
            const container = document.getElementById('subjectPoolItems');
            if (!container) {
                return;
            }
            const items = Array.from(container.querySelectorAll('.subject-slot'));
            const target = items.find(element => element.dataset.subject === subjectCode);
            if (target) {
                target.remove();
            }
        }

        function getSubjectPoolColumn(lineIndex) {
            const container = document.getElementById('subjectPoolItems');
            if (!container) {
                return null;
            }

            const numericLine = Number(lineIndex);
            const normalizedLine = Number.isInteger(numericLine) && numericLine >= 0
                ? String(numericLine)
                : 'unassigned';

            const selector = `.subject-pool-column[data-line="${normalizedLine}"] .subject-pool-column-body`;
            const column = container.querySelector(selector);

            if (column) {
                return column;
            }

            return container.querySelector('.subject-pool-column[data-line="unassigned"] .subject-pool-column-body');
        }

        function createSubjectElement(subjectCode) {
            const subjectElement = document.createElement('div');
            subjectElement.className = 'subject-slot';
            subjectElement.draggable = true;
            subjectElement.dataset.subject = subjectCode;

            const mappedLine = subjectLineMapping[subjectCode];
            subjectElement.dataset.line = mappedLine !== undefined ? mappedLine : 'unassigned';

            applySubjectDisplay(subjectElement, subjectCode);

            subjectElement.addEventListener('dragstart', handleDragStart);
            subjectElement.addEventListener('dragend', handleDragEnd);
            subjectElement.addEventListener('click', function(e) {
                if (draggedElement || subjectElement.classList.contains('dragging')) {
                    return;
                }
                e.preventDefault();
                e.stopPropagation();
                handleSubjectPoolSubjectClick(subjectCode);
            });

            return subjectElement;
        }

        function handleSubjectPoolSubjectClick(subjectCode) {
            if (!subjectCode) {
                return;
            }

            if (!Array.isArray(teachers) || teachers.length === 0) {
                alert('Please import spreadsheet data first!');
                return;
            }

            const availableSubjects = new Set(getAvailableSubjects());
            if (!availableSubjects.has(subjectCode)) {
                alert('This subject has already been allocated.');
                return;
            }

            const mappedLine = subjectLineMapping[subjectCode];
            const hasMappedLine = typeof mappedLine === 'number' && mappedLine >= 0 && mappedLine < lines.length;
            const teacherPrompt = hasMappedLine && lines[mappedLine]
                ? `Select teacher for ${subjectCode} (${lines[mappedLine]})`
                : `Select teacher for ${subjectCode}`;

            showAutocomplete(teacherPrompt, teachers, function(selectedTeacher) {
                const teacherIndex = teachers.indexOf(selectedTeacher);

                if (teacherIndex === -1) {
                    alert('Invalid teacher selection!');
                    return;
                }

                const finalizeAllocation = (lineIndex) => {
                    if (!allocateSubjectToTeacher(subjectCode, teacherIndex, lineIndex)) {
                        alert('Unable to allocate this subject to the selected teacher.');
                        return;
                    }

                    const lineName = typeof lineIndex === 'number' && lines[lineIndex]
                        ? ` on ${lines[lineIndex]}`
                        : '';
                    alert(`Subject ${subjectCode} allocated to ${selectedTeacher}${lineName}!`);
                };

                if (hasMappedLine) {
                    finalizeAllocation(mappedLine);
                } else {
                    setTimeout(() => {
                        showAutocomplete(`Select line for ${subjectCode}`, lines, function(selectedLine) {
                            const lineIndex = lines.indexOf(selectedLine);

                            if (lineIndex === -1) {
                                alert('Invalid line selection!');
                                return;
                            }

                            finalizeAllocation(lineIndex);
                        });
                    }, 200);
                }
            });
        }

        function addSubjectToPool(subjectCode) {
            const container = document.getElementById('subjectPoolItems');
            if (!container) {
                return;
            }

            const exists = Array.from(container.querySelectorAll('.subject-slot'))
                .some(element => element.dataset.subject === subjectCode);

            if (exists) {
                return;
            }

            const columnBody = getSubjectPoolColumn(subjectLineMapping[subjectCode]);
            if (!columnBody) {
                return;
            }

            const subjectElement = createSubjectElement(subjectCode);
            columnBody.appendChild(subjectElement);
        }

        function removeSubjectFromCell(lineIndex, teacherIndex, subjectCode, addBackToPool = false) {
            const key = getAllocationKey(lineIndex, teacherIndex);
            const subjects = getAllocationSubjects(key);
            const subjectPosition = subjects.indexOf(subjectCode);

            if (subjectPosition === -1) {
                return;
            }

            subjects.splice(subjectPosition, 1);
            setAllocationSubjects(key, subjects);

            if (addBackToPool) {
                addSubjectToPool(subjectCode);
            }
        }

        function handleSubjectRemoval(lineIndex, teacherIndex, subjectCode) {
            if (confirm('Remove ' + subjectCode + ' from ' + teachers[teacherIndex] + '?')) {
                removeSubjectFromCell(lineIndex, teacherIndex, subjectCode, true);
                renderCell(lineIndex, teacherIndex);
                updateStats();
            }
        }

        function enhanceAllocatedSubjectElement(element, subjectCode, lineIndex, teacherIndex) {
            if (!element) {
                return;
            }

            element.dataset.subject = subjectCode;
            element.dataset.teacher = teacherIndex;
            element.dataset.line = lineIndex;
            element.dataset.allocationState = 'allocated';
            element.draggable = true;

            element.addEventListener('dragstart', handleDragStart);
            element.addEventListener('dragend', handleDragEnd);
            element.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();

                if (draggedElement || element.classList.contains('dragging')) {
                    return;
                }

                handleSubjectRemoval(lineIndex, teacherIndex, subjectCode);
            });
        }

        function renderCell(lineIndex, teacherIndex) {
            const cell = document.querySelector(`[data-period="${lineIndex}"][data-teacher="${teacherIndex}"]`);
            if (!cell) {
                return;
            }

            cell.classList.remove('clash-cell', 'semester-pair-cell', 'split-allocation-cell');
            cell.querySelectorAll('.subject-slot, .split-allocation-header').forEach(element => element.remove());

            const key = getAllocationKey(lineIndex, teacherIndex);
            const subjects = getAllocationSubjects(key);
            const status = determineCellStatus(subjects);

            if (status === 'empty') {
                return;
            }

            if (status === 'semesterPair') {
                cell.classList.add('semester-pair-cell');
                const wrapper = document.createElement('div');
                wrapper.className = 'subject-slot allocated semester-pair';
                wrapper.dataset.teacher = teacherIndex;
                wrapper.dataset.line = lineIndex;

                subjects.forEach(subject => {
                    const subjectRow = document.createElement('div');
                    subjectRow.className = 'semester-pair-item';
                    subjectRow.textContent = subject;
                    enhanceAllocatedSubjectElement(subjectRow, subject, lineIndex, teacherIndex);
                    wrapper.appendChild(subjectRow);
                });

                const label = document.createElement('div');
                label.className = 'semester-pair-label';
                label.textContent = 'S1/S2 Pair';
                wrapper.appendChild(label);

                cell.appendChild(wrapper);
                return;
            }

            if (status === 'splitGroup' || status === 'splitSingle') {
                cell.classList.add('split-allocation-cell');
            }

            if (status === 'splitGroup') {
                const metadata = getSplitMetadata(subjects[0]);
                if (metadata) {
                    const header = document.createElement('div');
                    header.className = 'split-allocation-header';
                    header.textContent = `${metadata.baseSubject} – split allocation`;
                    cell.appendChild(header);
                }
            }

            if (status === 'clash') {
                cell.classList.add('clash-cell');
            }

            subjects.forEach(subject => {
                const subjectElement = document.createElement('div');
                subjectElement.className = 'subject-slot allocated';
                if (status === 'clash') {
                    subjectElement.classList.add('clash');
                }

                const shouldForceSegment = status === 'splitGroup' || status === 'splitSingle' || isSplitSubject(subject);
                applySubjectDisplay(subjectElement, subject, {
                    hideBaseLabel: status === 'splitGroup',
                    forceSegmentStyle: shouldForceSegment
                });

                enhanceAllocatedSubjectElement(subjectElement, subject, lineIndex, teacherIndex);
                cell.appendChild(subjectElement);
            });
        }

        function renderAllAllocations() {
            document.querySelectorAll('.drop-zone').forEach(cell => {
                cell.classList.remove('clash-cell', 'semester-pair-cell', 'split-allocation-cell');
                cell.querySelectorAll('.subject-slot, .split-allocation-header').forEach(slot => slot.remove());
            });

            Object.keys(allocations).forEach(key => {
                const [lineIndex, teacherIndex] = key.split('-').map(Number);
                renderCell(lineIndex, teacherIndex);
            });

            syncSubjectPool();
        }

        function syncSubjectPool() {
            const container = document.getElementById('subjectPoolItems');
            if (!container) {
                return;
            }

            const allocatedSubjects = new Set(flattenAllocatedSubjects());
            Array.from(container.querySelectorAll('.subject-slot')).forEach(item => {
                if (allocatedSubjects.has(item.dataset.subject)) {
                    item.remove();
                }
            });
        }

        // Autocomplete functionality
        let currentAutocompleteCallback = null;
        let selectedIndex = -1;
        let filteredItems = [];
        let allAutocompleteItems = [];

        function normalizeSubjectCode(rawCode) {
            if (!rawCode) {
                return '';
            }

            let code = rawCode.replace(/\r/g, '').trim().toUpperCase();
            code = code.replace(/\s+/g, ' ');
            code = code.replace(/([A-Z])\s+(\d)/g, '$1$2');
            code = code.replace(/(\d)\s+([A-Z])/g, '$1$2');
            return code;
        }

        function convertCSVToArray(csvText) {
            const rows = [];
            let field = '';
            let row = [];
            let inQuotes = false;

            const text = csvText.replace(/^\uFEFF/, '');

            for (let i = 0; i < text.length; i++) {
                const char = text[i];

                if (char === '"') {
                    if (inQuotes && text[i + 1] === '"') {
                        field += '"';
                        i++;
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    row.push(field.trim());
                    field = '';
                } else if ((char === '\n' || char === '\r') && !inQuotes) {
                    if (char === '\r' && text[i + 1] === '\n') {
                        i++;
                    }

                    row.push(field.trim());
                    const cleanedRow = row.map(cell => cell.replace(/\r/g, ''));
                    if (cleanedRow.some(cell => cell.length > 0)) {
                        rows.push(cleanedRow);
                    }

                    row = [];
                    field = '';
                } else {
                    field += char;
                }
            }

            if (inQuotes) {
                throw new Error('Malformed CSV: unmatched quotes detected.');
            }

            if (field.length > 0 || row.length > 0) {
                row.push(field.trim());
                const cleanedRow = row.map(cell => cell.replace(/\r/g, ''));
                if (cleanedRow.some(cell => cell.length > 0)) {
                    rows.push(cleanedRow);
                }
            }

            return rows;
        }

        // Initialize the timetable
        function initializeTimetable() {
            const thead = document.getElementById('timetableHead');
            const tbody = document.getElementById('timetableBody');
            
            // Clear existing content
            thead.innerHTML = '<tr><th>Line</th></tr>';
            tbody.innerHTML = '';

            if (teachers.length === 0) {
                tbody.innerHTML = '<tr><td colspan="1" style="text-align: center; padding: 40px; color: #7f8c8d;">Please import spreadsheet data first</td></tr>';
                updateStats();
                return;
            }

            // Add teacher headers
            const headerRow = thead.querySelector('tr');
            teachers.forEach((teacher, index) => {
                const th = document.createElement('th');
                th.textContent = teacher;
                th.dataset.teacherIndex = index;
                headerRow.appendChild(th);
            });

            // Add line rows
            lines.forEach((line, lineIndex) => {
                const row = document.createElement('tr');

                // Add line cell
                const lineCell = document.createElement('td');
                lineCell.className = 'period-row';
                lineCell.textContent = line;
                row.appendChild(lineCell);

                // Add teacher cells
                teachers.forEach((teacher, teacherIndex) => {
                    const cell = document.createElement('td');
                    cell.className = 'drop-zone';
                    cell.dataset.period = lineIndex;
                    cell.dataset.teacher = teacherIndex;

                    // Add click event for popup allocation
                    cell.addEventListener('click', function() {
                        showAllocationPopup(lineIndex, teacherIndex);
                    });

                    cell.addEventListener('dragover', handleDragOver);
                    cell.addEventListener('dragenter', handleDragEnter);
                    cell.addEventListener('dragleave', handleDragLeave);
                    cell.addEventListener('drop', handleDrop);

                    row.appendChild(cell);
                });

                tbody.appendChild(row);
            });

            renderTlcPeriodsRow();

            updateStats();

            // Create visual elements for pre-allocated subjects
            createAllocationVisuals();
        }

        function createAllocationVisuals() {
            renderAllAllocations();
        }

        // Create the subject pool
        function createSubjectPool() {
            const container = document.querySelector('.timetable-container');
            if (!container) {
                return;
            }

            // Remove existing subject pool if it exists
            const existingPool = document.getElementById('subjectPool');
            if (existingPool) {
                existingPool.remove();
            }

            const subjectPool = document.createElement('div');
            subjectPool.id = 'subjectPool';
            subjectPool.style.cssText = `
                margin-top: 20px;
                padding: 20px;
                background: #f8f9fa;
                border-radius: 8px;
                border: 1px solid #dee2e6;
                overflow-x: auto;
            `;

            const title = document.createElement('h3');
            title.textContent = 'Subject Pool - Drag subjects to allocate them';
            title.style.marginBottom = '15px';
            title.style.color = '#2c3e50';
            subjectPool.appendChild(title);

            const subjectsContainer = document.createElement('div');
            subjectsContainer.className = 'subject-pool-grid';
            subjectsContainer.id = 'subjectPoolItems';
            subjectsContainer.style.gridTemplateColumns = `repeat(${lines.length}, minmax(160px, 1fr))`;

            const columnBodies = {};

            function createColumn(label, key, extraClass) {
                const column = document.createElement('div');
                column.className = 'subject-pool-column';
                if (extraClass) {
                    column.classList.add(extraClass);
                }
                column.dataset.line = key;

                const header = document.createElement('h4');
                header.textContent = label;
                column.appendChild(header);

                const body = document.createElement('div');
                body.className = 'subject-pool-column-body';
                column.appendChild(body);

                subjectsContainer.appendChild(column);
                return body;
            }

            lines.forEach((line, index) => {
                columnBodies[index] = createColumn(line, index);
            });

            columnBodies.unassigned = createColumn('Unassigned', 'unassigned', 'subject-pool-column--unassigned');

            subjects.forEach(subject => {
                if (subjectSplits[subject]) {
                    return;
                }
                const subjectElement = createSubjectElement(subject);
                const mappedLine = subjectLineMapping[subject];
                const targetColumn = columnBodies[mappedLine !== undefined ? mappedLine : 'unassigned'] || columnBodies.unassigned;
                targetColumn.appendChild(subjectElement);
            });

            subjectPool.appendChild(subjectsContainer);
            container.appendChild(subjectPool);

            syncSubjectPool();
        }

        // Drag and drop event handlers
        function handleDragStart(e) {
            draggedElement = e.target;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.target.outerHTML);
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            draggedElement = null;
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDragEnter(e) {
            e.preventDefault();
            e.currentTarget.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            const cell = e.currentTarget;
            cell.classList.remove('drag-over');

            if (!draggedElement) {
                return;
            }

            const subject = draggedElement.dataset.subject;
            if (!subject) {
                return;
            }

            const period = parseInt(cell.dataset.period, 10);
            const teacher = parseInt(cell.dataset.teacher, 10);
            const isAllocatedElement = draggedElement.classList.contains('allocated')
                || draggedElement.dataset.allocationState === 'allocated';

            if (allocateSubjectToTeacher(subject, teacher, period)) {
                if (!isAllocatedElement) {
                    draggedElement.remove();
                }
            }
        }

        // CSV Import functionality
        function importSpreadsheet() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.csv';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            parseCSVData(e.target.result);
                            initializeTimetable();
                            createSubjectPool();
                            alert(`Spreadsheet imported successfully!\nTeachers: ${teachers.length}\nSubjects: ${subjects.length}`);
                        } catch (error) {
                            alert('Error importing CSV: ' + error.message);
                            console.error('CSV Import Error:', error);
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        function extractSubjectsFromParsedData(parsedData, options = {}) {
            const { debug = false } = options;
            const subjectSet = new Set();
            const mapping = {};

            if (!Array.isArray(parsedData)) {
                return { subjects: [], subjectLineMapping: {} };
            }

            // Column mapping: G=6, H=7, I=8, J=9, K=10, L=11 → Lines 0-5
            const lineColumnMapping = {6: 0, 7: 1, 8: 2, 9: 3, 10: 4, 11: 5};

            for (let i = 0; i < parsedData.length; i++) {
                const row = parsedData[i];

                if (!row || !row[5] || !row[5].includes('Year')) {
                    continue;
                }

                const year = row[5].trim();
                const isYear8 = /year\s*8/i.test(year);

                if (debug) {
                    console.log('Processing year:', year, 'to place subjects in correct lines');
                }

                for (let j = i + 1; j < parsedData.length; j++) {
                    const nextRow = parsedData[j];

                    if (nextRow[5] && (nextRow[5].includes('Year') || nextRow[5].includes('Teacher Matrix'))) {
                        break;
                    }

                    if (!nextRow[5] || !nextRow[5].includes('Row')) {
                        continue;
                    }

                    const rowLabel = nextRow[5].trim();
                    if (debug) {
                        console.log('Processing row:', rowLabel, 'at CSV row', j);
                    }

                    for (let colIndex = 6; colIndex <= 11; colIndex++) {
                        const cell = nextRow[colIndex] ? nextRow[colIndex] : '';
                        if (!cell) {
                            continue;
                        }

                        const cellLines = cell.split('\n');
                        cellLines.forEach(cellLine => {
                            const trimmedLine = cellLine.trim();
                            if (trimmedLine.length === 0) {
                                return;
                            }

                            const subjectCodes = [];
                            const codeRegex = /\b\d{1,2}\s*[A-Z]{2,4}\s*\d{0,2}\b/g;
                            let match;

                            while ((match = codeRegex.exec(trimmedLine)) !== null) {
                                let normalizedCode = normalizeSubjectCode(match[0]);
                                if (!normalizedCode) {
                                    continue;
                                }

                                if (isYear8) {
                                    const semesterMatch = trimmedLine.match(/\bS\s*([12])\b/i);
                                    if (semesterMatch) {
                                        const semesterLabel = `S${semesterMatch[1]}`.toUpperCase();
                                        if (!normalizedCode.includes(semesterLabel)) {
                                            normalizedCode = `${semesterLabel} ${normalizedCode}`.trim();
                                        }
                                    }
                                }

                                if (!subjectCodes.includes(normalizedCode)) {
                                    subjectCodes.push(normalizedCode);
                                }
                            }

                            subjectCodes.forEach(subjectCode => {
                                const lineIndex = lineColumnMapping[colIndex];
                                if (lineIndex === undefined) {
                                    return;
                                }

                                mapping[subjectCode] = lineIndex;
                                subjectSet.add(subjectCode);

                                if (debug) {
                                    const lineName = `Line ${lineIndex + 1}`;
                                    console.log(`Found subject: ${subjectCode} belongs in ${lineName} (column ${colIndex}) from "${trimmedLine}"`);
                                }
                            });

                            if (debug && subjectCodes.length === 0) {
                                console.log(`Could not parse any subject codes from: "${trimmedLine}"`);
                            }
                        });
                    }
                }
            }

            return {
                subjects: Array.from(subjectSet),
                subjectLineMapping: mapping
            };
        }

        function parseCSVData(csvText) {
            if (!csvText || csvText.trim().length === 0) {
                throw new Error('Empty CSV file');
            }

            const parsedData = convertCSVToArray(csvText);

            // Reset data
            teachers = [];
            subjects = [];
            allocations = {};
            subjectLineMapping = {};
            resetSplitData();

            console.log('=== DEBUGGING CSV PARSING ===');

            // Step 1: Find Teacher Matrix section and extract teachers
            let teacherMatrixStart = -1;
            for (let i = 0; i < parsedData.length; i++) {
                if (parsedData[i][0] && parsedData[i][0].includes('Teacher Matrix')) {
                    teacherMatrixStart = i + 2; // Skip header row
                    console.log('Found Teacher Matrix at row:', teacherMatrixStart);
                    break;
                }
            }

            if (teacherMatrixStart > -1) {
                // Extract teachers
                for (let i = teacherMatrixStart; i < parsedData.length; i++) {
                    const teacherName = parsedData[i][0] ? parsedData[i][0].trim() : '';
                    if (teacherName && teacherName !== '' && !teacherName.includes('Teacher')) {
                        teachers.push(teacherName);
                    }
                }
            }

            console.log('Teachers found:', teachers);

            const extracted = extractSubjectsFromParsedData(parsedData, { debug: true });
            subjects = extracted.subjects;
            subjectLineMapping = extracted.subjectLineMapping;

            console.log('Final allocations:', allocations);
            console.log('Total subjects found:', subjects.length);
            console.log('Total allocations made:', Object.keys(allocations).length);
            console.log('=== END DEBUGGING ===');

            csvData = parsedData;
        }

        // Autocomplete functions
        function showAutocomplete(title, items, callback) {
            const modal = document.getElementById('autocompleteModal');
            const modalTitle = document.getElementById('modalTitle');
            const input = document.getElementById('autocompleteInput');
            const list = document.getElementById('autocompleteList');

            modalTitle.textContent = title;
            input.value = '';
            list.innerHTML = '';
            selectedIndex = -1;
            currentAutocompleteCallback = callback;
            allAutocompleteItems = Array.isArray(items) ? items.slice() : [];
            filteredItems = [...allAutocompleteItems];

            modal.style.display = 'block';
            input.focus();
            updateFilteredList('');
        }

        function updateFilteredList(query = '') {
            const list = document.getElementById('autocompleteList');
            if (!list) {
                return;
            }

            const normalizedQuery = typeof query === 'string' ? query.trim().toLowerCase() : '';
            if (!Array.isArray(allAutocompleteItems)) {
                allAutocompleteItems = [];
            }

            if (normalizedQuery.length === 0) {
                filteredItems = [...allAutocompleteItems];
            } else {
                filteredItems = allAutocompleteItems.filter(item =>
                    item.toLowerCase().includes(normalizedQuery)
                );
            }

            list.innerHTML = '';

            if (filteredItems.length === 0) {
                const emptyMessage = document.createElement('div');
                emptyMessage.className = 'autocomplete-item empty-message';
                emptyMessage.textContent = 'No matches found';
                list.appendChild(emptyMessage);
            } else {
                filteredItems.forEach(item => {
                    const div = document.createElement('div');
                    div.className = 'autocomplete-item';
                    div.textContent = item;
                    div.addEventListener('click', () => {
                        invokeAutocompleteCallback(item);
                    });
                    list.appendChild(div);
                });
            }

            list.style.display = 'block';
            selectedIndex = -1;
            list.scrollTop = 0;
            updateSelection();
        }

        function invokeAutocompleteCallback(selectedItem) {
            const callback = currentAutocompleteCallback;
            closeModal();
            if (typeof callback === 'function') {
                callback(selectedItem);
            }
        }

        function selectItem(index) {
            selectedIndex = index;
            updateSelection();

            const input = document.getElementById('autocompleteInput');
            if (filteredItems[index]) {
                input.value = filteredItems[index];
            }

            const list = document.getElementById('autocompleteList');
            list.style.display = 'none';
        }

        function updateSelection() {
            const allItems = document.querySelectorAll('.autocomplete-item');
            allItems.forEach(item => item.classList.remove('selected'));

            if (selectedIndex < 0) {
                return;
            }

            const selectableItems = document.querySelectorAll('.autocomplete-item:not(.empty-message)');
            if (selectableItems.length === 0) {
                selectedIndex = -1;
                return;
            }

            if (selectedIndex >= selectableItems.length) {
                selectedIndex = selectableItems.length - 1;
            }

            if (selectedIndex >= 0 && selectableItems[selectedIndex]) {
                const selectedItem = selectableItems[selectedIndex];
                selectedItem.classList.add('selected');
                selectedItem.scrollIntoView({ block: 'nearest' });
            }
        }

        function confirmSelection() {
            const input = document.getElementById('autocompleteInput');
            const items = document.querySelectorAll('.autocomplete-item:not(.empty-message)');

            if (selectedIndex >= 0 && selectedIndex < items.length) {
                const selectedItem = filteredItems[selectedIndex];
                if (selectedItem !== undefined) {
                    invokeAutocompleteCallback(selectedItem);
                }
            } else {
                // Try to find exact match from the original list
                const exactMatch = allAutocompleteItems.find(item =>
                    item.toLowerCase() === input.value.toLowerCase()
                );
                if (exactMatch) {
                    invokeAutocompleteCallback(exactMatch);
                } else {
                    alert('Please select a valid option from the list.');
                }
            }
        }

        function closeModal() {
            const modal = document.getElementById('autocompleteModal');
            const input = document.getElementById('autocompleteInput');
            const list = document.getElementById('autocompleteList');
            
            modal.style.display = 'none';
            input.value = '';
            list.innerHTML = '';
            list.style.display = 'none';
            currentAutocompleteCallback = null;
            selectedIndex = -1;
            filteredItems = [];
            allAutocompleteItems = [];

            // Small delay to ensure modal is fully closed before next operation
        }

        // Get available (unallocated) subjects
        function getAvailableSubjects() {
            const allocatedSubjects = new Set(flattenAllocatedSubjects());
            return subjects.filter(subject => {
                if (subjectSplits[subject]) {
                    return false;
                }
                return !allocatedSubjects.has(subject);
            });
        }

        // Get allocated subjects with their current teacher
        function getAllocatedSubjects() {
            const allocatedList = [];
            Object.entries(allocations).forEach(([key, value]) => {
                const [lineIndex, teacherIndex] = key.split('-').map(Number);
                const subjectList = Array.isArray(value) ? value : [value];

                subjectList.forEach(subject => {
                    allocatedList.push({
                        subject: subject,
                        teacher: teachers[teacherIndex],
                        teacherIndex: teacherIndex,
                        line: lines[lineIndex],
                        lineIndex: lineIndex
                    });
                });
            });
            return allocatedList;
        }

        // Allocate new subject code
        function allocateNewSubject() {
            if (subjects.length === 0) {
                alert('Please import spreadsheet data first!');
                return;
            }

            const availableSubjects = getAvailableSubjects();
            if (availableSubjects.length === 0) {
                alert('No available subject codes to allocate!');
                return;
            }

            // Show subject code autocomplete
            showAutocomplete('Select Subject Code', availableSubjects, function(selectedSubject) {
                // Show teacher autocomplete with a small delay
                setTimeout(() => {
                    showAutocomplete('Select Teacher for ' + selectedSubject, teachers, function(selectedTeacher) {
                        const teacherIndex = teachers.indexOf(selectedTeacher);
                        if (allocateSubjectToTeacher(selectedSubject, teacherIndex)) {
                            alert('Subject ' + selectedSubject + ' allocated to ' + selectedTeacher + ' successfully!');
                        } else {
                            alert('Unable to allocate this subject to the selected teacher.');
                        }
                    });
                }, 200); // 200ms delay to ensure first modal is fully closed
            });
        }

        function splitSubject() {
            if (subjects.length === 0) {
                alert('Please import spreadsheet data first!');
                return;
            }

            const labelToSubject = new Map();

            subjects.forEach(subject => {
                if (!isSplitSubject(subject) && !subjectSplits[subject]) {
                    labelToSubject.set(subject, subject);
                }
            });

            Object.keys(subjectSplits).forEach(baseSubject => {
                const label = `${baseSubject} (currently split)`;
                labelToSubject.set(label, baseSubject);
            });

            const labels = Array.from(labelToSubject.keys());

            if (labels.length === 0) {
                alert('No subjects are available to split at this time.');
                return;
            }

            showAutocomplete('Select subject to split', labels, function(selectedLabel) {
                const baseSubject = labelToSubject.get(selectedLabel);

                if (!baseSubject) {
                    alert('Invalid subject selection.');
                    return;
                }

                const existingLocation = findSubjectLocation(baseSubject);
                if (existingLocation) {
                    alert('Please remove this subject from the timetable before splitting it.');
                    return;
                }

                const existingSplits = subjectSplits[baseSubject] || [];
                const activeSplit = existingSplits.find(split => findSubjectLocation(split.code));
                if (activeSplit) {
                    alert('Please remove all allocated split portions for this subject before changing the split.');
                    return;
                }

                const totalPeriods = getSubjectPeriodValue(baseSubject);
                if (!Number.isFinite(totalPeriods) || totalPeriods <= 0) {
                    alert('Unable to determine the period value for the selected subject.');
                    return;
                }

                setTimeout(() => {
                    const input = prompt(`Enter the number of periods for each portion of ${baseSubject} (total ${totalPeriods} periods). Separate values with commas, e.g. 4,3.`);
                    if (input === null) {
                        return;
                    }

                    const sanitized = input.replace(/\+/g, ',');
                    const splitValues = sanitized
                        .split(',')
                        .map(value => parseInt(value.trim(), 10))
                        .filter(value => Number.isFinite(value) && value > 0);

                    if (splitValues.length === 0) {
                        alert('Please enter at least one positive number.');
                        return;
                    }

                    const sum = splitValues.reduce((acc, value) => acc + value, 0);
                    if (sum !== totalPeriods) {
                        alert(`The split values must add up to ${totalPeriods} periods. Currently they add up to ${sum}.`);
                        return;
                    }

                    const existingSplitCodes = new Set(existingSplits.map(split => split.code));
                    const removalSet = new Set(existingSplitCodes);
                    removalSet.add(baseSubject);

                    let insertIndex = subjects.findIndex(subject => removalSet.has(subject));
                    if (insertIndex === -1 && existingSplits.length > 0) {
                        const firstExistingSplitIndex = subjects.findIndex(subject => existingSplitCodes.has(subject));
                        if (firstExistingSplitIndex !== -1) {
                            insertIndex = firstExistingSplitIndex;
                        }
                    }
                    if (insertIndex === -1) {
                        insertIndex = subjects.length;
                    }

                    subjects = subjects.filter(subject => !removalSet.has(subject));

                    existingSplits.forEach(split => {
                        delete subjectLineMapping[split.code];
                    });

                    if (splitValues.length === 1 && splitValues[0] === totalPeriods) {
                        delete subjectSplits[baseSubject];
                        rebuildSplitLookup();

                        subjects.splice(insertIndex, 0, baseSubject);

                        removalSet.forEach(subject => removeSubjectFromPool(subject));

                        createSubjectPool();
                        updateStats();

                        alert(`${baseSubject} has been restored to a single ${totalPeriods}-period allocation.`);
                        return;
                    }

                    const mappedLine = subjectLineMapping[baseSubject];
                    const totalSplits = splitValues.length;
                    const newSplits = splitValues.map((periods, index) => {
                        const code = `${baseSubject} ▸ ${periods}p (Split ${index + 1}/${totalSplits})`;
                        return {
                            code: code,
                            periods: periods,
                            index: index,
                            totalSplits: totalSplits
                        };
                    });

                    subjectSplits[baseSubject] = newSplits;
                    rebuildSplitLookup();

                    const newCodes = newSplits.map(split => split.code);
                    subjects.splice(insertIndex, 0, ...newCodes);

                    newCodes.forEach(code => {
                        if (mappedLine !== undefined) {
                            subjectLineMapping[code] = mappedLine;
                        }
                    });

                    removalSet.forEach(subject => removeSubjectFromPool(subject));

                    createSubjectPool();
                    updateStats();

                    alert(`Created ${newSplits.length} split allocation${newSplits.length === 1 ? '' : 's'} for ${baseSubject}.`);
                }, 200);
            });
        }

        // Move existing allocation between teachers
        function moveExistingAllocation() {
            const allocatedSubjects = getAllocatedSubjects();
            if (allocatedSubjects.length === 0) {
                alert('No allocated subjects to move!');
                return;
            }

            const subjectList = allocatedSubjects.map(item => 
                `${item.subject} (currently with ${item.teacher})`
            );

            // Show subject selection autocomplete
            showAutocomplete('Select Subject to Move', subjectList, function(selectedSubjectText) {
                // Find the allocation
                const allocation = allocatedSubjects.find(item => selectedSubjectText.includes(item.subject));
                if (!allocation) {
                    alert('Subject allocation not found!');
                    return;
                }
                // Show teacher selection autocomplete with a small delay
                setTimeout(() => {
                    showAutocomplete(`Move ${allocation.subject} to which teacher?`, teachers, function(selectedTeacher) {
                        const newTeacherIndex = teachers.indexOf(selectedTeacher);

                        if (allocateSubjectToTeacher(allocation.subject, newTeacherIndex, allocation.lineIndex)) {
                            alert(`${allocation.subject} moved from ${allocation.teacher} to ${selectedTeacher} on Line ${allocation.lineIndex + 1} successfully!`);
                        } else {
                            alert(`${allocation.subject} is already allocated to ${selectedTeacher} on Line ${allocation.lineIndex + 1}.`);
                        }
                    });
                }, 200); // 200ms delay to ensure first modal is fully closed
            });
        }

        // Function to record actions for undo functionality
        function recordAction(actionType, subjectCode, fromTeacher, toTeacher, lineIndex, fromLineIndex = null) {
            actionHistory.push({
                type: actionType,
                subject: subjectCode,
                fromTeacher: fromTeacher,
                toTeacher: toTeacher,
                lineIndex: lineIndex,
                fromLineIndex: fromLineIndex,
                timestamp: Date.now()
            });

            if (actionHistory.length > 10) {
                actionHistory.shift();
            }

            const undoBtn = document.getElementById('undoBtn');
            if (undoBtn) {
                undoBtn.disabled = actionHistory.length === 0;
            }

            redoStack = [];
            const redoBtn = document.getElementById('redoBtn');
            if (redoBtn) {
                redoBtn.disabled = true;
            }

            console.log('Action recorded:', actionHistory[actionHistory.length - 1]);
        }

        function allocateSubjectToTeacher(subjectCode, teacherIndex, preferredLine = null, options = {}) {
            if (teacherIndex < 0 || teacherIndex >= teachers.length) {
                return false;
            }

            let targetLine = preferredLine;

            if (targetLine === null && subjectLineMapping[subjectCode] !== undefined) {
                targetLine = subjectLineMapping[subjectCode];
                console.log(`Subject ${subjectCode} must stay in Line ${targetLine + 1}`);
            }

            if (targetLine === null) {
                const teacherCells = document.querySelectorAll(`[data-teacher="${teacherIndex}"]`);
                if (teacherCells.length === 0) {
                    return false;
                }
                targetLine = parseInt(teacherCells[0].dataset.period);
            }

            const cell = document.querySelector(`[data-period="${targetLine}"][data-teacher="${teacherIndex}"]`);
            if (!cell) {
                return false;
            }

            const key = getAllocationKey(targetLine, teacherIndex);
            const currentSubjects = getAllocationSubjects(key);
            if (currentSubjects.includes(subjectCode)) {
                return false;
            }

            const existingLocation = findSubjectLocation(subjectCode);
            let fromTeacher = null;
            let fromLineIndex = null;

            if (existingLocation) {
                fromTeacher = existingLocation.teacherIndex;
                fromLineIndex = existingLocation.lineIndex;

                const previousSubjects = getAllocationSubjects(existingLocation.key)
                    .filter(subject => subject !== subjectCode);
                setAllocationSubjects(existingLocation.key, previousSubjects);
                renderCell(existingLocation.lineIndex, existingLocation.teacherIndex);
            }

            currentSubjects.push(subjectCode);
            setAllocationSubjects(key, currentSubjects);
            renderCell(targetLine, teacherIndex);

            removeSubjectFromPool(subjectCode);

            if (options.recordAction !== false) {
                recordAction(
                    fromTeacher !== null ? 'move' : 'allocate',
                    subjectCode,
                    fromTeacher,
                    teacherIndex,
                    targetLine,
                    fromLineIndex
                );
            }

            updateStats();
            return true;
        }

        // Undo functionality
        function undoLastAction() {
            if (actionHistory.length === 0) {
                alert('No actions to undo');
                return;
            }

            const lastAction = actionHistory.pop();
            console.log('Undoing action:', lastAction);

            let undone = false;

            if (lastAction.type === 'allocate') {
                const allocationKey = getAllocationKey(lastAction.lineIndex, lastAction.toTeacher);
                const remainingSubjects = getAllocationSubjects(allocationKey)
                    .filter(subject => subject !== lastAction.subject);
                setAllocationSubjects(allocationKey, remainingSubjects);
                renderCell(lastAction.lineIndex, lastAction.toTeacher);
                addSubjectToPool(lastAction.subject);
                undone = true;
            } else if (lastAction.type === 'move') {
                const currentKey = getAllocationKey(lastAction.lineIndex, lastAction.toTeacher);
                const remainingSubjects = getAllocationSubjects(currentKey)
                    .filter(subject => subject !== lastAction.subject);
                setAllocationSubjects(currentKey, remainingSubjects);
                renderCell(lastAction.lineIndex, lastAction.toTeacher);

                if (lastAction.fromTeacher !== null) {
                    const originalLine = lastAction.fromLineIndex !== null ? lastAction.fromLineIndex : lastAction.lineIndex;
                    const originalKey = getAllocationKey(originalLine, lastAction.fromTeacher);
                    const originalSubjects = getAllocationSubjects(originalKey);

                    if (!originalSubjects.includes(lastAction.subject)) {
                        originalSubjects.push(lastAction.subject);
                        setAllocationSubjects(originalKey, originalSubjects);
                    }

                    renderCell(originalLine, lastAction.fromTeacher);
                }

                undone = true;
            }

            if (!undone) {
                actionHistory.push(lastAction);
                return;
            }

            redoStack.push(lastAction);
            if (redoStack.length > 10) {
                redoStack.shift();
            }

            const redoBtn = document.getElementById('redoBtn');
            if (redoBtn) {
                redoBtn.disabled = false;
            }

            updateStats();

            const undoBtn = document.getElementById('undoBtn');
            if (undoBtn) {
                undoBtn.disabled = actionHistory.length === 0;
            }
        }

        function redoLastAction() {
            if (redoStack.length === 0) {
                alert('No actions to redo');
                return;
            }

            const actionToRedo = redoStack.pop();
            console.log('Redoing action:', actionToRedo);

            let success = false;

            if (actionToRedo.type === 'allocate') {
                success = allocateSubjectToTeacher(actionToRedo.subject, actionToRedo.toTeacher, actionToRedo.lineIndex, { recordAction: false });
            } else if (actionToRedo.type === 'move') {
                success = allocateSubjectToTeacher(actionToRedo.subject, actionToRedo.toTeacher, actionToRedo.lineIndex, { recordAction: false });
            }

            if (!success) {
                redoStack.push(actionToRedo);
                alert('Unable to redo the last action.');
                return;
            }

            actionHistory.push(actionToRedo);
            if (actionHistory.length > 10) {
                actionHistory.shift();
            }

            const undoBtn = document.getElementById('undoBtn');
            if (undoBtn) {
                undoBtn.disabled = false;
            }

            if (redoStack.length === 0) {
                const redoBtn = document.getElementById('redoBtn');
                if (redoBtn) {
                    redoBtn.disabled = true;
                }
            }
        }

        function showAllocationPopup(lineIndex, teacherIndex) {
            if (subjects.length === 0) {
                alert('Please import spreadsheet data first!');
                return;
            }

            // Validate indices
            if (teacherIndex < 0 || teacherIndex >= teachers.length) {
                alert('Invalid teacher selection!');
                return;
            }
            if (lineIndex < 0 || lineIndex >= lines.length) {
                alert('Invalid line selection!');
                return;
            }

            const teacherName = teachers[teacherIndex];
            const lineName = lines[lineIndex];
            const availableSubjects = getAvailableSubjects();
            
            if (availableSubjects.length === 0) {
                alert('No available subject codes to allocate!');
                return;
            }

            // Show subject autocomplete
            showAutocomplete(`Allocate subject to ${teacherName} on ${lineName}`, availableSubjects, function(selectedSubject) {
                if (!allocateSubjectToTeacher(selectedSubject, teacherIndex, lineIndex)) {
                    alert('Unable to allocate ' + selectedSubject + ' to ' + teacherName + ' on ' + lineName + '.');
                }
            });
        }

        function saveAllocations() {
            const data = {
                allocations: allocations,
                timestamp: new Date().toISOString(),
                subjects: subjects,
                teachers: teachers,
                lines: lines,
                csvData: csvData,
                subjectLineMapping: subjectLineMapping,
                subjectSplits: subjectSplits,
                teacherLoadSettings: teacherLoadSettings
            };

            localStorage.setItem('facultyAllocations', JSON.stringify(data));
            alert('Allocations saved successfully!');
        }

        function resetAllocations() {
            if (confirm('Are you sure you want to reset all allocations? This action cannot be undone.')) {
                allocations = {};
                actionHistory = []; // Clear undo history
                redoStack = [];

                renderAllAllocations();

                // Disable undo button
                const undoBtn = document.getElementById('undoBtn');
                if (undoBtn) {
                    undoBtn.disabled = true;
                }

                const redoBtn = document.getElementById('redoBtn');
                if (redoBtn) {
                    redoBtn.disabled = true;
                }

                // Recreate subject pool
                createSubjectPool();
                updateStats();
            }
        }

        function getSubjectYearLabel(subjectCode) {
            if (!subjectCode) {
                return null;
            }

            const splitInfo = getSplitMetadata(subjectCode);
            const baseSubject = splitInfo ? splitInfo.baseSubject : subjectCode;

            if (!baseSubject) {
                return null;
            }

            const normalized = normalizeSubjectCodeForPeriods(baseSubject);
            if (!normalized) {
                return null;
            }

            const match = normalized.match(/^(\d{1,2})/);
            if (!match) {
                return null;
            }

            const yearValue = parseInt(match[1], 10);
            if (!Number.isInteger(yearValue)) {
                return null;
            }

            return `Year ${yearValue}`;
        }

        function formatSubjectForExport(subject) {
            if (typeof subject !== 'string') {
                return '';
            }

            const cleanedSubject = subject.trim();
            if (cleanedSubject === '') {
                return '';
            }

            const yearLabel = getSubjectYearLabel(cleanedSubject);
            const splitInfo = getSplitMetadata(cleanedSubject);

            let formattedSubject = '';

            if (!splitInfo) {
                formattedSubject = cleanedSubject;
            } else {
                const baseLabel = (typeof splitInfo.baseSubject === 'string' && splitInfo.baseSubject.trim() !== '')
                    ? splitInfo.baseSubject.trim()
                    : cleanedSubject;

                const periodLabel = Number.isFinite(splitInfo.periods) && splitInfo.periods > 0
                    ? `${splitInfo.periods}p`
                    : '';

                const hasValidTotal = Number.isFinite(splitInfo.totalSplits) && splitInfo.totalSplits > 0;
                const partIndex = Number.isFinite(splitInfo.index) ? splitInfo.index + 1 : null;

                let splitLabel = '';
                if (partIndex !== null && hasValidTotal) {
                    splitLabel = `Split ${partIndex}/${splitInfo.totalSplits}`;
                } else if (partIndex !== null) {
                    splitLabel = `Split ${partIndex}`;
                } else if (hasValidTotal && splitInfo.totalSplits > 1) {
                    splitLabel = `Split of ${splitInfo.totalSplits}`;
                }

                if (!periodLabel && !splitLabel) {
                    formattedSubject = baseLabel;
                } else if (periodLabel && splitLabel) {
                    formattedSubject = `${baseLabel} - ${periodLabel} (${splitLabel})`;
                } else if (periodLabel) {
                    formattedSubject = `${baseLabel} - ${periodLabel}`;
                } else {
                    formattedSubject = `${baseLabel} - ${splitLabel}`;
                }
            }

            return yearLabel ? `${yearLabel} – ${formattedSubject}` : formattedSubject;
        }

        function formatSubjectsForCellExport(subjects) {
            if (!Array.isArray(subjects) || subjects.length === 0) {
                return '';
            }

            const sanitizedSubjects = subjects
                .map(subject => (typeof subject === 'string' ? subject.trim() : ''))
                .filter(subject => subject !== '');

            if (sanitizedSubjects.length === 0) {
                return '';
            }

            const sortedSubjects = sanitizedSubjects
                .map(subject => {
                    const splitInfo = getSplitMetadata(subject);
                    const baseSubject = splitInfo ? splitInfo.baseSubject : subject;
                    const normalizedBase = baseSubject ? normalizeSubjectCodeForPeriods(baseSubject) : '';
                    const match = normalizedBase.match(/^(\d{1,2})/);
                    const yearValue = match ? parseInt(match[1], 10) : null;
                    const sortKey = normalizedBase && normalizedBase.trim().length > 0
                        ? normalizedBase
                        : (baseSubject || subject);

                    return {
                        subject: subject,
                        baseSubject: baseSubject || subject,
                        year: Number.isInteger(yearValue) ? yearValue : null,
                        splitIndex: splitInfo && Number.isFinite(splitInfo.index) ? splitInfo.index : 0,
                        sortKey: sortKey
                    };
                })
                .sort((a, b) => {
                    if (a.year !== null && b.year !== null && a.year !== b.year) {
                        return b.year - a.year;
                    }

                    if (a.sortKey !== b.sortKey) {
                        return a.sortKey.localeCompare(b.sortKey);
                    }

                    if (a.splitIndex !== b.splitIndex) {
                        return a.splitIndex - b.splitIndex;
                    }

                    return a.subject.localeCompare(b.subject);
                })
                .map(item => item.subject);

            const formatted = sortedSubjects.map(formatSubjectForExport);
            return formatted.join(formatted.length > 1 ? ' | ' : '');
        }

        function buildAllocationSpreadsheetRows() {
            const teacherList = Array.isArray(teachers) ? teachers : [];
            const lineList = Array.isArray(lines) ? lines : [];

            const rows = [];
            rows.push(['Line', ...teacherList]);

            lineList.forEach((lineNameValue, lineIndex) => {
                const lineName = typeof lineNameValue === 'string' && lineNameValue.trim() !== ''
                    ? lineNameValue
                    : `Line ${lineIndex + 1}`;

                const row = [lineName];

                teacherList.forEach((_, teacherIndex) => {
                    const key = getAllocationKey(lineIndex, teacherIndex);
                    const subjects = getAllocationSubjects(key);
                    row.push(formatSubjectsForCellExport(subjects));
                });

                rows.push(row);
            });

            if (teacherList.length > 0) {
                const totals = calculateTeacherPeriodTotals();
                const totalRow = ['Total Periods (per fortnight)'];

                teacherList.forEach((_, teacherIndex) => {
                    const totalValue = Array.isArray(totals) && Number.isFinite(totals[teacherIndex])
                        ? totals[teacherIndex]
                        : 0;
                    totalRow.push(totalValue);
                });

                rows.push(totalRow);
            }

            return rows;
        }

        function convertRowsToCSV(rows) {
            if (!Array.isArray(rows)) {
                return '';
            }

            const csvLines = rows.map(row => {
                const cells = Array.isArray(row) ? row : [];
                return cells.map(cell => {
                    let value = cell === null || cell === undefined ? '' : String(cell);
                    value = value.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
                    value = value.replace(/[\u2013\u2014]/g, '-');

                    if (value.includes('"')) {
                        value = value.replace(/"/g, '""');
                    }

                    if (/[",\n]/.test(value)) {
                        value = `"${value}"`;
                    }

                    return value;
                }).join(',');
            });

            return csvLines.join('\r\n');
        }

        function downloadAllocationSpreadsheet() {
            if (!Array.isArray(teachers) || teachers.length === 0) {
                alert('No teacher data available to export. Import spreadsheet data to begin.');
                return;
            }

            const rows = buildAllocationSpreadsheetRows();
            if (!rows || rows.length === 0) {
                alert('No allocation data available to export.');
                return;
            }

            const csvContent = convertRowsToCSV(rows);
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const today = new Date().toISOString().split('T')[0];
            a.href = url;
            a.download = `teacher-allocations-${today}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function exportData() {
            if (!Array.isArray(teachers) || teachers.length === 0) {
                alert('No teacher data available to export. Import spreadsheet data to begin.');
                return;
            }

            const rows = buildAllocationSpreadsheetRows();
            if (!rows || rows.length === 0) {
                alert('No allocation data available to export.');
                return;
            }

            const csvContent = convertRowsToCSV(rows);
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'export.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function importData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const data = JSON.parse(e.target.result);
                            loadAllocations(data);
                        } catch (error) {
                            alert('Error importing data: ' + error.message);
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        function loadAllocations(data) {
            allocations = {};
            actionHistory = [];
            redoStack = [];

            const undoBtn = document.getElementById('undoBtn');
            if (undoBtn) {
                undoBtn.disabled = true;
            }

            const redoBtn = document.getElementById('redoBtn');
            if (redoBtn) {
                redoBtn.disabled = true;
            }

            if (data.subjects) subjects = data.subjects;
            if (data.teachers) teachers = data.teachers;
            if (data.lines) lines = data.lines;

            if (!Array.isArray(teachers)) {
                teachers = [];
            }

            if (data.teacherLoadSettings && typeof data.teacherLoadSettings === 'object') {
                try {
                    teacherLoadSettings = JSON.parse(JSON.stringify(data.teacherLoadSettings));
                } catch (error) {
                    teacherLoadSettings = { ...data.teacherLoadSettings };
                }
            } else if (!teacherLoadSettings || typeof teacherLoadSettings !== 'object') {
                teacherLoadSettings = {};
            }

            teachers.forEach(teacher => {
                getTeacherLoadSettings(teacher);
            });

            if (!Array.isArray(subjects)) {
                subjects = [];
            }

            if (data.subjectSplits) {
                try {
                    subjectSplits = JSON.parse(JSON.stringify(data.subjectSplits));
                } catch (error) {
                    subjectSplits = data.subjectSplits;
                }
                rebuildSplitLookup();
            } else {
                resetSplitData();
            }

            if (Array.isArray(subjects) && Object.keys(subjectSplits).length > 0) {
                const splitCodes = [];
                Object.values(subjectSplits).forEach(splits => {
                    if (!Array.isArray(splits)) {
                        return;
                    }
                    splits.forEach(split => {
                        if (split && typeof split.code === 'string') {
                            splitCodes.push(split.code);
                        }
                    });
                });

                const baseSubjects = new Set(Object.keys(subjectSplits));
                subjects = subjects.filter(subject => !baseSubjects.has(subject));

                splitCodes.forEach(code => {
                    if (!subjects.includes(code)) {
                        subjects.push(code);
                    }
                });
            }

            let parsedCSV = null;
            if (data.csvData) {
                if (Array.isArray(data.csvData)) {
                    parsedCSV = data.csvData;
                } else if (typeof data.csvData === 'string') {
                    parsedCSV = convertCSVToArray(data.csvData);
                }
            }

            csvData = parsedCSV || [];

            if (data.subjectLineMapping) {
                subjectLineMapping = { ...data.subjectLineMapping };
            } else if (parsedCSV) {
                const extracted = extractSubjectsFromParsedData(parsedCSV);
                subjectLineMapping = extracted.subjectLineMapping;
                if (!data.subjects || data.subjects.length === 0) {
                    subjects = extracted.subjects;
                }
            } else {
                subjectLineMapping = {};
            }

            if (!Array.isArray(subjects)) {
                subjects = [];
            }

            if (data.allocations) {
                Object.entries(data.allocations).forEach(([key, value]) => {
                    const subjectsList = Array.isArray(value) ? value : [value];
                    setAllocationSubjects(key, subjectsList);
                });
            }

            initializeTimetable();
            createSubjectPool();
            updateStats();
        }

        function updateStats() {
            const totalSubjects = subjects.length;
            const allocatedSubjects = flattenAllocatedSubjects().length;
            const availableSubjects = getAvailableSubjects().length;
            const allocationPercentage = totalSubjects > 0 ? Math.round((allocatedSubjects / totalSubjects) * 100) : 0;

            document.getElementById('totalSubjects').textContent = totalSubjects;
            document.getElementById('allocatedSubjects').textContent = allocatedSubjects;
            document.getElementById('remainingSubjects').textContent = availableSubjects;
            document.getElementById('allocationPercentage').textContent = allocationPercentage + '%';

            updateTeacherPeriodTotals();
        }

        // Load saved data on page load
        function loadSavedData() {
            const savedData = localStorage.getItem('facultyAllocations');
            if (savedData) {
                try {
                    const data = JSON.parse(savedData);
                    loadAllocations(data);
                } catch (error) {
                    console.error('Error loading saved data:', error);
                }
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            try {
            initializeTimetable();
            loadSavedData();
                setupModalEventListeners();
            } catch (error) {
                console.error('Error during initialization:', error);
                alert('Error initializing application: ' + error.message);
            }
        });

        // Global error handler
        window.addEventListener('error', function(e) {
            console.error('JavaScript error:', e.error);
            alert('JavaScript error: ' + e.message);
        });


        function setupModalEventListeners() {
            const modal = document.getElementById('autocompleteModal');
            const input = document.getElementById('autocompleteInput');
            const confirmBtn = document.getElementById('confirmBtn');
            const cancelBtn = document.getElementById('cancelBtn');
            const closeBtn = document.querySelector('.close');

            // Close modal events
            closeBtn.addEventListener('click', closeModal);
            cancelBtn.addEventListener('click', closeModal);
            window.addEventListener('click', function(event) {
                if (event.target === modal) {
                    closeModal();
                }
            });

            // Confirm button
            confirmBtn.addEventListener('click', confirmSelection);

            // Input events
            input.addEventListener('input', function() {
                updateFilteredList(this.value);
            });

            // Keyboard navigation
            input.addEventListener('keydown', function(e) {
                const selectableItems = document.querySelectorAll('.autocomplete-item:not(.empty-message)');

                if (e.key === 'ArrowDown') {
                    if (selectableItems.length === 0) {
                        return;
                    }
                    e.preventDefault();
                    selectedIndex = Math.min(selectedIndex + 1, selectableItems.length - 1);
                    if (selectedIndex < 0) {
                        selectedIndex = 0;
                    }
                    updateSelection();
                } else if (e.key === 'ArrowUp') {
                    if (selectableItems.length === 0) {
                        return;
                    }
                    e.preventDefault();
                    selectedIndex = Math.max(selectedIndex - 1, -1);
                    updateSelection();
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    confirmSelection();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    closeModal();
                }
            });
        }
    </script>
</body>
</html>

